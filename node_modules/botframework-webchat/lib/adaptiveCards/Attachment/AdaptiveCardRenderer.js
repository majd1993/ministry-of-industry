"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _botframeworkWebchatComponent = require("botframework-webchat-component");

var _classnames = _interopRequireDefault(require("classnames"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _useAdaptiveCardsHostConfig = _interopRequireDefault(require("../hooks/useAdaptiveCardsHostConfig"));

var _useAdaptiveCardsPackage = _interopRequireDefault(require("../hooks/useAdaptiveCardsPackage"));

/* eslint no-magic-numbers: ["error", { "ignore": [-1, 0, 2] }] */
var ErrorBox = _botframeworkWebchatComponent.Components.ErrorBox;
var useDisabled = _botframeworkWebchatComponent.hooks.useDisabled,
    useLocalizer = _botframeworkWebchatComponent.hooks.useLocalizer,
    usePerformCardAction = _botframeworkWebchatComponent.hooks.usePerformCardAction,
    useRenderMarkdownAsHTML = _botframeworkWebchatComponent.hooks.useRenderMarkdownAsHTML,
    useScrollToEnd = _botframeworkWebchatComponent.hooks.useScrollToEnd,
    useStyleSet = _botframeworkWebchatComponent.hooks.useStyleSet;
var node_env = process.env.node_env || process.env.NODE_ENV;

function addClass(element, className) {
  var classNames = new Set(element.className.split(' '));

  if (!classNames.has(className)) {
    classNames.add(className);
    element.className = Array.from(classNames).join(' ');
    return true;
  }

  return false;
}

function addPersistentClassWithUndo(element, className) {
  if (addClass(element, className)) {
    // After we add the class, keep observing the element to make sure the class is not removed.
    var observer = new MutationObserver(function () {
      return addClass(element, className);
    });
    observer.observe(element, {
      attributes: true,
      attributeFilter: ['class']
    });
    return function () {
      var classNames = new Set(element.className.split(' '));
      classNames.delete(className);
      element.className = Array.from(classNames).join(' ');
      observer.disconnect();
    };
  }
}

function isPlainObject(obj) {
  return Object.getPrototypeOf(obj) === Object.prototype;
}

function setAttributeWithUndo(element, qualifiedName, nextValue) {
  var value = element.getAttribute(qualifiedName);

  if (value !== nextValue) {
    element.setAttribute(qualifiedName, nextValue);
    return function () {
      return value ? element.setAttribute(qualifiedName, value) : element.removeAttribute(qualifiedName);
    };
  }
}

var disabledHandler = function disabledHandler(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
  event.stopPropagation();
};

function addEventListenerOnceWithUndo(element, name, handler) {
  /* eslint-disable-next-line prefer-const */
  var detach;

  var detachingHandler = function detachingHandler(event) {
    try {
      handler(event);
    } finally {
      // IE11 does not support { once: true }, so we need to detach manually.
      detach();
    }
  };

  detach = function detach() {
    return element.removeEventListener(name, detachingHandler);
  };

  element.addEventListener(name, detachingHandler, {
    once: true
  });
  return detach;
}

function disableElementWithUndo(element) {
  var undoStack = [];
  var isActive = element === document.activeElement;
  var tag = element.nodeName.toLowerCase();
  /* eslint-disable-next-line default-case */

  switch (tag) {
    // Should we not disable <a>? Will some of the <a> are styled as button?
    case 'a':
      undoStack.push(addEventListenerOnceWithUndo(element, 'click', disabledHandler));
      break;

    case 'button':
    case 'input':
    case 'select':
    case 'textarea':
      undoStack.push(setAttributeWithUndo(element, 'aria-disabled', 'true'));

      if (isActive) {
        undoStack.push(addEventListenerOnceWithUndo(element, 'blur', function () {
          return undoStack.push(setAttributeWithUndo(element, 'disabled', 'disabled'));
        }));
      } else {
        undoStack.push(setAttributeWithUndo(element, 'disabled', 'disabled'));
      }

      if (tag === 'input' || tag === 'textarea') {
        undoStack.push(addEventListenerOnceWithUndo(element, 'click', disabledHandler));
        undoStack.push(setAttributeWithUndo(element, 'readonly', 'readonly'));
      } else if (tag === 'select') {
        undoStack.push.apply(undoStack, (0, _toConsumableArray2.default)([].map.call(element.querySelectorAll('option'), function (option) {
          return setAttributeWithUndo(option, 'disabled', 'disabled');
        })));
      }

      break;
  }

  return function () {
    return undoStack.forEach(function (undo) {
      return undo && undo();
    });
  };
}

function disableInputElementsWithUndo(element) {
  var observeSubtree = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var undoStack = [].map.call(element.querySelectorAll('a, button, input, select, textarea'), function (element) {
    return disableElementWithUndo(element);
  });
  var tag = element.nodeName.toLowerCase(); // Only set tabindex="-1" on focusable element. Otherwise, we will make <div> focusable by mouse.

  (tag === 'a' || tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea') && undoStack.push(setAttributeWithUndo(element, 'tabindex', '-1'));

  if (observeSubtree) {
    var observer = new MutationObserver(function (mutations) {
      return mutations.forEach(function (_ref) {
        var addedNodes = _ref.addedNodes;
        return undoStack.push.apply(undoStack, (0, _toConsumableArray2.default)(addedNodes.map(function (addedNode) {
          return disableInputElementsWithUndo(addedNode, false);
        })));
      });
    });
    observer.observe(element, {
      childList: true,
      subtree: true
    });
    undoStack.push(function () {
      return observer.disconnect();
    });
  }

  return function () {
    return undoStack.forEach(function (undo) {
      return undo && undo();
    });
  };
}

function getFocusableElements(element) {
  return [].filter.call(element.querySelectorAll(['a', 'body', 'button', 'frame', 'iframe', 'img', 'input', 'isindex', 'object', 'select', 'textarea', '[tabindex]'].join(', ')), function (element) {
    var tabIndex = (0, _botframeworkWebchatComponent.getTabIndex)(element);
    return typeof tabIndex === 'number' && tabIndex >= 0;
  });
}

function restoreActiveElementIndex(element, activeElementIndex) {
  var focusable = getFocusableElements(element)[activeElementIndex];
  focusable && focusable.focus();
}

function saveActiveElementIndex(element) {
  return getFocusableElements(element).indexOf(document.activeElement);
}

function restoreInputValues(element, inputValues) {
  var inputs = element.querySelectorAll('input, select, textarea');
  [].forEach.call(inputs, function (input, index) {
    var value = inputValues[index];

    if (typeof value !== 'undefined') {
      var tagName = input.tagName,
          type = input.type;

      if (tagName === 'INPUT' && (type === 'checkbox' || type === 'radio')) {
        input.checked = value;
      } else {
        input.value = value;
      }
    }
  });
}

function saveInputValues(element) {
  var inputs = element.querySelectorAll('input, select, textarea');
  return [].map.call(inputs, function (_ref2) {
    var checked = _ref2.checked,
        tagName = _ref2.tagName,
        type = _ref2.type,
        value = _ref2.value;

    if (tagName === 'INPUT' && (type === 'checkbox' || type === 'radio')) {
      return checked;
    }

    return value;
  });
}

var AdaptiveCardRenderer = function AdaptiveCardRenderer(_ref3) {
  var actionPerformedClassName = _ref3.actionPerformedClassName,
      adaptiveCard = _ref3.adaptiveCard,
      disabledFromProps = _ref3.disabled,
      tapAction = _ref3.tapAction;

  var _useStyleSet = useStyleSet(),
      _useStyleSet2 = (0, _slicedToArray2.default)(_useStyleSet, 1),
      adaptiveCardRendererStyleSet = _useStyleSet2[0].adaptiveCardRenderer;

  var _useAdaptiveCardsPack = (0, _useAdaptiveCardsPackage.default)(),
      _useAdaptiveCardsPack2 = (0, _slicedToArray2.default)(_useAdaptiveCardsPack, 1),
      _useAdaptiveCardsPack3 = _useAdaptiveCardsPack2[0],
      GlobalSettings = _useAdaptiveCardsPack3.GlobalSettings,
      HostConfig = _useAdaptiveCardsPack3.HostConfig;

  var _useState = (0, _react.useState)([]),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      actionsPerformed = _useState2[0],
      setActionsPerformed = _useState2[1];

  var _useAdaptiveCardsHost = (0, _useAdaptiveCardsHostConfig.default)(),
      _useAdaptiveCardsHost2 = (0, _slicedToArray2.default)(_useAdaptiveCardsHost, 1),
      adaptiveCardsHostConfig = _useAdaptiveCardsHost2[0];

  var _useDisabled = useDisabled(),
      _useDisabled2 = (0, _slicedToArray2.default)(_useDisabled, 1),
      disabledFromComposer = _useDisabled2[0];

  var _useState3 = (0, _react.useState)([]),
      _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
      errors = _useState4[0],
      setErrors = _useState4[1];

  var _useState5 = (0, _react.useState)(0),
      _useState6 = (0, _slicedToArray2.default)(_useState5, 2),
      lastRender = _useState6[0],
      setLastRender = _useState6[1];

  var activeElementIndexRef = (0, _react.useRef)(-1);
  var adaptiveCardElementRef = (0, _react.useRef)();
  var contentRef = (0, _react.useRef)();
  var inputValuesRef = (0, _react.useRef)([]);
  var localize = useLocalizer();
  var performCardAction = usePerformCardAction();
  var renderMarkdownAsHTML = useRenderMarkdownAsHTML();
  var scrollToEnd = useScrollToEnd();
  var disabled = disabledFromComposer || disabledFromProps; // TODO: [P2] #3199 We should consider using `adaptiveCard.selectAction` instead.
  // The null check for "tapAction" is in "handleClickAndKeyPressForTapAction".

  var handleClickAndKeyPress = (0, _react.useCallback)(function (event) {
    var key = event.key,
        target = event.target,
        type = event.type; // Some items, e.g. tappable text, cannot be disabled thru DOM attributes

    var current = contentRef.current;
    var adaptiveCardRoot = current.querySelector('.ac-adaptiveCard[tabindex="0"]');

    if (!adaptiveCardRoot) {
      return console.warn('botframework-webchat: No Adaptive Card root container can be found, probably on an unsupported Adaptive Card version.');
    } // For "keypress" event, we only listen to ENTER and SPACEBAR key.


    if (type === 'keypress') {
      if (key !== 'Enter' && key !== ' ') {
        return;
      }

      event.preventDefault();
    } // We will call performCardAction if either:
    // 1. We are on the target, or
    // 2. The event-dispatching element is not interactive


    if (target !== adaptiveCardRoot) {
      var tabIndex = (0, _botframeworkWebchatComponent.getTabIndex)(target); // If the user is clicking on something that is already clickable, do not allow them to click the card.
      // E.g. a hero card can be tappable, and image and buttons inside the hero card can also be tappable.

      if (typeof tabIndex === 'number' && tabIndex >= 0) {
        return;
      }
    }

    performCardAction(tapAction);
    scrollToEnd();
  }, [contentRef, performCardAction, scrollToEnd, tapAction]); // Only listen to event if it is not disabled and have "tapAction" prop.

  var handleClickAndKeyPressForTapAction = !disabled && tapAction ? handleClickAndKeyPress : undefined;
  var addActionsPerformed = (0, _react.useCallback)(function (action) {
    return !~actionsPerformed.indexOf(action) && setActionsPerformed([].concat((0, _toConsumableArray2.default)(actionsPerformed), [action]));
  }, [actionsPerformed, setActionsPerformed]);
  var handleExecuteAction = (0, _react.useCallback)(function (action) {
    // Some items, e.g. tappable image, cannot be disabled thru DOM attributes
    if (disabled) {
      return;
    }

    addActionsPerformed(action);
    var actionTypeName = action.getJsonTypeName();

    if (actionTypeName === 'Action.OpenUrl') {
      performCardAction({
        type: 'openUrl',
        value: action.url
      });
    } else if (actionTypeName === 'Action.Submit') {
      if (typeof action.data !== 'undefined') {
        var actionData = action.data;

        if (actionData && actionData.__isBotFrameworkCardAction) {
          var cardAction = actionData.cardAction;
          var displayText = cardAction.displayText,
              text = cardAction.text,
              type = cardAction.type,
              value = cardAction.value;
          performCardAction({
            displayText: displayText,
            text: text,
            type: type,
            value: value
          });
        } else {
          performCardAction({
            type: typeof action.data === 'string' ? 'imBack' : 'postBack',
            value: action.data
          });
        }
      }

      scrollToEnd();
    } else {
      console.error("Web Chat: received unknown action from Adaptive Cards");
      console.error(action);
    }
  }, [addActionsPerformed, disabled, performCardAction, scrollToEnd]);
  (0, _react.useLayoutEffect)(function () {
    var current = contentRef.current;

    if (!current || !adaptiveCard) {
      activeElementIndexRef.current = -1;
      inputValuesRef.current = [];
    } // Currently, the only way to set the Markdown engine is to set it thru static member of AdaptiveCard class
    // TODO: [P3] Checks if we could make the "renderMarkdownAsHTML" per card
    //       This could be limitations from Adaptive Cards package (not supported as of 1.2.5)
    //       Because there could be timing difference between .parse and .render, we could be using wrong Markdown engine


    adaptiveCard.constructor.onProcessMarkdown = function (text, result) {
      if (renderMarkdownAsHTML) {
        result.outputHtml = renderMarkdownAsHTML(text);
        result.didProcess = true;
      }
    };

    if (adaptiveCardsHostConfig) {
      adaptiveCard.hostConfig = isPlainObject(adaptiveCardsHostConfig) ? new HostConfig(adaptiveCardsHostConfig) : adaptiveCardsHostConfig;
    } // For accessibility issue #1340, `tabindex="0"` must not be set for the root container if it is not interactive.


    GlobalSettings.setTabIndexAtCardRoot = !!tapAction;

    var _adaptiveCard$validat = adaptiveCard.validateProperties(),
        failures = _adaptiveCard$validat.failures;

    if (failures.length) {
      return setErrors(failures.reduce(function (items, _ref4) {
        var errors = _ref4.errors;
        return [].concat((0, _toConsumableArray2.default)(items), (0, _toConsumableArray2.default)(errors.map(function (_ref5) {
          var message = _ref5.message;
          return new Error(message);
        })));
      }, []));
    }

    var element;

    try {
      element = adaptiveCard.render();
    } catch (error) {
      return setErrors([error]);
    }

    if (!element) {
      return setErrors([new Error('Adaptive Card rendered as empty element')]);
    } // Clear errors on next render


    setErrors([]);
    restoreInputValues(element, inputValuesRef.current);
    current.appendChild(element);
    adaptiveCardElementRef.current = element; // Focus can only be restored after the DOM is attached.

    restoreActiveElementIndex(element, activeElementIndexRef.current);
    setLastRender(Date.now());
    return function () {
      activeElementIndexRef.current = saveActiveElementIndex(element);
      inputValuesRef.current = saveInputValues(element);
      current.removeChild(adaptiveCardElementRef.current);
      adaptiveCardElementRef.current = undefined;
    };
  }, [adaptiveCard, adaptiveCardsHostConfig, contentRef, GlobalSettings, HostConfig, renderMarkdownAsHTML, setErrors, tapAction]);
  (0, _react.useEffect)(function () {
    // Set onExecuteAction without causing unnecessary re-render.
    adaptiveCard.onExecuteAction = disabled ? undefined : handleExecuteAction;
  }, [adaptiveCard, disabled, handleExecuteAction]);
  (0, _react.useEffect)(function () {
    // If the Adaptive Card get re-rendered, re-disable elements as needed.
    if (disabled) {
      return disableInputElementsWithUndo(adaptiveCardElementRef.current);
    }
  }, [disabled, lastRender]);
  (0, _react.useEffect)(function () {
    // If the Adaptive Card changed, reset all actions performed.
    setActionsPerformed([]);
  }, [adaptiveCard]);
  (0, _react.useEffect)(function () {
    // Add developers to highlight actions when they have been clicked.
    if (!actionPerformedClassName) {
      return;
    }

    var undoStack = actionsPerformed.map(function (_ref6) {
      var renderedElement = _ref6.renderedElement;
      return renderedElement && adaptiveCardElementRef.current.contains(renderedElement) && addPersistentClassWithUndo(renderedElement, actionPerformedClassName);
    });
    return function () {
      return undoStack.forEach(function (undo) {
        return undo && undo();
      });
    };
  }, [actionsPerformed, actionPerformedClassName, lastRender]);
  return errors.length ? node_env === 'development' ? /*#__PURE__*/_react.default.createElement(ErrorBox, {
    error: errors[0],
    type: localize('ADAPTIVE_CARD_ERROR_BOX_TITLE_RENDER')
  }) : false : /*#__PURE__*/_react.default.createElement("div", {
    className: (0, _classnames.default)(adaptiveCardRendererStyleSet + '', 'webchat__adaptive-card-renderer'),
    onClick: handleClickAndKeyPressForTapAction,
    onKeyPress: handleClickAndKeyPressForTapAction,
    ref: contentRef
  });
};

AdaptiveCardRenderer.defaultProps = {
  actionPerformedClassName: '',
  disabled: undefined,
  tapAction: undefined
};
AdaptiveCardRenderer.propTypes = {
  actionPerformedClassName: _propTypes.default.string,
  adaptiveCard: _propTypes.default.any.isRequired,
  disabled: _propTypes.default.bool,
  tapAction: _propTypes.default.shape({
    type: _propTypes.default.string.isRequired,
    value: _propTypes.default.string
  })
};
var _default = AdaptiveCardRenderer;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9hZGFwdGl2ZUNhcmRzL0F0dGFjaG1lbnQvQWRhcHRpdmVDYXJkUmVuZGVyZXIuanMiXSwibmFtZXMiOlsiRXJyb3JCb3giLCJDb21wb25lbnRzIiwidXNlRGlzYWJsZWQiLCJob29rcyIsInVzZUxvY2FsaXplciIsInVzZVBlcmZvcm1DYXJkQWN0aW9uIiwidXNlUmVuZGVyTWFya2Rvd25Bc0hUTUwiLCJ1c2VTY3JvbGxUb0VuZCIsInVzZVN0eWxlU2V0Iiwibm9kZV9lbnYiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJhZGRDbGFzcyIsImVsZW1lbnQiLCJjbGFzc05hbWUiLCJjbGFzc05hbWVzIiwiU2V0Iiwic3BsaXQiLCJoYXMiLCJhZGQiLCJBcnJheSIsImZyb20iLCJqb2luIiwiYWRkUGVyc2lzdGVudENsYXNzV2l0aFVuZG8iLCJvYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiYXR0cmlidXRlcyIsImF0dHJpYnV0ZUZpbHRlciIsImRlbGV0ZSIsImRpc2Nvbm5lY3QiLCJpc1BsYWluT2JqZWN0Iiwib2JqIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCJzZXRBdHRyaWJ1dGVXaXRoVW5kbyIsInF1YWxpZmllZE5hbWUiLCJuZXh0VmFsdWUiLCJ2YWx1ZSIsImdldEF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsImRpc2FibGVkSGFuZGxlciIsImV2ZW50IiwicHJldmVudERlZmF1bHQiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJzdG9wUHJvcGFnYXRpb24iLCJhZGRFdmVudExpc3RlbmVyT25jZVdpdGhVbmRvIiwibmFtZSIsImhhbmRsZXIiLCJkZXRhY2giLCJkZXRhY2hpbmdIYW5kbGVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbmNlIiwiZGlzYWJsZUVsZW1lbnRXaXRoVW5kbyIsInVuZG9TdGFjayIsImlzQWN0aXZlIiwiZG9jdW1lbnQiLCJhY3RpdmVFbGVtZW50IiwidGFnIiwibm9kZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsInB1c2giLCJtYXAiLCJjYWxsIiwicXVlcnlTZWxlY3RvckFsbCIsIm9wdGlvbiIsImZvckVhY2giLCJ1bmRvIiwiZGlzYWJsZUlucHV0RWxlbWVudHNXaXRoVW5kbyIsIm9ic2VydmVTdWJ0cmVlIiwibXV0YXRpb25zIiwiYWRkZWROb2RlcyIsImFkZGVkTm9kZSIsImNoaWxkTGlzdCIsInN1YnRyZWUiLCJnZXRGb2N1c2FibGVFbGVtZW50cyIsImZpbHRlciIsInRhYkluZGV4IiwicmVzdG9yZUFjdGl2ZUVsZW1lbnRJbmRleCIsImFjdGl2ZUVsZW1lbnRJbmRleCIsImZvY3VzYWJsZSIsImZvY3VzIiwic2F2ZUFjdGl2ZUVsZW1lbnRJbmRleCIsImluZGV4T2YiLCJyZXN0b3JlSW5wdXRWYWx1ZXMiLCJpbnB1dFZhbHVlcyIsImlucHV0cyIsImlucHV0IiwiaW5kZXgiLCJ0YWdOYW1lIiwidHlwZSIsImNoZWNrZWQiLCJzYXZlSW5wdXRWYWx1ZXMiLCJBZGFwdGl2ZUNhcmRSZW5kZXJlciIsImFjdGlvblBlcmZvcm1lZENsYXNzTmFtZSIsImFkYXB0aXZlQ2FyZCIsImRpc2FibGVkRnJvbVByb3BzIiwiZGlzYWJsZWQiLCJ0YXBBY3Rpb24iLCJhZGFwdGl2ZUNhcmRSZW5kZXJlclN0eWxlU2V0IiwiYWRhcHRpdmVDYXJkUmVuZGVyZXIiLCJHbG9iYWxTZXR0aW5ncyIsIkhvc3RDb25maWciLCJhY3Rpb25zUGVyZm9ybWVkIiwic2V0QWN0aW9uc1BlcmZvcm1lZCIsImFkYXB0aXZlQ2FyZHNIb3N0Q29uZmlnIiwiZGlzYWJsZWRGcm9tQ29tcG9zZXIiLCJlcnJvcnMiLCJzZXRFcnJvcnMiLCJsYXN0UmVuZGVyIiwic2V0TGFzdFJlbmRlciIsImFjdGl2ZUVsZW1lbnRJbmRleFJlZiIsImFkYXB0aXZlQ2FyZEVsZW1lbnRSZWYiLCJjb250ZW50UmVmIiwiaW5wdXRWYWx1ZXNSZWYiLCJsb2NhbGl6ZSIsInBlcmZvcm1DYXJkQWN0aW9uIiwicmVuZGVyTWFya2Rvd25Bc0hUTUwiLCJzY3JvbGxUb0VuZCIsImhhbmRsZUNsaWNrQW5kS2V5UHJlc3MiLCJrZXkiLCJ0YXJnZXQiLCJjdXJyZW50IiwiYWRhcHRpdmVDYXJkUm9vdCIsInF1ZXJ5U2VsZWN0b3IiLCJjb25zb2xlIiwid2FybiIsImhhbmRsZUNsaWNrQW5kS2V5UHJlc3NGb3JUYXBBY3Rpb24iLCJ1bmRlZmluZWQiLCJhZGRBY3Rpb25zUGVyZm9ybWVkIiwiYWN0aW9uIiwiaGFuZGxlRXhlY3V0ZUFjdGlvbiIsImFjdGlvblR5cGVOYW1lIiwiZ2V0SnNvblR5cGVOYW1lIiwidXJsIiwiZGF0YSIsImFjdGlvbkRhdGEiLCJfX2lzQm90RnJhbWV3b3JrQ2FyZEFjdGlvbiIsImNhcmRBY3Rpb24iLCJkaXNwbGF5VGV4dCIsInRleHQiLCJlcnJvciIsImNvbnN0cnVjdG9yIiwib25Qcm9jZXNzTWFya2Rvd24iLCJyZXN1bHQiLCJvdXRwdXRIdG1sIiwiZGlkUHJvY2VzcyIsImhvc3RDb25maWciLCJzZXRUYWJJbmRleEF0Q2FyZFJvb3QiLCJ2YWxpZGF0ZVByb3BlcnRpZXMiLCJmYWlsdXJlcyIsImxlbmd0aCIsInJlZHVjZSIsIml0ZW1zIiwibWVzc2FnZSIsIkVycm9yIiwicmVuZGVyIiwiYXBwZW5kQ2hpbGQiLCJEYXRlIiwibm93IiwicmVtb3ZlQ2hpbGQiLCJvbkV4ZWN1dGVBY3Rpb24iLCJyZW5kZXJlZEVsZW1lbnQiLCJjb250YWlucyIsImRlZmF1bHRQcm9wcyIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsInN0cmluZyIsImFueSIsImlzUmVxdWlyZWQiLCJib29sIiwic2hhcGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQVJBO0lBVVFBLFEsR0FBYUMsd0MsQ0FBYkQsUTtJQUNBRSxXLEdBQTBHQyxtQyxDQUExR0QsVztJ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QUFtQlQsd0JBQW5CLEVBQTZDZSxVQUE3QyxDQWRIO0FBZ0JBLFNBQU9GLE1BQU0sQ0FBQzRDLE1BQVAsR0FDTGxKLFFBQVEsS0FBSyxhQUFiLGdCQUNFLDZCQUFDLFFBQUQ7QUFBVSxJQUFBLEtBQUssRUFBRXNHLE1BQU0sQ0FBQyxDQUFELENBQXZCO0FBQTRCLElBQUEsSUFBSSxFQUFFUSxRQUFRLENBQUMsc0NBQUQ7QUFBMUMsSUFERixHQUdFLEtBSkcsZ0JBT0w7QUFDRSxJQUFBLFNBQVMsRUFBRSx5QkFBV2hCLDRCQUE0QixHQUFHLEVBQTFDLEVBQThDLGlDQUE5QyxDQURiO0FBRUUsSUFBQSxPQUFPLEVBQUU0QixrQ0FGWDtBQUdFLElBQUEsVUFBVSxFQUFFQSxrQ0FIZDtBQUlFLElBQUEsR0FBRyxFQUFFZDtBQUpQLElBUEY7QUFjRCxDQWxQRDs7QUFvUEFwQixvQkFBb0IsQ0FBQ3VFLFlBQXJCLEdBQW9DO0FBQ2xDdEUsRUFBQUEsd0JBQXdCLEVBQUUsRUFEUTtBQUVsQ0csRUFBQUEsUUFBUSxFQUFFK0IsU0FGd0I7QUFHbEM5QixFQUFBQSxTQUFTLEVBQUU4QjtBQUh1QixDQUFwQztBQU1BbkMsb0JBQW9CLENBQUN3RSxTQUFyQixHQUFpQztBQUMvQnZFLEVBQUFBLHdCQUF3QixFQUFFd0UsbUJBQVVDLE1BREw7QUFFL0J4RSxFQUFBQSxZQUFZLEVBQUV1RSxtQkFBVUUsR0FBVixDQUFjQyxVQUZHO0FBRy9CeEUsRUFBQUEsUUFBUSxFQUFFcUUsbUJBQVVJLElBSFc7QUFJL0J4RSxFQUFBQSxTQUFTLEVBQUVvRSxtQkFBVUssS0FBVixDQUFnQjtBQUN6QmpGLElBQUFBLElBQUksRUFBRTRFLG1CQUFVQyxNQUFWLENBQWlCRSxVQURFO0FBRXpCckksSUFBQUEsS0FBSyxFQUFFa0ksbUJBQVVDO0FBRlEsR0FBaEI7QUFKb0IsQ0FBakM7ZUFVZTFFLG9CIiwic291cmNlUm9vdCI6ImJ1bmRsZTovLy8iLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tbWFnaWMtbnVtYmVyczogW1wiZXJyb3JcIiwgeyBcImlnbm9yZVwiOiBbLTEsIDAsIDJdIH1dICovXG5cbmltcG9ydCB7IENvbXBvbmVudHMsIGdldFRhYkluZGV4LCBob29rcyB9IGZyb20gJ2JvdGZyYW1ld29yay13ZWJjaGF0LWNvbXBvbmVudCc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgdXNlQWRhcHRpdmVDYXJkc0hvc3RDb25maWcgZnJvbSAnLi4vaG9va3MvdXNlQWRhcHRpdmVDYXJkc0hvc3RDb25maWcnO1xuaW1wb3J0IHVzZUFkYXB0aXZlQ2FyZHNQYWNrYWdlIGZyb20gJy4uL2hvb2tzL3VzZUFkYXB0aXZlQ2FyZHNQYWNrYWdlJztcblxuY29uc3QgeyBFcnJvckJveCB9ID0gQ29tcG9uZW50cztcbmNvbnN0IHsgdXNlRGlzYWJsZWQsIHVzZUxvY2FsaXplciwgdXNlUGVyZm9ybUNhcmRBY3Rpb24sIHVzZVJlbmRlck1hcmtkb3duQXNIVE1MLCB1c2VTY3JvbGxUb0VuZCwgdXNlU3R5bGVTZXQgfSA9IGhvb2tzO1xuXG5jb25zdCBub2RlX2VudiA9IHByb2Nlc3MuZW52Lm5vZGVfZW52IHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WO1xuXG5mdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgY29uc3QgY2xhc3NOYW1lcyA9IG5ldyBTZXQoZWxlbWVudC5jbGFzc05hbWUuc3BsaXQoJyAnKSk7XG5cbiAgaWYgKCFjbGFzc05hbWVzLmhhcyhjbGFzc05hbWUpKSB7XG4gICAgY2xhc3NOYW1lcy5hZGQoY2xhc3NOYW1lKTtcblxuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gQXJyYXkuZnJvbShjbGFzc05hbWVzKS5qb2luKCcgJyk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYWRkUGVyc2lzdGVudENsYXNzV2l0aFVuZG8oZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gIGlmIChhZGRDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpKSB7XG4gICAgLy8gQWZ0ZXIgd2UgYWRkIHRoZSBjbGFzcywga2VlcCBvYnNlcnZpbmcgdGhlIGVsZW1lbnQgdG8gbWFrZSBzdXJlIHRoZSBjbGFzcyBpcyBub3QgcmVtb3ZlZC5cbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkpO1xuXG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7IGF0dHJpYnV0ZXM6IHRydWUsIGF0dHJpYnV0ZUZpbHRlcjogWydjbGFzcyddIH0pO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBuZXcgU2V0KGVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KCcgJykpO1xuXG4gICAgICBjbGFzc05hbWVzLmRlbGV0ZShjbGFzc05hbWUpO1xuXG4gICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IEFycmF5LmZyb20oY2xhc3NOYW1lcykuam9pbignICcpO1xuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVXaXRoVW5kbyhlbGVtZW50LCBxdWFsaWZpZWROYW1lLCBuZXh0VmFsdWUpIHtcbiAgY29uc3QgdmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShxdWFsaWZpZWROYW1lKTtcblxuICBpZiAodmFsdWUgIT09IG5leHRWYWx1ZSkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKHF1YWxpZmllZE5hbWUsIG5leHRWYWx1ZSk7XG5cbiAgICByZXR1cm4gKCkgPT4gKHZhbHVlID8gZWxlbWVudC5zZXRBdHRyaWJ1dGUocXVhbGlmaWVkTmFtZSwgdmFsdWUpIDogZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUocXVhbGlmaWVkTmFtZSkpO1xuICB9XG59XG5cbmNvbnN0IGRpc2FibGVkSGFuZGxlciA9IGV2ZW50ID0+IHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufTtcblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lck9uY2VXaXRoVW5kbyhlbGVtZW50LCBuYW1lLCBoYW5kbGVyKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3QgKi9cbiAgbGV0IGRldGFjaDtcbiAgY29uc3QgZGV0YWNoaW5nSGFuZGxlciA9IGV2ZW50ID0+IHtcbiAgICB0cnkge1xuICAgICAgaGFuZGxlcihldmVudCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCB7IG9uY2U6IHRydWUgfSwgc28gd2UgbmVlZCB0byBkZXRhY2ggbWFudWFsbHkuXG4gICAgICBkZXRhY2goKTtcbiAgICB9XG4gIH07XG5cbiAgZGV0YWNoID0gKCkgPT4gZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGRldGFjaGluZ0hhbmRsZXIpO1xuXG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBkZXRhY2hpbmdIYW5kbGVyLCB7IG9uY2U6IHRydWUgfSk7XG5cbiAgcmV0dXJuIGRldGFjaDtcbn1cblxuZnVuY3Rpb24gZGlzYWJsZUVsZW1lbnRXaXRoVW5kbyhlbGVtZW50KSB7XG4gIGNvbnN0IHVuZG9TdGFjayA9IFtdO1xuICBjb25zdCBpc0FjdGl2ZSA9IGVsZW1lbnQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gIGNvbnN0IHRhZyA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVmYXVsdC1jYXNlICovXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgLy8gU2hvdWxkIHdlIG5vdCBkaXNhYmxlIDxhPj8gV2lsbCBzb21lIG9mIHRoZSA8YT4gYXJlIHN0eWxlZCBhcyBidXR0b24/XG4gICAgY2FzZSAnYSc6XG4gICAgICB1bmRvU3RhY2sucHVzaChhZGRFdmVudExpc3RlbmVyT25jZVdpdGhVbmRvKGVsZW1lbnQsICdjbGljaycsIGRpc2FibGVkSGFuZGxlcikpO1xuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgdW5kb1N0YWNrLnB1c2goc2V0QXR0cmlidXRlV2l0aFVuZG8oZWxlbWVudCwgJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpKTtcblxuICAgICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICAgIHVuZG9TdGFjay5wdXNoKFxuICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXJPbmNlV2l0aFVuZG8oZWxlbWVudCwgJ2JsdXInLCAoKSA9PlxuICAgICAgICAgICAgdW5kb1N0YWNrLnB1c2goc2V0QXR0cmlidXRlV2l0aFVuZG8oZWxlbWVudCwgJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJykpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5kb1N0YWNrLnB1c2goc2V0QXR0cmlidXRlV2l0aFVuZG8oZWxlbWVudCwgJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJykpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJykge1xuICAgICAgICB1bmRvU3RhY2sucHVzaChhZGRFdmVudExpc3RlbmVyT25jZVdpdGhVbmRvKGVsZW1lbnQsICdjbGljaycsIGRpc2FibGVkSGFuZGxlcikpO1xuICAgICAgICB1bmRvU3RhY2sucHVzaChzZXRBdHRyaWJ1dGVXaXRoVW5kbyhlbGVtZW50LCAncmVhZG9ubHknLCAncmVhZG9ubHknKSk7XG4gICAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgdW5kb1N0YWNrLnB1c2goXG4gICAgICAgICAgLi4uW10ubWFwLmNhbGwoZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdvcHRpb24nKSwgb3B0aW9uID0+XG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGVXaXRoVW5kbyhvcHRpb24sICdkaXNhYmxlZCcsICdkaXNhYmxlZCcpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiAoKSA9PiB1bmRvU3RhY2suZm9yRWFjaCh1bmRvID0+IHVuZG8gJiYgdW5kbygpKTtcbn1cblxuZnVuY3Rpb24gZGlzYWJsZUlucHV0RWxlbWVudHNXaXRoVW5kbyhlbGVtZW50LCBvYnNlcnZlU3VidHJlZSA9IHRydWUpIHtcbiAgY29uc3QgdW5kb1N0YWNrID0gW10ubWFwLmNhbGwoZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdhLCBidXR0b24sIGlucHV0LCBzZWxlY3QsIHRleHRhcmVhJyksIGVsZW1lbnQgPT5cbiAgICBkaXNhYmxlRWxlbWVudFdpdGhVbmRvKGVsZW1lbnQpXG4gICk7XG5cbiAgY29uc3QgdGFnID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIC8vIE9ubHkgc2V0IHRhYmluZGV4PVwiLTFcIiBvbiBmb2N1c2FibGUgZWxlbWVudC4gT3RoZXJ3aXNlLCB3ZSB3aWxsIG1ha2UgPGRpdj4gZm9jdXNhYmxlIGJ5IG1vdXNlLlxuICAodGFnID09PSAnYScgfHwgdGFnID09PSAnYnV0dG9uJyB8fCB0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAnc2VsZWN0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScpICYmXG4gICAgdW5kb1N0YWNrLnB1c2goc2V0QXR0cmlidXRlV2l0aFVuZG8oZWxlbWVudCwgJ3RhYmluZGV4JywgJy0xJykpO1xuXG4gIGlmIChvYnNlcnZlU3VidHJlZSkge1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+XG4gICAgICBtdXRhdGlvbnMuZm9yRWFjaCgoeyBhZGRlZE5vZGVzIH0pID0+XG4gICAgICAgIHVuZG9TdGFjay5wdXNoKC4uLmFkZGVkTm9kZXMubWFwKGFkZGVkTm9kZSA9PiBkaXNhYmxlSW5wdXRFbGVtZW50c1dpdGhVbmRvKGFkZGVkTm9kZSwgZmFsc2UpKSlcbiAgICAgIClcbiAgICApO1xuXG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7IGNoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZSB9KTtcblxuICAgIHVuZG9TdGFjay5wdXNoKCgpID0+IG9ic2VydmVyLmRpc2Nvbm5lY3QoKSk7XG4gIH1cblxuICByZXR1cm4gKCkgPT4gdW5kb1N0YWNrLmZvckVhY2godW5kbyA9PiB1bmRvICYmIHVuZG8oKSk7XG59XG5cbmZ1bmN0aW9uIGdldEZvY3VzYWJsZUVsZW1lbnRzKGVsZW1lbnQpIHtcbiAgcmV0dXJuIFtdLmZpbHRlci5jYWxsKFxuICAgIGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcbiAgICAgIFtcbiAgICAgICAgJ2EnLFxuICAgICAgICAnYm9keScsXG4gICAgICAgICdidXR0b24nLFxuICAgICAgICAnZnJhbWUnLFxuICAgICAgICAnaWZyYW1lJyxcbiAgICAgICAgJ2ltZycsXG4gICAgICAgICdpbnB1dCcsXG4gICAgICAgICdpc2luZGV4JyxcbiAgICAgICAgJ29iamVjdCcsXG4gICAgICAgICdzZWxlY3QnLFxuICAgICAgICAndGV4dGFyZWEnLFxuICAgICAgICAnW3RhYmluZGV4XSdcbiAgICAgIF0uam9pbignLCAnKVxuICAgICksXG4gICAgZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCB0YWJJbmRleCA9IGdldFRhYkluZGV4KGVsZW1lbnQpO1xuXG4gICAgICByZXR1cm4gdHlwZW9mIHRhYkluZGV4ID09PSAnbnVtYmVyJyAmJiB0YWJJbmRleCA+PSAwO1xuICAgIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVzdG9yZUFjdGl2ZUVsZW1lbnRJbmRleChlbGVtZW50LCBhY3RpdmVFbGVtZW50SW5kZXgpIHtcbiAgY29uc3QgZm9jdXNhYmxlID0gZ2V0Rm9jdXNhYmxlRWxlbWVudHMoZWxlbWVudClbYWN0aXZlRWxlbWVudEluZGV4XTtcblxuICBmb2N1c2FibGUgJiYgZm9jdXNhYmxlLmZvY3VzKCk7XG59XG5cbmZ1bmN0aW9uIHNhdmVBY3RpdmVFbGVtZW50SW5kZXgoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0Rm9jdXNhYmxlRWxlbWVudHMoZWxlbWVudCkuaW5kZXhPZihkb2N1bWVudC5hY3RpdmVFbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gcmVzdG9yZUlucHV0VmFsdWVzKGVsZW1lbnQsIGlucHV0VmFsdWVzKSB7XG4gIGNvbnN0IGlucHV0cyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEnKTtcblxuICBbXS5mb3JFYWNoLmNhbGwoaW5wdXRzLCAoaW5wdXQsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBpbnB1dFZhbHVlc1tpbmRleF07XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3QgeyB0YWdOYW1lLCB0eXBlIH0gPSBpbnB1dDtcblxuICAgICAgaWYgKHRhZ05hbWUgPT09ICdJTlBVVCcgJiYgKHR5cGUgPT09ICdjaGVja2JveCcgfHwgdHlwZSA9PT0gJ3JhZGlvJykpIHtcbiAgICAgICAgaW5wdXQuY2hlY2tlZCA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzYXZlSW5wdXRWYWx1ZXMoZWxlbWVudCkge1xuICBjb25zdCBpbnB1dHMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0LCBzZWxlY3QsIHRleHRhcmVhJyk7XG5cbiAgcmV0dXJuIFtdLm1hcC5jYWxsKGlucHV0cywgKHsgY2hlY2tlZCwgdGFnTmFtZSwgdHlwZSwgdmFsdWUgfSkgPT4ge1xuICAgIGlmICh0YWdOYW1lID09PSAnSU5QVVQnICYmICh0eXBlID09PSAnY2hlY2tib3gnIHx8IHR5cGUgPT09ICdyYWRpbycpKSB7XG4gICAgICByZXR1cm4gY2hlY2tlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0pO1xufVxuXG5jb25zdCBBZGFwdGl2ZUNhcmRSZW5kZXJlciA9ICh7IGFjdGlvblBlcmZvcm1lZENsYXNzTmFtZSwgYWRhcHRpdmVDYXJkLCBkaXNhYmxlZDogZGlzYWJsZWRGcm9tUHJvcHMsIHRhcEFjdGlvbiB9KSA9PiB7XG4gIGNvbnN0IFt7IGFkYXB0aXZlQ2FyZFJlbmRlcmVyOiBhZGFwdGl2ZUNhcmRSZW5kZXJlclN0eWxlU2V0IH1dID0gdXNlU3R5bGVTZXQoKTtcbiAgY29uc3QgW3sgR2xvYmFsU2V0dGluZ3MsIEhvc3RDb25maWcgfV0gPSB1c2VBZGFwdGl2ZUNhcmRzUGFja2FnZSgpO1xuICBjb25zdCBbYWN0aW9uc1BlcmZvcm1lZCwgc2V0QWN0aW9uc1BlcmZvcm1lZF0gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IFthZGFwdGl2ZUNhcmRzSG9zdENvbmZpZ10gPSB1c2VBZGFwdGl2ZUNhcmRzSG9zdENvbmZpZygpO1xuICBjb25zdCBbZGlzYWJsZWRGcm9tQ29tcG9zZXJdID0gdXNlRGlzYWJsZWQoKTtcbiAgY29uc3QgW2Vycm9ycywgc2V0RXJyb3JzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW2xhc3RSZW5kZXIsIHNldExhc3RSZW5kZXJdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IGFjdGl2ZUVsZW1lbnRJbmRleFJlZiA9IHVzZVJlZigtMSk7XG4gIGNvbnN0IGFkYXB0aXZlQ2FyZEVsZW1lbnRSZWYgPSB1c2VSZWYoKTtcbiAgY29uc3QgY29udGVudFJlZiA9IHVzZVJlZigpO1xuICBjb25zdCBpbnB1dFZhbHVlc1JlZiA9IHVzZVJlZihbXSk7XG4gIGNvbnN0IGxvY2FsaXplID0gdXNlTG9jYWxpemVyKCk7XG4gIGNvbnN0IHBlcmZvcm1DYXJkQWN0aW9uID0gdXNlUGVyZm9ybUNhcmRBY3Rpb24oKTtcbiAgY29uc3QgcmVuZGVyTWFya2Rvd25Bc0hUTUwgPSB1c2VSZW5kZXJNYXJrZG93bkFzSFRNTCgpO1xuICBjb25zdCBzY3JvbGxUb0VuZCA9IHVzZVNjcm9sbFRvRW5kKCk7XG5cbiAgY29uc3QgZGlzYWJsZWQgPSBkaXNhYmxlZEZyb21Db21wb3NlciB8fCBkaXNhYmxlZEZyb21Qcm9wcztcblxuICAvLyBUT0RPOiBbUDJdICMzMTk5IFdlIHNob3VsZCBjb25zaWRlciB1c2luZyBgYWRhcHRpdmVDYXJkLnNlbGVjdEFjdGlvbmAgaW5zdGVhZC5cbiAgLy8gVGhlIG51bGwgY2hlY2sgZm9yIFwidGFwQWN0aW9uXCIgaXMgaW4gXCJoYW5kbGVDbGlja0FuZEtleVByZXNzRm9yVGFwQWN0aW9uXCIuXG4gIGNvbnN0IGhhbmRsZUNsaWNrQW5kS2V5UHJlc3MgPSB1c2VDYWxsYmFjayhcbiAgICBldmVudCA9PiB7XG4gICAgICBjb25zdCB7IGtleSwgdGFyZ2V0LCB0eXBlIH0gPSBldmVudDtcblxuICAgICAgLy8gU29tZSBpdGVtcywgZS5nLiB0YXBwYWJsZSB0ZXh0LCBjYW5ub3QgYmUgZGlzYWJsZWQgdGhydSBET00gYXR0cmlidXRlc1xuICAgICAgY29uc3QgeyBjdXJyZW50IH0gPSBjb250ZW50UmVmO1xuICAgICAgY29uc3QgYWRhcHRpdmVDYXJkUm9vdCA9IGN1cnJlbnQucXVlcnlTZWxlY3RvcignLmFjLWFkYXB0aXZlQ2FyZFt0YWJpbmRleD1cIjBcIl0nKTtcblxuICAgICAgaWYgKCFhZGFwdGl2ZUNhcmRSb290KSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ2JvdGZyYW1ld29yay13ZWJjaGF0OiBObyBBZGFwdGl2ZSBDYXJkIHJvb3QgY29udGFpbmVyIGNhbiBiZSBmb3VuZCwgcHJvYmFibHkgb24gYW4gdW5zdXBwb3J0ZWQgQWRhcHRpdmUgQ2FyZCB2ZXJzaW9uLidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gRm9yIFwia2V5cHJlc3NcIiBldmVudCwgd2Ugb25seSBsaXN0ZW4gdG8gRU5URVIgYW5kIFNQQUNFQkFSIGtleS5cbiAgICAgIGlmICh0eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICAgIGlmIChrZXkgIT09ICdFbnRlcicgJiYga2V5ICE9PSAnICcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSB3aWxsIGNhbGwgcGVyZm9ybUNhcmRBY3Rpb24gaWYgZWl0aGVyOlxuICAgICAgLy8gMS4gV2UgYXJlIG9uIHRoZSB0YXJnZXQsIG9yXG4gICAgICAvLyAyLiBUaGUgZXZlbnQtZGlzcGF0Y2hpbmcgZWxlbWVudCBpcyBub3QgaW50ZXJhY3RpdmVcbiAgICAgIGlmICh0YXJnZXQgIT09IGFkYXB0aXZlQ2FyZFJvb3QpIHtcbiAgICAgICAgY29uc3QgdGFiSW5kZXggPSBnZXRUYWJJbmRleCh0YXJnZXQpO1xuXG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGlzIGNsaWNraW5nIG9uIHNvbWV0aGluZyB0aGF0IGlzIGFscmVhZHkgY2xpY2thYmxlLCBkbyBub3QgYWxsb3cgdGhlbSB0byBjbGljayB0aGUgY2FyZC5cbiAgICAgICAgLy8gRS5nLiBhIGhlcm8gY2FyZCBjYW4gYmUgdGFwcGFibGUsIGFuZCBpbWFnZSBhbmQgYnV0dG9ucyBpbnNpZGUgdGhlIGhlcm8gY2FyZCBjYW4gYWxzbyBiZSB0YXBwYWJsZS5cbiAgICAgICAgaWYgKHR5cGVvZiB0YWJJbmRleCA9PT0gJ251bWJlcicgJiYgdGFiSW5kZXggPj0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwZXJmb3JtQ2FyZEFjdGlvbih0YXBBY3Rpb24pO1xuICAgICAgc2Nyb2xsVG9FbmQoKTtcbiAgICB9LFxuICAgIFtjb250ZW50UmVmLCBwZXJmb3JtQ2FyZEFjdGlvbiwgc2Nyb2xsVG9FbmQsIHRhcEFjdGlvbl1cbiAgKTtcblxuICAvLyBPbmx5IGxpc3RlbiB0byBldmVudCBpZiBpdCBpcyBub3QgZGlzYWJsZWQgYW5kIGhhdmUgXCJ0YXBBY3Rpb25cIiBwcm9wLlxuICBjb25zdCBoYW5kbGVDbGlja0FuZEtleVByZXNzRm9yVGFwQWN0aW9uID0gIWRpc2FibGVkICYmIHRhcEFjdGlvbiA/IGhhbmRsZUNsaWNrQW5kS2V5UHJlc3MgOiB1bmRlZmluZWQ7XG5cbiAgY29uc3QgYWRkQWN0aW9uc1BlcmZvcm1lZCA9IHVzZUNhbGxiYWNrKFxuICAgIGFjdGlvbiA9PiAhfmFjdGlvbnNQZXJmb3JtZWQuaW5kZXhPZihhY3Rpb24pICYmIHNldEFjdGlvbnNQZXJmb3JtZWQoWy4uLmFjdGlvbnNQZXJmb3JtZWQsIGFjdGlvbl0pLFxuICAgIFthY3Rpb25zUGVyZm9ybWVkLCBzZXRBY3Rpb25zUGVyZm9ybWVkXVxuICApO1xuXG4gIGNvbnN0IGhhbmRsZUV4ZWN1dGVBY3Rpb24gPSB1c2VDYWxsYmFjayhcbiAgICBhY3Rpb24gPT4ge1xuICAgICAgLy8gU29tZSBpdGVtcywgZS5nLiB0YXBwYWJsZSBpbWFnZSwgY2Fubm90IGJlIGRpc2FibGVkIHRocnUgRE9NIGF0dHJpYnV0ZXNcbiAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGFkZEFjdGlvbnNQZXJmb3JtZWQoYWN0aW9uKTtcblxuICAgICAgY29uc3QgYWN0aW9uVHlwZU5hbWUgPSBhY3Rpb24uZ2V0SnNvblR5cGVOYW1lKCk7XG5cbiAgICAgIGlmIChhY3Rpb25UeXBlTmFtZSA9PT0gJ0FjdGlvbi5PcGVuVXJsJykge1xuICAgICAgICBwZXJmb3JtQ2FyZEFjdGlvbih7XG4gICAgICAgICAgdHlwZTogJ29wZW5VcmwnLFxuICAgICAgICAgIHZhbHVlOiBhY3Rpb24udXJsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChhY3Rpb25UeXBlTmFtZSA9PT0gJ0FjdGlvbi5TdWJtaXQnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYWN0aW9uLmRhdGEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY29uc3QgeyBkYXRhOiBhY3Rpb25EYXRhIH0gPSBhY3Rpb247XG5cbiAgICAgICAgICBpZiAoYWN0aW9uRGF0YSAmJiBhY3Rpb25EYXRhLl9faXNCb3RGcmFtZXdvcmtDYXJkQWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCB7IGNhcmRBY3Rpb24gfSA9IGFjdGlvbkRhdGE7XG4gICAgICAgICAgICBjb25zdCB7IGRpc3BsYXlUZXh0LCB0ZXh0LCB0eXBlLCB2YWx1ZSB9ID0gY2FyZEFjdGlvbjtcblxuICAgICAgICAgICAgcGVyZm9ybUNhcmRBY3Rpb24oeyBkaXNwbGF5VGV4dCwgdGV4dCwgdHlwZSwgdmFsdWUgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlcmZvcm1DYXJkQWN0aW9uKHtcbiAgICAgICAgICAgICAgdHlwZTogdHlwZW9mIGFjdGlvbi5kYXRhID09PSAnc3RyaW5nJyA/ICdpbUJhY2snIDogJ3Bvc3RCYWNrJyxcbiAgICAgICAgICAgICAgdmFsdWU6IGFjdGlvbi5kYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzY3JvbGxUb0VuZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgV2ViIENoYXQ6IHJlY2VpdmVkIHVua25vd24gYWN0aW9uIGZyb20gQWRhcHRpdmUgQ2FyZHNgKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihhY3Rpb24pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW2FkZEFjdGlvbnNQZXJmb3JtZWQsIGRpc2FibGVkLCBwZXJmb3JtQ2FyZEFjdGlvbiwgc2Nyb2xsVG9FbmRdXG4gICk7XG5cbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB7IGN1cnJlbnQgfSA9IGNvbnRlbnRSZWY7XG5cbiAgICBpZiAoIWN1cnJlbnQgfHwgIWFkYXB0aXZlQ2FyZCkge1xuICAgICAgYWN0aXZlRWxlbWVudEluZGV4UmVmLmN1cnJlbnQgPSAtMTtcbiAgICAgIGlucHV0VmFsdWVzUmVmLmN1cnJlbnQgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBDdXJyZW50bHksIHRoZSBvbmx5IHdheSB0byBzZXQgdGhlIE1hcmtkb3duIGVuZ2luZSBpcyB0byBzZXQgaXQgdGhydSBzdGF0aWMgbWVtYmVyIG9mIEFkYXB0aXZlQ2FyZCBjbGFzc1xuXG4gICAgLy8gVE9ETzogW1AzXSBDaGVja3MgaWYgd2UgY291bGQgbWFrZSB0aGUgXCJyZW5kZXJNYXJrZG93bkFzSFRNTFwiIHBlciBjYXJkXG4gICAgLy8gICAgICAgVGhpcyBjb3VsZCBiZSBsaW1pdGF0aW9ucyBmcm9tIEFkYXB0aXZlIENhcmRzIHBhY2thZ2UgKG5vdCBzdXBwb3J0ZWQgYXMgb2YgMS4yLjUpXG4gICAgLy8gICAgICAgQmVjYXVzZSB0aGVyZSBjb3VsZCBiZSB0aW1pbmcgZGlmZmVyZW5jZSBiZXR3ZWVuIC5wYXJzZSBhbmQgLnJlbmRlciwgd2UgY291bGQgYmUgdXNpbmcgd3JvbmcgTWFya2Rvd24gZW5naW5lXG5cbiAgICBhZGFwdGl2ZUNhcmQuY29uc3RydWN0b3Iub25Qcm9jZXNzTWFya2Rvd24gPSAodGV4dCwgcmVzdWx0KSA9PiB7XG4gICAgICBpZiAocmVuZGVyTWFya2Rvd25Bc0hUTUwpIHtcbiAgICAgICAgcmVzdWx0Lm91dHB1dEh0bWwgPSByZW5kZXJNYXJrZG93bkFzSFRNTCh0ZXh0KTtcbiAgICAgICAgcmVzdWx0LmRpZFByb2Nlc3MgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoYWRhcHRpdmVDYXJkc0hvc3RDb25maWcpIHtcbiAgICAgIGFkYXB0aXZlQ2FyZC5ob3N0Q29uZmlnID0gaXNQbGFpbk9iamVjdChhZGFwdGl2ZUNhcmRzSG9zdENvbmZpZylcbiAgICAgICAgPyBuZXcgSG9zdENvbmZpZyhhZGFwdGl2ZUNhcmRzSG9zdENvbmZpZylcbiAgICAgICAgOiBhZGFwdGl2ZUNhcmRzSG9zdENvbmZpZztcbiAgICB9XG5cbiAgICAvLyBGb3IgYWNjZXNzaWJpbGl0eSBpc3N1ZSAjMTM0MCwgYHRhYmluZGV4PVwiMFwiYCBtdXN0IG5vdCBiZSBzZXQgZm9yIHRoZSByb290IGNvbnRhaW5lciBpZiBpdCBpcyBub3QgaW50ZXJhY3RpdmUuXG4gICAgR2xvYmFsU2V0dGluZ3Muc2V0VGFiSW5kZXhBdENhcmRSb290ID0gISF0YXBBY3Rpb247XG5cbiAgICBjb25zdCB7IGZhaWx1cmVzIH0gPSBhZGFwdGl2ZUNhcmQudmFsaWRhdGVQcm9wZXJ0aWVzKCk7XG5cbiAgICBpZiAoZmFpbHVyZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gc2V0RXJyb3JzKFxuICAgICAgICBmYWlsdXJlcy5yZWR1Y2UoKGl0ZW1zLCB7IGVycm9ycyB9KSA9PiBbLi4uaXRlbXMsIC4uLmVycm9ycy5tYXAoKHsgbWVzc2FnZSB9KSA9PiBuZXcgRXJyb3IobWVzc2FnZSkpXSwgW10pXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCBlbGVtZW50O1xuXG4gICAgdHJ5IHtcbiAgICAgIGVsZW1lbnQgPSBhZGFwdGl2ZUNhcmQucmVuZGVyKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBzZXRFcnJvcnMoW2Vycm9yXSk7XG4gICAgfVxuXG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gc2V0RXJyb3JzKFtuZXcgRXJyb3IoJ0FkYXB0aXZlIENhcmQgcmVuZGVyZWQgYXMgZW1wdHkgZWxlbWVudCcpXSk7XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgZXJyb3JzIG9uIG5leHQgcmVuZGVyXG4gICAgc2V0RXJyb3JzKFtdKTtcblxuICAgIHJlc3RvcmVJbnB1dFZhbHVlcyhlbGVtZW50LCBpbnB1dFZhbHVlc1JlZi5jdXJyZW50KTtcblxuICAgIGN1cnJlbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgYWRhcHRpdmVDYXJkRWxlbWVudFJlZi5jdXJyZW50ID0gZWxlbWVudDtcblxuICAgIC8vIEZvY3VzIGNhbiBvbmx5IGJlIHJlc3RvcmVkIGFmdGVyIHRoZSBET00gaXMgYXR0YWNoZWQuXG4gICAgcmVzdG9yZUFjdGl2ZUVsZW1lbnRJbmRleChlbGVtZW50LCBhY3RpdmVFbGVtZW50SW5kZXhSZWYuY3VycmVudCk7XG5cbiAgICBzZXRMYXN0UmVuZGVyKERhdGUubm93KCkpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGFjdGl2ZUVsZW1lbnRJbmRleFJlZi5jdXJyZW50ID0gc2F2ZUFjdGl2ZUVsZW1lbnRJbmRleChlbGVtZW50KTtcbiAgICAgIGlucHV0VmFsdWVzUmVmLmN1cnJlbnQgPSBzYXZlSW5wdXRWYWx1ZXMoZWxlbWVudCk7XG5cbiAgICAgIGN1cnJlbnQucmVtb3ZlQ2hpbGQoYWRhcHRpdmVDYXJkRWxlbWVudFJlZi5jdXJyZW50KTtcblxuICAgICAgYWRhcHRpdmVDYXJkRWxlbWVudFJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgIH07XG4gIH0sIFtcbiAgICBhZGFwdGl2ZUNhcmQsXG4gICAgYWRhcHRpdmVDYXJkc0hvc3RDb25maWcsXG4gICAgY29udGVudFJlZixcbiAgICBHbG9iYWxTZXR0aW5ncyxcbiAgICBIb3N0Q29uZmlnLFxuICAgIHJlbmRlck1hcmtkb3duQXNIVE1MLFxuICAgIHNldEVycm9ycyxcbiAgICB0YXBBY3Rpb25cbiAgXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBTZXQgb25FeGVjdXRlQWN0aW9uIHdpdGhvdXQgY2F1c2luZyB1bm5lY2Vzc2FyeSByZS1yZW5kZXIuXG4gICAgYWRhcHRpdmVDYXJkLm9uRXhlY3V0ZUFjdGlvbiA9IGRpc2FibGVkID8gdW5kZWZpbmVkIDogaGFuZGxlRXhlY3V0ZUFjdGlvbjtcbiAgfSwgW2FkYXB0aXZlQ2FyZCwgZGlzYWJsZWQsIGhhbmRsZUV4ZWN1dGVBY3Rpb25dKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIElmIHRoZSBBZGFwdGl2ZSBDYXJkIGdldCByZS1yZW5kZXJlZCwgcmUtZGlzYWJsZSBlbGVtZW50cyBhcyBuZWVkZWQuXG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gZGlzYWJsZUlucHV0RWxlbWVudHNXaXRoVW5kbyhhZGFwdGl2ZUNhcmRFbGVtZW50UmVmLmN1cnJlbnQpO1xuICAgIH1cbiAgfSwgW2Rpc2FibGVkLCBsYXN0UmVuZGVyXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBJZiB0aGUgQWRhcHRpdmUgQ2FyZCBjaGFuZ2VkLCByZXNldCBhbGwgYWN0aW9ucyBwZXJmb3JtZWQuXG4gICAgc2V0QWN0aW9uc1BlcmZvcm1lZChbXSk7XG4gIH0sIFthZGFwdGl2ZUNhcmRdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIEFkZCBkZXZlbG9wZXJzIHRvIGhpZ2hsaWdodCBhY3Rpb25zIHdoZW4gdGhleSBoYXZlIGJlZW4gY2xpY2tlZC5cbiAgICBpZiAoIWFjdGlvblBlcmZvcm1lZENsYXNzTmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHVuZG9TdGFjayA9IGFjdGlvbnNQZXJmb3JtZWQubWFwKFxuICAgICAgKHsgcmVuZGVyZWRFbGVtZW50IH0pID0+XG4gICAgICAgIHJlbmRlcmVkRWxlbWVudCAmJlxuICAgICAgICBhZGFwdGl2ZUNhcmRFbGVtZW50UmVmLmN1cnJlbnQuY29udGFpbnMocmVuZGVyZWRFbGVtZW50KSAmJlxuICAgICAgICBhZGRQZXJzaXN0ZW50Q2xhc3NXaXRoVW5kbyhyZW5kZXJlZEVsZW1lbnQsIGFjdGlvblBlcmZvcm1lZENsYXNzTmFtZSlcbiAgICApO1xuXG4gICAgcmV0dXJuICgpID0+IHVuZG9TdGFjay5mb3JFYWNoKHVuZG8gPT4gdW5kbyAmJiB1bmRvKCkpO1xuICB9LCBbYWN0aW9uc1BlcmZvcm1lZCwgYWN0aW9uUGVyZm9ybWVkQ2xhc3NOYW1lLCBsYXN0UmVuZGVyXSk7XG5cbiAgcmV0dXJuIGVycm9ycy5sZW5ndGggPyAoXG4gICAgbm9kZV9lbnYgPT09ICdkZXZlbG9wbWVudCcgPyAoXG4gICAgICA8RXJyb3JCb3ggZXJyb3I9e2Vycm9yc1swXX0gdHlwZT17bG9jYWxpemUoJ0FEQVBUSVZFX0NBUkRfRVJST1JfQk9YX1RJVExFX1JFTkRFUicpfSAvPlxuICAgICkgOiAoXG4gICAgICBmYWxzZVxuICAgIClcbiAgKSA6IChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoYWRhcHRpdmVDYXJkUmVuZGVyZXJTdHlsZVNldCArICcnLCAnd2ViY2hhdF9fYWRhcHRpdmUtY2FyZC1yZW5kZXJlcicpfVxuICAgICAgb25DbGljaz17aGFuZGxlQ2xpY2tBbmRLZXlQcmVzc0ZvclRhcEFjdGlvbn1cbiAgICAgIG9uS2V5UHJlc3M9e2hhbmRsZUNsaWNrQW5kS2V5UHJlc3NGb3JUYXBBY3Rpb259XG4gICAgICByZWY9e2NvbnRlbnRSZWZ9XG4gICAgLz5cbiAgKTtcbn07XG5cbkFkYXB0aXZlQ2FyZFJlbmRlcmVyLmRlZmF1bHRQcm9wcyA9IHtcbiAgYWN0aW9uUGVyZm9ybWVkQ2xhc3NOYW1lOiAnJyxcbiAgZGlzYWJsZWQ6IHVuZGVmaW5lZCxcbiAgdGFwQWN0aW9uOiB1bmRlZmluZWRcbn07XG5cbkFkYXB0aXZlQ2FyZFJlbmRlcmVyLnByb3BUeXBlcyA9IHtcbiAgYWN0aW9uUGVyZm9ybWVkQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBhZGFwdGl2ZUNhcmQ6IFByb3BUeXBlcy5hbnkuaXNSZXF1aXJlZCxcbiAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICB0YXBBY3Rpb246IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgdHlwZTogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIHZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nXG4gIH0pXG59O1xuXG5leHBvcnQgZGVmYXVsdCBBZGFwdGl2ZUNhcmRSZW5kZXJlcjtcbiJdfQ==