"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.connectSpeakActivity = exports.default = void 0;

var _botframeworkWebchatApi = require("botframework-webchat-api");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _reactSay = _interopRequireWildcard(require("react-say"));

var _connectToWebChat = _interopRequireDefault(require("../connectToWebChat"));

var _SayAlt = _interopRequireDefault(require("./SayAlt"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var useMarkActivityAsSpoken = _botframeworkWebchatApi.hooks.useMarkActivityAsSpoken,
    useStyleOptions = _botframeworkWebchatApi.hooks.useStyleOptions,
    useVoiceSelector = _botframeworkWebchatApi.hooks.useVoiceSelector; // TODO: [P4] Consider moving this feature into BasicActivity
//       And it has better DOM position for showing visual spoken text
// TODO: [P3] We should add a "spoken" or "speakState" flag to indicate whether this activity is going to speak, or spoken

var connectSpeakActivity = function connectSpeakActivity() {
  for (var _len = arguments.length, selectors = new Array(_len), _key = 0; _key < _len; _key++) {
    selectors[_key] = arguments[_key];
  }

  return _connectToWebChat.default.apply(void 0, [function (_ref, _ref2) {
    var language = _ref.language,
        markActivity = _ref.markActivity,
        _selectVoice = _ref.selectVoice;
    var activity = _ref2.activity;
    return {
      language: language,
      markAsSpoken: function markAsSpoken() {
        return markActivity(activity, 'speak', false);
      },
      selectVoice: function selectVoice(voices) {
        return _selectVoice(voices, activity);
      }
    };
  }].concat(selectors));
};

exports.connectSpeakActivity = connectSpeakActivity;

var Speak = function Speak(_ref3) {
  var activity = _ref3.activity;

  var _useStyleOptions = useStyleOptions(),
      _useStyleOptions2 = _slicedToArray(_useStyleOptions, 1),
      showSpokenText = _useStyleOptions2[0].showSpokenText;

  var markActivityAsSpoken = useMarkActivityAsSpoken();
  var selectVoice = useVoiceSelector(activity);
  var markAsSpoken = (0, _react.useCallback)(function () {
    markActivityAsSpoken(activity);
  }, [activity, markActivityAsSpoken]);
  var singleLine = (0, _react.useMemo)(function () {
    var _activity$attachments = activity.attachments,
        attachments = _activity$attachments === void 0 ? [] : _activity$attachments,
        speak = activity.speak,
        text = activity.text;
    return !!activity && [speak || text].concat(_toConsumableArray(attachments.filter(function (_ref4) {
      var contentType = _ref4.contentType;
      return contentType === 'application/vnd.microsoft.card.adaptive';
    }).map(function (_ref5) {
      var _ref5$content = _ref5.content;
      _ref5$content = _ref5$content === void 0 ? {} : _ref5$content;
      var speak = _ref5$content.speak;
      return speak;
    }))).filter(function (line) {
      return line;
    }).join('\r\n');
  }, [activity]);
  var _activity$channelData = activity.channelData;
  _activity$channelData = _activity$channelData === void 0 ? {} : _activity$channelData;
  var speechSynthesisUtterance = _activity$channelData.speechSynthesisUtterance;
  return !!activity && /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, speechSynthesisUtterance ? /*#__PURE__*/_react.default.createElement(_reactSay.SayUtterance, {
    onEnd: markAsSpoken,
    onError: markAsSpoken,
    utterance: speechSynthesisUtterance
  }) : /*#__PURE__*/_react.default.createElement(_reactSay.default, {
    onEnd: markAsSpoken,
    onError: markAsSpoken,
    text: singleLine,
    voice: selectVoice
  }), !!showSpokenText && /*#__PURE__*/_react.default.createElement(_SayAlt.default, {
    speak: singleLine,
    voice: selectVoice
  }));
};

Speak.propTypes = {
  activity: _propTypes.default.shape({
    attachments: _propTypes.default.arrayOf(_propTypes.default.shape({
      speak: _propTypes.default.string,
      subtitle: _propTypes.default.string,
      text: _propTypes.default.string,
      title: _propTypes.default.string
    })),
    channelData: _propTypes.default.shape({
      speechSynthesisUtterance: _propTypes.default.any
    }),
    speak: _propTypes.default.string,
    text: _propTypes.default.string
  }).isRequired
};
var _default = Speak;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9BY3Rpdml0eS9TcGVhay5qcyJdLCJuYW1lcyI6WyJ1c2VNYXJrQWN0aXZpdHlBc1Nwb2tlbiIsImhvb2tzIiwidXNlU3R5bGVPcHRpb25zIiwidXNlVm9pY2VTZWxlY3RvciIsImNvbm5lY3RTcGVha0FjdGl2aXR5Iiwic2VsZWN0b3JzIiwiY29ubmVjdFRvV2ViQ2hhdCIsImxhbmd1YWdlIiwibWFya0FjdGl2aXR5Iiwic2VsZWN0Vm9pY2UiLCJhY3Rpdml0eSIsIm1hcmtBc1Nwb2tlbiIsInZvaWNlcyIsIlNwZWFrIiwic2hvd1Nwb2tlblRleHQiLCJtYXJrQWN0aXZpdHlBc1Nwb2tlbiIsInNpbmdsZUxpbmUiLCJhdHRhY2htZW50cyIsInNwZWFrIiwidGV4dCIsImZpbHRlciIsImNvbnRlbnRUeXBlIiwibWFwIiwiY29udGVudCIsImxpbmUiLCJqb2luIiwiY2hhbm5lbERhdGEiLCJzcGVlY2hTeW50aGVzaXNVdHRlcmFuY2UiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJzaGFwZSIsImFycmF5T2YiLCJzdHJpbmciLCJzdWJ0aXRsZSIsInRpdGxlIiwiYW55IiwiaXNSZXF1aXJlZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFFUUEsdUIsR0FBK0RDLDZCLENBQS9ERCx1QjtJQUF5QkUsZSxHQUFzQ0QsNkIsQ0FBdENDLGU7SUFBaUJDLGdCLEdBQXFCRiw2QixDQUFyQkUsZ0IsRUFFbEQ7QUFDQTtBQUVBOztBQUNBLElBQU1DLG9CQUFvQixHQUFHLFNBQXZCQSxvQkFBdUI7QUFBQSxvQ0FBSUMsU0FBSjtBQUFJQSxJQUFBQSxTQUFKO0FBQUE7O0FBQUEsU0FDM0JDLHlDQUNFO0FBQUEsUUFBR0MsUUFBSCxRQUFHQSxRQUFIO0FBQUEsUUFBYUMsWUFBYixRQUFhQSxZQUFiO0FBQUEsUUFBMkJDLFlBQTNCLFFBQTJCQSxX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QkFBVUUsT0FBVixDQUNYRixtQkFBVUMsS0FBVixDQUFnQjtBQUNkWixNQUFBQSxLQUFLLEVBQUVXLG1CQUFVRyxNQURIO0FBRWRDLE1BQUFBLFFBQVEsRUFBRUosbUJBQVVHLE1BRk47QUFHZGIsTUFBQUEsSUFBSSxFQUFFVSxtQkFBVUcsTUFIRjtBQUlkRSxNQUFBQSxLQUFLLEVBQUVMLG1CQUFVRztBQUpILEtBQWhCLENBRFcsQ0FEVztBQVN4Qk4sSUFBQUEsV0FBVyxFQUFFRyxtQkFBVUMsS0FBVixDQUFnQjtBQUMzQkgsTUFBQUEsd0JBQXdCLEVBQUVFLG1CQUFVTTtBQURULEtBQWhCLENBVFc7QUFZeEJqQixJQUFBQSxLQUFLLEVBQUVXLG1CQUFVRyxNQVpPO0FBYXhCYixJQUFBQSxJQUFJLEVBQUVVLG1CQUFVRztBQWJRLEdBQWhCLEVBY1BJO0FBZmEsQ0FBbEI7ZUFrQmV2QixLIiwic291cmNlUm9vdCI6ImNvbXBvbmVudDovLy8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBob29rcyB9IGZyb20gJ2JvdGZyYW1ld29yay13ZWJjaGF0LWFwaSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFNheSwgeyBTYXlVdHRlcmFuY2UgfSBmcm9tICdyZWFjdC1zYXknO1xuXG5pbXBvcnQgY29ubmVjdFRvV2ViQ2hhdCBmcm9tICcuLi9jb25uZWN0VG9XZWJDaGF0JztcbmltcG9ydCBTYXlBbHQgZnJvbSAnLi9TYXlBbHQnO1xuXG5jb25zdCB7IHVzZU1hcmtBY3Rpdml0eUFzU3Bva2VuLCB1c2VTdHlsZU9wdGlvbnMsIHVzZVZvaWNlU2VsZWN0b3IgfSA9IGhvb2tzO1xuXG4vLyBUT0RPOiBbUDRdIENvbnNpZGVyIG1vdmluZyB0aGlzIGZlYXR1cmUgaW50byBCYXNpY0FjdGl2aXR5XG4vLyAgICAgICBBbmQgaXQgaGFzIGJldHRlciBET00gcG9zaXRpb24gZm9yIHNob3dpbmcgdmlzdWFsIHNwb2tlbiB0ZXh0XG5cbi8vIFRPRE86IFtQM10gV2Ugc2hvdWxkIGFkZCBhIFwic3Bva2VuXCIgb3IgXCJzcGVha1N0YXRlXCIgZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoaXMgYWN0aXZpdHkgaXMgZ29pbmcgdG8gc3BlYWssIG9yIHNwb2tlblxuY29uc3QgY29ubmVjdFNwZWFrQWN0aXZpdHkgPSAoLi4uc2VsZWN0b3JzKSA9PlxuICBjb25uZWN0VG9XZWJDaGF0KFxuICAgICh7IGxhbmd1YWdlLCBtYXJrQWN0aXZpdHksIHNlbGVjdFZvaWNlIH0sIHsgYWN0aXZpdHkgfSkgPT4gKHtcbiAgICAgIGxhbmd1YWdlLFxuICAgICAgbWFya0FzU3Bva2VuOiAoKSA9PiBtYXJrQWN0aXZpdHkoYWN0aXZpdHksICdzcGVhaycsIGZhbHNlKSxcbiAgICAgIHNlbGVjdFZvaWNlOiB2b2ljZXMgPT4gc2VsZWN0Vm9pY2Uodm9pY2VzLCBhY3Rpdml0eSlcbiAgICB9KSxcbiAgICAuLi5zZWxlY3RvcnNcbiAgKTtcblxuY29uc3QgU3BlYWsgPSAoeyBhY3Rpdml0eSB9KSA9PiB7XG4gIGNvbnN0IFt7IHNob3dTcG9rZW5UZXh0IH1dID0gdXNlU3R5bGVPcHRpb25zKCk7XG4gIGNvbnN0IG1hcmtBY3Rpdml0eUFzU3Bva2VuID0gdXNlTWFya0FjdGl2aXR5QXNTcG9rZW4oKTtcbiAgY29uc3Qgc2VsZWN0Vm9pY2UgPSB1c2VWb2ljZVNlbGVjdG9yKGFjdGl2aXR5KTtcblxuICBjb25zdCBtYXJrQXNTcG9rZW4gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgbWFya0FjdGl2aXR5QXNTcG9rZW4oYWN0aXZpdHkpO1xuICB9LCBbYWN0aXZpdHksIG1hcmtBY3Rpdml0eUFzU3Bva2VuXSk7XG5cbiAgY29uc3Qgc2luZ2xlTGluZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHsgYXR0YWNobWVudHMgPSBbXSwgc3BlYWssIHRleHQgfSA9IGFjdGl2aXR5O1xuXG4gICAgcmV0dXJuIChcbiAgICAgICEhYWN0aXZpdHkgJiZcbiAgICAgIFtcbiAgICAgICAgc3BlYWsgfHwgdGV4dCxcbiAgICAgICAgLi4uYXR0YWNobWVudHNcbiAgICAgICAgICAuZmlsdGVyKCh7IGNvbnRlbnRUeXBlIH0pID0+IGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vdm5kLm1pY3Jvc29mdC5jYXJkLmFkYXB0aXZlJylcbiAgICAgICAgICAubWFwKCh7IGNvbnRlbnQ6IHsgc3BlYWsgfSA9IHt9IH0pID0+IHNwZWFrKVxuICAgICAgXVxuICAgICAgICAuZmlsdGVyKGxpbmUgPT4gbGluZSlcbiAgICAgICAgLmpvaW4oJ1xcclxcbicpXG4gICAgKTtcbiAgfSwgW2FjdGl2aXR5XSk7XG5cbiAgY29uc3QgeyBjaGFubmVsRGF0YTogeyBzcGVlY2hTeW50aGVzaXNVdHRlcmFuY2UgfSA9IHt9IH0gPSBhY3Rpdml0eTtcblxuICByZXR1cm4gKFxuICAgICEhYWN0aXZpdHkgJiYgKFxuICAgICAgPFJlYWN0LkZyYWdtZW50PlxuICAgICAgICB7c3BlZWNoU3ludGhlc2lzVXR0ZXJhbmNlID8gKFxuICAgICAgICAgIDxTYXlVdHRlcmFuY2Ugb25FbmQ9e21hcmtBc1Nwb2tlbn0gb25FcnJvcj17bWFya0FzU3Bva2VufSB1dHRlcmFuY2U9e3NwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZX0gLz5cbiAgICAgICAgKSA6IChcbiAgICAgICAgICA8U2F5IG9uRW5kPXttYXJrQXNTcG9rZW59IG9uRXJyb3I9e21hcmtBc1Nwb2tlbn0gdGV4dD17c2luZ2xlTGluZX0gdm9pY2U9e3NlbGVjdFZvaWNlfSAvPlxuICAgICAgICApfVxuICAgICAgICB7ISFzaG93U3Bva2VuVGV4dCAmJiA8U2F5QWx0IHNwZWFrPXtzaW5nbGVMaW5lfSB2b2ljZT17c2VsZWN0Vm9pY2V9IC8+fVxuICAgICAgPC9SZWFjdC5GcmFnbWVudD5cbiAgICApXG4gICk7XG59O1xuXG5TcGVhay5wcm9wVHlwZXMgPSB7XG4gIGFjdGl2aXR5OiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGF0dGFjaG1lbnRzOiBQcm9wVHlwZXMuYXJyYXlPZihcbiAgICAgIFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICAgIHNwZWFrOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBzdWJ0aXRsZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgdGV4dDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgdGl0bGU6IFByb3BUeXBlcy5zdHJpbmdcbiAgICAgIH0pXG4gICAgKSxcbiAgICBjaGFubmVsRGF0YTogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIHNwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZTogUHJvcFR5cGVzLmFueVxuICAgIH0pLFxuICAgIHNwZWFrOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIHRleHQ6IFByb3BUeXBlcy5zdHJpbmdcbiAgfSkuaXNSZXF1aXJlZFxufTtcblxuZXhwb3J0IGRlZmF1bHQgU3BlYWs7XG5cbmV4cG9ydCB7IGNvbm5lY3RTcGVha0FjdGl2aXR5IH07XG4iXX0=