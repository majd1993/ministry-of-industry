"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useTextBoxSubmit = useTextBoxSubmit;
exports.useTextBoxValue = useTextBoxValue;
exports.connectSendTextBox = exports.default = void 0;

var _botframeworkWebchatApi = require("botframework-webchat-api");

var _classnames = _interopRequireDefault(require("classnames"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _TypeFocusSink = require("../Utils/TypeFocusSink");

var _AccessibleInputText = _interopRequireDefault(require("../Utils/AccessibleInputText"));

var _AccessibleTextArea = _interopRequireDefault(require("../Utils/AccessibleTextArea"));

var _connectToWebChat = _interopRequireDefault(require("../connectToWebChat"));

var _useFocus = _interopRequireDefault(require("../hooks/useFocus"));

var _useReplaceEmoticon = _interopRequireDefault(require("../hooks/internal/useReplaceEmoticon"));

var _useScrollToEnd = _interopRequireDefault(require("../hooks/useScrollToEnd"));

var _useStyleSet3 = _interopRequireDefault(require("../hooks/useStyleSet"));

var _useStyleToEmotionObject = _interopRequireDefault(require("../hooks/internal/useStyleToEmotionObject"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var useDisabled = _botframeworkWebchatApi.hooks.useDisabled,
    useLocalizer = _botframeworkWebchatApi.hooks.useLocalizer,
    useSendBoxValue = _botframeworkWebchatApi.hooks.useSendBoxValue,
    useStopDictate = _botframeworkWebchatApi.hooks.useStopDictate,
    useStyleOptions = _botframeworkWebchatApi.hooks.useStyleOptions,
    useSubmitSendBox = _botframeworkWebchatApi.hooks.useSubmitSendBox;
var ROOT_STYLE = {
  '&.webchat__send-box-text-box': {
    display: 'flex',
    '& .webchat__send-box-text-box__input, & .webchat__send-box-text-box__text-area-box': {
      flex: 1
    }
  }
};

var connectSendTextBox = function connectSendTextBox() {
  for (var _len = arguments.length, selectors = new Array(_len), _key = 0; _key < _len; _key++) {
    selectors[_key] = arguments[_key];
  }

  return _connectToWebChat.default.apply(void 0, [function (_ref) {
    var disabled = _ref.disabled,
        focusSendBox = _ref.focusSendBox,
        language = _ref.language,
        scrollToEnd = _ref.scrollToEnd,
        sendBoxValue = _ref.sendBoxValue,
        setSendBox = _ref.setSendBox,
        stopDictate = _ref.stopDictate,
        submitSendBox = _ref.submitSendBox;
    return {
      disabled: disabled,
      language: language,
      onChange: function onChange(_ref2) {
        var value = _ref2.target.value;
        setSendBox(value);
        stopDictate();
      },
      onKeyPress: function onKeyPress(event) {
        var key = event.key,
            shiftKey = event.shiftKey;

        if (key === 'Enter' && !shiftKey) {
          event.preventDefault();

          if (sendBoxValue) {
            scrollToEnd();
            submitSendBox();
            focusSendBox();
          }
        }
      },
      onSubmit: function onSubmit(event) {
        event.preventDefault(); // Consider clearing the send box only after we received POST_ACTIVITY_PENDING
        // E.g. if the connection is bad, sending the message essentially do nothing but just clearing the send box

        if (sendBoxValue) {
          scrollToEnd();
          submitSendBox();
        }
      },
      value: sendBoxValue
    };
  }].concat(selectors));
};

exports.connectSendTextBox = connectSendTextBox;

function useTextBoxSubmit() {
  var _useSendBoxValue = useSendBoxValue(),
      _useSendBoxValue2 = _slicedToArray(_useSendBoxValue, 1),
      sendBoxValue = _useSendBoxValue2[0];

  var focus = (0, _useFocus.default)();
  var scrollToEnd = (0, _useScrollToEnd.default)();
  var submitSendBox = useSubmitSendBox();
  return (0, _react.useCallback)(function (setFocus) {
    if (sendBoxValue) {
      scrollToEnd();
      submitSendBox();

      if (setFocus) {
        if (setFocus === true) {
          console.warn("\"botframework-webchat: Passing \"true\" to \"useTextBoxSubmit\" is deprecated and will be removed on or after 2022-04-23. Please pass \"sendBox\" instead.\"");
          focus('sendBox');
        } else {
          focus(setFocus);
        }
      }
    }

    return !!sendBoxValue;
  }, [focus, scrollToEnd, sendBoxValue, submitSendBox]);
}

function useTextBoxValue() {
  var _useSendBoxValue3 = useSendBoxValue(),
      _useSendBoxValue4 = _slicedToArray(_useSendBoxValue3, 2),
      value = _useSendBoxValue4[0],
      setValue = _useSendBoxValue4[1];

  var replaceEmoticon = (0, _useReplaceEmoticon.default)();
  var stopDictate = useStopDictate();
  var setter = (0, _react.useCallback)(function (nextValue) {
    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        selectionEnd = _ref3.selectionEnd,
        selectionStart = _ref3.selectionStart;

    if (typeof nextValue !== 'string') {
      throw new Error('botframework-webchat: First argument passed to useTextBoxValue() must be a string.');
    } // Currently, we cannot detect whether the change is due to clipboard paste or pressing a key on the keyboard.
    // We should not change to emoji when the user is pasting text.
    // We would assume, for a single character addition, the user must be pressing a key.


    if (nextValue.length === value.length + 1) {
      var _replaceEmoticon = replaceEmoticon({
        selectionEnd: selectionEnd,
        selectionStart: selectionStart,
        value: nextValue
      }),
          nextSelectionEnd = _replaceEmoticon.selectionEnd,
          nextSelectionStart = _replaceEmoticon.selectionStart,
          nextValueWithEmoji = _replaceEmoticon.value;

      selectionEnd = nextSelectionEnd;
      selectionStart = nextSelectionStart;
      nextValue = nextValueWithEmoji;
    }

    setValue(nextValue);
    stopDictate();
    return {
      selectionEnd: selectionEnd,
      selectionStart: selectionStart,
      value: nextValue
    };
  }, [replaceEmoticon, setValue, stopDictate, value]);
  return [value, setter];
}

var PREVENT_DEFAULT_HANDLER = function PREVENT_DEFAULT_HANDLER(event) {
  return event.preventDefault();
};

var TextBoxCore = /*#__PURE__*/(0, _react.forwardRef)(function (_ref4, forwardedRef) {
  var className = _ref4.className;

  var _useSendBoxValue5 = useSendBoxValue(),
      _useSendBoxValue6 = _slicedToArray(_useSendBoxValue5, 2),
      setSendBox = _useSendBoxValue6[1];

  var _useStyleSet = (0, _useStyleSet3.default)(),
      _useStyleSet2 = _slicedToArray(_useStyleSet, 1),
      _useStyleSet2$ = _useStyleSet2[0],
      sendBoxTextAreaStyleSet = _useStyleSet2$.sendBoxTextArea,
      sendBoxTextBoxStyleSet = _useStyleSet2$.sendBoxTextBox;

  var _useStyleOptions = useStyleOptions(),
      _useStyleOptions2 = _slicedToArray(_useStyleOptions, 1),
      sendBoxTextWrap = _useStyleOptions2[0].sendBoxTextWrap;

  var _useDisabled = useDisabled(),
      _useDisabled2 = _slicedToArray(_useDisabled, 1),
      disabled = _useDisabled2[0];

  var _useTextBoxValue = useTextBoxValue(),
      _useTextBoxValue2 = _slicedToArray(_useTextBoxValue, 2),
      textBoxValue = _useTextBoxValue2[0],
      setTextBoxValue = _useTextBoxValue2[1];

  var inputElementRef = (0, _react.useRef)();
  var localize = useLocalizer();
  var placeCheckpointOnChangeRef = (0, _react.useRef)(false);
  var prevInputStateRef = (0, _react.useRef)();
  var rootClassName = (0, _useStyleToEmotionObject.default)()(ROOT_STYLE) + '';
  var submitTextBox = useTextBoxSubmit();
  var undoStackRef = (0, _react.useRef)([]);
  var inputRefCallback = (0, _react.useCallback)(function (element) {
    if (typeof forwardedRef === 'function') {
      forwardedRef(element);
    } else if (forwardedRef) {
      forwardedRef.current = element;
    }

    inputElementRef.current = element;
  }, [forwardedRef, inputElementRef]);
  var sendBoxString = localize('TEXT_INPUT_ALT');
  var typeYourMessageString = localize('TEXT_INPUT_PLACEHOLDER');
  var rememberInputState = (0, _react.useCallback)(function () {
    var _inputElementRef$curr = inputElementRef.current,
        selectionEnd = _inputElementRef$curr.selectionEnd,
        selectionStart = _inputElementRef$curr.selectionStart,
        value = _inputElementRef$curr.value;
    prevInputStateRef.current = {
      selectionEnd: selectionEnd,
      selectionStart: selectionStart,
      value: value
    };
  }, [inputElementRef, prevInputStateRef]); // This is for TypeFocusSink. When the focus in on the script, then starting press "a", without this line, it would cause errors.
  // We call rememberInputState() when "onFocus" event is fired, but since this is from TypeFocusSink, we are not able to receive "onFocus" event before it happen.

  (0, _react.useEffect)(rememberInputState, [rememberInputState]); // This is for moving the selection while setting the send box value.
  // If we only use setSendBox, we will need to wait for the next render cycle to get the value in, before we can set selectionEnd/Start.

  var setSelectionRangeAndValue = (0, _react.useCallback)(function (_ref5) {
    var selectionEnd = _ref5.selectionEnd,
        selectionStart = _ref5.selectionStart,
        value = _ref5.value;

    if (inputElementRef.current) {
      // We need to set the value, before selectionStart/selectionEnd.
      inputElementRef.current.value = value;
      inputElementRef.current.selectionStart = selectionStart;
      inputElementRef.current.selectionEnd = selectionEnd;
    }

    setSendBox(value);
  }, [inputElementRef, setSendBox]);
  var handleChange = (0, _react.useCallback)(function (event) {
    var _event$target = event.target,
        selectionEnd = _event$target.selectionEnd,
        selectionStart = _event$target.selectionStart,
        value = _event$target.value;

    if (placeCheckpointOnChangeRef.current) {
      undoStackRef.current.push(_objectSpread({}, prevInputStateRef.current));
      placeCheckpointOnChangeRef.current = false;
    }

    var nextInputState = setTextBoxValue(value, {
      selectionEnd: selectionEnd,
      selectionStart: selectionStart
    }); // If an emoticon is converted to emoji, place another checkpoint.

    if (nextInputState.value !== value) {
      undoStackRef.current.push({
        selectionEnd: selectionEnd,
        selectionStart: selectionStart,
        value: value
      });
      placeCheckpointOnChangeRef.current = true;
      setSelectionRangeAndValue(nextInputState);
    }
  }, [placeCheckpointOnChangeRef, prevInputStateRef, setSelectionRangeAndValue, setTextBoxValue, undoStackRef]);
  var handleFocus = (0, _react.useCallback)(function () {
    rememberInputState();
    placeCheckpointOnChangeRef.current = true;
  }, [placeCheckpointOnChangeRef, rememberInputState]);
  var handleKeyDown = (0, _react.useCallback)(function (event) {
    var ctrlKey = event.ctrlKey,
        key = event.key,
        metaKey = event.metaKey;

    if ((ctrlKey || metaKey) && (key === 'Z' || key === 'z')) {
      event.preventDefault();
      var poppedInputState = undoStackRef.current.pop();

      if (poppedInputState) {
        prevInputStateRef.current = _objectSpread({}, poppedInputState);
      } else {
        prevInputStateRef.current = {
          selectionEnd: 0,
          selectionStart: 0,
          value: ''
        };
      }

      setSelectionRangeAndValue(prevInputStateRef.current);
    }
  }, [prevInputStateRef, setSelectionRangeAndValue, undoStackRef]);
  var handleKeyPress = (0, _react.useCallback)(function (event) {
    var key = event.key,
        shiftKey = event.shiftKey;

    if (key === 'Enter' && !shiftKey) {
      event.preventDefault(); // If text box is submitted, focus on the send box

      submitTextBox('sendBox'); // After submit, we will clear the undo stack.

      undoStackRef.current = [];
    }
  }, [submitTextBox, undoStackRef]);
  var handleSelect = (0, _react.useCallback)(function (_ref6) {
    var _ref6$target = _ref6.target,
        selectionEnd = _ref6$target.selectionEnd,
        selectionStart = _ref6$target.selectionStart,
        value = _ref6$target.value;

    if (value === prevInputStateRef.current.value) {
      // When caret move, we should push to undo stack on change.
      placeCheckpointOnChangeRef.current = true;
    }

    prevInputStateRef.current = {
      selectionEnd: selectionEnd,
      selectionStart: selectionStart,
      value: value
    };
  }, [placeCheckpointOnChangeRef, prevInputStateRef]);
  var handleSubmit = (0, _react.useCallback)(function (event) {
    event.preventDefault(); // Consider clearing the send box only after we received POST_ACTIVITY_PENDING
    // E.g. if the connection is bad, sending the message essentially do nothing but just clearing the send box

    submitTextBox(); // After submit, we will clear the undo stack.

    undoStackRef.current = [];
  }, [submitTextBox, undoStackRef]);
  return /*#__PURE__*/_react.default.createElement("form", {
    "aria-disabled": disabled,
    className: (0, _classnames.default)('webchat__send-box-text-box', rootClassName, sendBoxTextAreaStyleSet + '', sendBoxTextBoxStyleSet + '', (className || '') + ''),
    onSubmit: disabled ? PREVENT_DEFAULT_HANDLER : handleSubmit
  }, !sendBoxTextWrap ? /*#__PURE__*/_react.default.createElement(_AccessibleInputText.default, {
    "aria-label": sendBoxString,
    className: "webchat__send-box-text-box__input",
    "data-id": "webchat-sendbox-input",
    disabled: disabled,
    enterkeyhint: "send" // The version of React we are using does not support "enterKeyHint" yet
    ,
    inputMode: "text",
    onChange: disabled ? undefined : handleChange,
    onFocus: disabled ? undefined : handleFocus,
    onKeyDown: disabled ? undefined : handleKeyDown,
    onKeyPress: disabled ? undefined : handleKeyPress,
    onSelect: disabled ? undefined : handleSelect,
    placeholder: typeYourMessageString,
    readOnly: disabled,
    ref: inputRefCallback,
    type: "text",
    value: textBoxValue
  }) : /*#__PURE__*/_react.default.createElement("div", {
    className: "webchat__send-box-text-box__text-area-box"
  }, /*#__PURE__*/_react.default.createElement(_AccessibleTextArea.default, {
    "aria-label": sendBoxString,
    className: "webchat__send-box-text-box__text-area",
    "data-id": "webchat-sendbox-input",
    disabled: disabled,
    enterkeyhint: "send" // The version of React we are using does not support "enterKeyHint" yet
    ,
    inputMode: "text",
    onChange: disabled ? undefined : handleChange,
    onFocus: disabled ? undefined : handleFocus,
    onKeyDown: disabled ? undefined : handleKeyDown,
    onKeyPress: disabled ? undefined : handleKeyPress,
    onSelect: disabled ? undefined : handleSelect,
    placeholder: typeYourMessageString,
    readOnly: disabled,
    ref: inputRefCallback,
    rows: "1",
    value: textBoxValue
  }), /*#__PURE__*/_react.default.createElement("div", {
    className: "webchat__send-box-text-box__text-area-doppelganger"
  }, textBoxValue + '\n')), disabled && /*#__PURE__*/_react.default.createElement("div", {
    className: "webchat__send-box-text-box__glass"
  }));
});
TextBoxCore.defaultProps = {
  className: ''
};
TextBoxCore.propTypes = {
  className: _propTypes.default.string
};

var TextBox = function TextBox(_ref7) {
  var className = _ref7.className;
  return (
    /*#__PURE__*/
    // For DOM node referenced by sendFocusRef, we are using a hack to focus on it.
    // By flipping readOnly attribute while setting focus, we can focus on text box without popping the virtual keyboard on mobile device.
    _react.default.createElement(_TypeFocusSink.Context.Consumer, null, function (_ref8) {
      var sendFocusRef = _ref8.sendFocusRef;
      return /*#__PURE__*/_react.default.createElement(TextBoxCore, {
        className: className,
        ref: sendFocusRef
      });
    })
  );
};

TextBox.defaultProps = {
  className: ''
};
TextBox.propTypes = {
  className: _propTypes.default.string
};
var _default = TextBox;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9TZW5kQm94L1RleHRCb3guanMiXSwibmFtZXMiOlsidXNlRGlzYWJsZWQiLCJob29rcyIsInVzZUxvY2FsaXplciIsInVzZVNlbmRCb3hWYWx1ZSIsInVzZVN0b3BEaWN0YXRlIiwidXNlU3R5bGVPcHRpb25zIiwidXNlU3VibWl0U2VuZEJveCIsIlJPT1RfU1RZTEUiLCJkaXNwbGF5IiwiZmxleCIsImNvbm5lY3RTZW5kVGV4dEJveCIsInNlbGVjdG9ycyIsImNvbm5lY3RUb1dlYkNoYXQiLCJkaXNhYmxlZCIsImZvY3VzU2VuZEJveCIsImxhbmd1YWdlIiwic2Nyb2xsVG9FbmQiLCJzZW5kQm94VmFsdWUiLCJzZXRTZW5kQm94Iiwic3RvcERpY3RhdGUiLCJzdWJtaXRTZW5kQm94Iiwib25DaGFuZ2UiLCJ2YWx1ZSIsInRhcmdldCIsIm9uS2V5UHJlc3MiLCJldmVudCIsImtleSIsInNoaWZ0S2V5IiwicHJldmVudERlZmF1bHQiLCJvblN1Ym1pdCIsInVzZVRleHRCb3hTdWJtaXQiLCJmb2N1cyIsInNldEZvY3VzIiwiY29uc29sZSIsIndhcm4iLCJ1c2VUZXh0Qm94VmFsdWUiLCJzZXRWYWx1ZSIsInJlcGxhY2VFbW90aWNvbiIsInNldHRlciIsIm5leHRWYWx1ZSIsInNlbGVjdGlvbkVuZCIsInNlbGVjdGlvblN0YXJ0IiwiRXJyb3IiLCJsZW5ndGgiLCJuZXh0U2VsZWN0aW9uRW5kIiwibmV4dFNlbGVjdGlvblN0YXJ0IiwibmV4dFZhbHVlV2l0aEVtb2ppIiwiUFJFVkVOVF9ERUZBVUxUX0hBTkRMRVIiLCJUZXh0Qm94Q29yZSIsImZvcndhcmRlZFJlZiIsImNsYXNzTmFtZSIsInNlbmRCb3hUZXh0QXJlYVN0eWxlU2V0Iiwic2VuZEJveFRleHRBcmVhIiwic2VuZEJveFRleHRCb3hTdHlsZVNldCIsInNlbmRCb3hUZXh0Qm94Iiwic2VuZEJveFRleHRXcmFwIiwidGV4dEJveFZhbHVlIiwic2V0VGV4dEJveFZhbHVlIiwiaW5wdXRFbGVtZW50UmVmIiwibG9jYWxpemUiLCJwbGFjZUNoZWNrcG9pbnRPbkNoYW5nZVJlZiIsInByZXZJbnB1dFN0YXRlUmVmIiwicm9vdENsYXNzTmFtZSIsInN1Ym1pdFRleHRCb3giLCJ1bmRvU3RhY2tSZWYiLCJpbnB1dFJlZkNhbGxiYWNrIiwiZWxlbWVudCIsImN1cnJlbnQiLCJzZW5kQm94U3RyaW5nIiwidHlwZVlvdXJNZXNzYWdlU3RyaW5nIiwicmVtZW1iZXJJbnB1dFN0YXRlIiwic2V0U2VsZWN0aW9uUmFuZ2VBbmRWYWx1ZSIsImhhbmRsZUNoYW5nZSIsInB1c2giLCJuZXh0SW5wdXRTdGF0ZSIsImhhbmRsZUZvY3VzIiwiaGFuZGxlS2V5RG93biIsImN0cmxLZXkiLCJtZXRhS2V5IiwicG9wcGVkSW5wdXRTdGF0ZSIsInBvcCIsImhhbmRsZUtleVByZXNzIiwiaGFuZGxlU2VsZWN0IiwiaGFuZGxlU3VibWl0IiwidW5kZWZpbmVkIiwiZGVmYXVsdFByb3BzIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwic3RyaW5nIiwiVGV4dEJveCIsInNlbmRGb2N1c1JlZiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFFUUEsVyxHQUFrR0MsNkIsQ0FBbEdELFc7SUFBYUUsWSxHQUFxRkQsNkIsQ0FBckZDLFk7SUFBY0MsZSxHQUF1RUYsNkIsQ0FBdkVFLGU7SUFBaUJDLGMsR0FBc0RILDZCLENBQXRERyxjO0lBQWdCQyxlLEdBQXNDSiw2QixDQUF0Q0ksZTtJQUFpQkMsZ0IsR0FBcUJMLDZCLENBQXJCSyxnQjtBQUVyRixJQUFNQyxVQUFVLEdBQUc7QUFDakIsa0NBQWdDO0FBQzlCQyxJQUFBQSxPQUFPLEVBQUUsTUFEcUI7QUFHOUIsMEZBQXNGO0FBQ3BGQyxNQUFBQSxJQUFJLEVBQUU7QUFEOEU7QUFIeEQ7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LFdBQVcsQ0FBQ3NDLFNBQVosR0FBd0I7QUFDdEJwQyxFQUFBQSxTQUFTLEVBQUVxQyxtQkFBVUM7QUFEQyxDQUF4Qjs7QUFJQSxJQUFNQyxPQUFPLEdBQUcsU0FBVkEsT0FBVTtBQUFBLE1BQUd2QyxTQUFILFNBQUdBLFNBQUg7QUFBQTtBQUFBO0FBQ2Q7QUFDQTtBQUNBLGlDQUFDLHNCQUFELENBQXNCLFFBQXRCLFFBQ0c7QUFBQSxVQUFHd0MsWUFBSCxTQUFHQSxZQUFIO0FBQUEsMEJBQXNCLDZCQUFDLFdBQUQ7QUFBYSxRQUFBLFNBQVMsRUFBRXhDLFNBQXhCO0FBQW1DLFFBQUEsR0FBRyxFQUFFd0M7QUFBeEMsUUFBdEI7QUFBQSxLQURIO0FBSGM7QUFBQSxDQUFoQjs7QUFRQUQsT0FBTyxDQUFDSixZQUFSLEdBQXVCO0FBQ3JCbkMsRUFBQUEsU0FBUyxFQUFFO0FBRFUsQ0FBdkI7QUFJQXVDLE9BQU8sQ0FBQ0gsU0FBUixHQUFvQjtBQUNsQnBDLEVBQUFBLFNBQVMsRUFBRXFDLG1CQUFVQztBQURILENBQXBCO2VBSWVDLE8iLCJzb3VyY2VSb290IjoiY29tcG9uZW50Oi8vLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGhvb2tzIH0gZnJvbSAnYm90ZnJhbWV3b3JrLXdlYmNoYXQtYXBpJztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCwgeyBmb3J3YXJkUmVmLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IENvbnRleHQgYXMgVHlwZUZvY3VzU2lua0NvbnRleHQgfSBmcm9tICcuLi9VdGlscy9UeXBlRm9jdXNTaW5rJztcbmltcG9ydCBBY2Nlc3NpYmxlSW5wdXRUZXh0IGZyb20gJy4uL1V0aWxzL0FjY2Vzc2libGVJbnB1dFRleHQnO1xuaW1wb3J0IEFjY2Vzc2libGVUZXh0QXJlYSBmcm9tICcuLi9VdGlscy9BY2Nlc3NpYmxlVGV4dEFyZWEnO1xuaW1wb3J0IGNvbm5lY3RUb1dlYkNoYXQgZnJvbSAnLi4vY29ubmVjdFRvV2ViQ2hhdCc7XG5pbXBvcnQgdXNlRm9jdXMgZnJvbSAnLi4vaG9va3MvdXNlRm9jdXMnO1xuaW1wb3J0IHVzZVJlcGxhY2VFbW90aWNvbiBmcm9tICcuLi9ob29rcy9pbnRlcm5hbC91c2VSZXBsYWNlRW1vdGljb24nO1xuaW1wb3J0IHVzZVNjcm9sbFRvRW5kIGZyb20gJy4uL2hvb2tzL3VzZVNjcm9sbFRvRW5kJztcbmltcG9ydCB1c2VTdHlsZVNldCBmcm9tICcuLi9ob29rcy91c2VTdHlsZVNldCc7XG5pbXBvcnQgdXNlU3R5bGVUb0Vtb3Rpb25PYmplY3QgZnJvbSAnLi4vaG9va3MvaW50ZXJuYWwvdXNlU3R5bGVUb0Vtb3Rpb25PYmplY3QnO1xuXG5jb25zdCB7IHVzZURpc2FibGVkLCB1c2VMb2NhbGl6ZXIsIHVzZVNlbmRCb3hWYWx1ZSwgdXNlU3RvcERpY3RhdGUsIHVzZVN0eWxlT3B0aW9ucywgdXNlU3VibWl0U2VuZEJveCB9ID0gaG9va3M7XG5cbmNvbnN0IFJPT1RfU1RZTEUgPSB7XG4gICcmLndlYmNoYXRfX3NlbmQtYm94LXRleHQtYm94Jzoge1xuICAgIGRpc3BsYXk6ICdmbGV4JyxcblxuICAgICcmIC53ZWJjaGF0X19zZW5kLWJveC10ZXh0LWJveF9faW5wdXQsICYgLndlYmNoYXRfX3NlbmQtYm94LXRleHQtYm94X190ZXh0LWFyZWEtYm94Jzoge1xuICAgICAgZmxleDogMVxuICAgIH1cbiAgfVxufTtcblxuY29uc3QgY29ubmVjdFNlbmRUZXh0Qm94ID0gKC4uLnNlbGVjdG9ycykgPT5cbiAgY29ubmVjdFRvV2ViQ2hhdChcbiAgICAoeyBkaXNhYmxlZCwgZm9jdXNTZW5kQm94LCBsYW5ndWFnZSwgc2Nyb2xsVG9FbmQsIHNlbmRCb3hWYWx1ZSwgc2V0U2VuZEJveCwgc3RvcERpY3RhdGUsIHN1Ym1pdFNlbmRCb3ggfSkgPT4gKHtcbiAgICAgIGRpc2FibGVkLFxuICAgICAgbGFuZ3VhZ2UsXG4gICAgICBvbkNoYW5nZTogKHsgdGFyZ2V0OiB7IHZhbHVlIH0gfSkgPT4ge1xuICAgICAgICBzZXRTZW5kQm94KHZhbHVlKTtcbiAgICAgICAgc3RvcERpY3RhdGUoKTtcbiAgICAgIH0sXG4gICAgICBvbktleVByZXNzOiBldmVudCA9PiB7XG4gICAgICAgIGNvbnN0IHsga2V5LCBzaGlmdEtleSB9ID0gZXZlbnQ7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ0VudGVyJyAmJiAhc2hpZnRLZXkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgaWYgKHNlbmRCb3hWYWx1ZSkge1xuICAgICAgICAgICAgc2Nyb2xsVG9FbmQoKTtcbiAgICAgICAgICAgIHN1Ym1pdFNlbmRCb3goKTtcbiAgICAgICAgICAgIGZvY3VzU2VuZEJveCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uU3VibWl0OiBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gQ29uc2lkZXIgY2xlYXJpbmcgdGhlIHNlbmQgYm94IG9ubHkgYWZ0ZXIgd2UgcmVjZWl2ZWQgUE9TVF9BQ1RJVklUWV9QRU5ESU5HXG4gICAgICAgIC8vIEUuZy4gaWYgdGhlIGNvbm5lY3Rpb24gaXMgYmFkLCBzZW5kaW5nIHRoZSBtZXNzYWdlIGVzc2VudGlhbGx5IGRvIG5vdGhpbmcgYnV0IGp1c3QgY2xlYXJpbmcgdGhlIHNlbmQgYm94XG5cbiAgICAgICAgaWYgKHNlbmRCb3hWYWx1ZSkge1xuICAgICAgICAgIHNjcm9sbFRvRW5kKCk7XG4gICAgICAgICAgc3VibWl0U2VuZEJveCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmFsdWU6IHNlbmRCb3hWYWx1ZVxuICAgIH0pLFxuICAgIC4uLnNlbGVjdG9yc1xuICApO1xuXG5mdW5jdGlvbiB1c2VUZXh0Qm94U3VibWl0KCkge1xuICBjb25zdCBbc2VuZEJveFZhbHVlXSA9IHVzZVNlbmRCb3hWYWx1ZSgpO1xuICBjb25zdCBmb2N1cyA9IHVzZUZvY3VzKCk7XG4gIGNvbnN0IHNjcm9sbFRvRW5kID0gdXNlU2Nyb2xsVG9FbmQoKTtcbiAgY29uc3Qgc3VibWl0U2VuZEJveCA9IHVzZVN1Ym1pdFNlbmRCb3goKTtcblxuICByZXR1cm4gdXNlQ2FsbGJhY2soXG4gICAgc2V0Rm9jdXMgPT4ge1xuICAgICAgaWYgKHNlbmRCb3hWYWx1ZSkge1xuICAgICAgICBzY3JvbGxUb0VuZCgpO1xuICAgICAgICBzdWJtaXRTZW5kQm94KCk7XG5cbiAgICAgICAgaWYgKHNldEZvY3VzKSB7XG4gICAgICAgICAgaWYgKHNldEZvY3VzID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIGBcImJvdGZyYW1ld29yay13ZWJjaGF0OiBQYXNzaW5nIFwidHJ1ZVwiIHRvIFwidXNlVGV4dEJveFN1Ym1pdFwiIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBvbiBvciBhZnRlciAyMDIyLTA0LTIzLiBQbGVhc2UgcGFzcyBcInNlbmRCb3hcIiBpbnN0ZWFkLlwiYFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZm9jdXMoJ3NlbmRCb3gnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9jdXMoc2V0Rm9jdXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gISFzZW5kQm94VmFsdWU7XG4gICAgfSxcbiAgICBbZm9jdXMsIHNjcm9sbFRvRW5kLCBzZW5kQm94VmFsdWUsIHN1Ym1pdFNlbmRCb3hdXG4gICk7XG59XG5cbmZ1bmN0aW9uIHVzZVRleHRCb3hWYWx1ZSgpIHtcbiAgY29uc3QgW3ZhbHVlLCBzZXRWYWx1ZV0gPSB1c2VTZW5kQm94VmFsdWUoKTtcbiAgY29uc3QgcmVwbGFjZUVtb3RpY29uID0gdXNlUmVwbGFjZUVtb3RpY29uKCk7XG4gIGNvbnN0IHN0b3BEaWN0YXRlID0gdXNlU3RvcERpY3RhdGUoKTtcblxuICBjb25zdCBzZXR0ZXIgPSB1c2VDYWxsYmFjayhcbiAgICAobmV4dFZhbHVlLCB7IHNlbGVjdGlvbkVuZCwgc2VsZWN0aW9uU3RhcnQgfSA9IHt9KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG5leHRWYWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdib3RmcmFtZXdvcmstd2ViY2hhdDogRmlyc3QgYXJndW1lbnQgcGFzc2VkIHRvIHVzZVRleHRCb3hWYWx1ZSgpIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEN1cnJlbnRseSwgd2UgY2Fubm90IGRldGVjdCB3aGV0aGVyIHRoZSBjaGFuZ2UgaXMgZHVlIHRvIGNsaXBib2FyZCBwYXN0ZSBvciBwcmVzc2luZyBhIGtleSBvbiB0aGUga2V5Ym9hcmQuXG4gICAgICAvLyBXZSBzaG91bGQgbm90IGNoYW5nZSB0byBlbW9qaSB3aGVuIHRoZSB1c2VyIGlzIHBhc3RpbmcgdGV4dC5cbiAgICAgIC8vIFdlIHdvdWxkIGFzc3VtZSwgZm9yIGEgc2luZ2xlIGNoYXJhY3RlciBhZGRpdGlvbiwgdGhlIHVzZXIgbXVzdCBiZSBwcmVzc2luZyBhIGtleS5cbiAgICAgIGlmIChuZXh0VmFsdWUubGVuZ3RoID09PSB2YWx1ZS5sZW5ndGggKyAxKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzZWxlY3Rpb25FbmQ6IG5leHRTZWxlY3Rpb25FbmQsXG4gICAgICAgICAgc2VsZWN0aW9uU3RhcnQ6IG5leHRTZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICB2YWx1ZTogbmV4dFZhbHVlV2l0aEVtb2ppXG4gICAgICAgIH0gPSByZXBsYWNlRW1vdGljb24oeyBzZWxlY3Rpb25FbmQsIHNlbGVjdGlvblN0YXJ0LCB2YWx1ZTogbmV4dFZhbHVlIH0pO1xuXG4gICAgICAgIHNlbGVjdGlvbkVuZCA9IG5leHRTZWxlY3Rpb25FbmQ7XG4gICAgICAgIHNlbGVjdGlvblN0YXJ0ID0gbmV4dFNlbGVjdGlvblN0YXJ0O1xuICAgICAgICBuZXh0VmFsdWUgPSBuZXh0VmFsdWVXaXRoRW1vamk7XG4gICAgICB9XG5cbiAgICAgIHNldFZhbHVlKG5leHRWYWx1ZSk7XG4gICAgICBzdG9wRGljdGF0ZSgpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3Rpb25FbmQsXG4gICAgICAgIHNlbGVjdGlvblN0YXJ0LFxuICAgICAgICB2YWx1ZTogbmV4dFZhbHVlXG4gICAgICB9O1xuICAgIH0sXG4gICAgW3JlcGxhY2VFbW90aWNvbiwgc2V0VmFsdWUsIHN0b3BEaWN0YXRlLCB2YWx1ZV1cbiAgKTtcblxuICByZXR1cm4gW3ZhbHVlLCBzZXR0ZXJdO1xufVxuXG5jb25zdCBQUkVWRU5UX0RFRkFVTFRfSEFORExFUiA9IGV2ZW50ID0+IGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbmNvbnN0IFRleHRCb3hDb3JlID0gZm9yd2FyZFJlZigoeyBjbGFzc05hbWUgfSwgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGNvbnN0IFssIHNldFNlbmRCb3hdID0gdXNlU2VuZEJveFZhbHVlKCk7XG4gIGNvbnN0IFt7IHNlbmRCb3hUZXh0QXJlYTogc2VuZEJveFRleHRBcmVhU3R5bGVTZXQsIHNlbmRCb3hUZXh0Qm94OiBzZW5kQm94VGV4dEJveFN0eWxlU2V0IH1dID0gdXNlU3R5bGVTZXQoKTtcbiAgY29uc3QgW3sgc2VuZEJveFRleHRXcmFwIH1dID0gdXNlU3R5bGVPcHRpb25zKCk7XG4gIGNvbnN0IFtkaXNhYmxlZF0gPSB1c2VEaXNhYmxlZCgpO1xuICBjb25zdCBbdGV4dEJveFZhbHVlLCBzZXRUZXh0Qm94VmFsdWVdID0gdXNlVGV4dEJveFZhbHVlKCk7XG4gIGNvbnN0IGlucHV0RWxlbWVudFJlZiA9IHVzZVJlZigpO1xuICBjb25zdCBsb2NhbGl6ZSA9IHVzZUxvY2FsaXplcigpO1xuICBjb25zdCBwbGFjZUNoZWNrcG9pbnRPbkNoYW5nZVJlZiA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHByZXZJbnB1dFN0YXRlUmVmID0gdXNlUmVmKCk7XG4gIGNvbnN0IHJvb3RDbGFzc05hbWUgPSB1c2VTdHlsZVRvRW1vdGlvbk9iamVjdCgpKFJPT1RfU1RZTEUpICsgJyc7XG4gIGNvbnN0IHN1Ym1pdFRleHRCb3ggPSB1c2VUZXh0Qm94U3VibWl0KCk7XG4gIGNvbnN0IHVuZG9TdGFja1JlZiA9IHVzZVJlZihbXSk7XG5cbiAgY29uc3QgaW5wdXRSZWZDYWxsYmFjayA9IHVzZUNhbGxiYWNrKFxuICAgIGVsZW1lbnQgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBmb3J3YXJkZWRSZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm9yd2FyZGVkUmVmKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmIChmb3J3YXJkZWRSZWYpIHtcbiAgICAgICAgZm9yd2FyZGVkUmVmLmN1cnJlbnQgPSBlbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBpbnB1dEVsZW1lbnRSZWYuY3VycmVudCA9IGVsZW1lbnQ7XG4gICAgfSxcbiAgICBbZm9yd2FyZGVkUmVmLCBpbnB1dEVsZW1lbnRSZWZdXG4gICk7XG5cbiAgY29uc3Qgc2VuZEJveFN0cmluZyA9IGxvY2FsaXplKCdURVhUX0lOUFVUX0FMVCcpO1xuICBjb25zdCB0eXBlWW91ck1lc3NhZ2VTdHJpbmcgPSBsb2NhbGl6ZSgnVEVYVF9JTlBVVF9QTEFDRUhPTERFUicpO1xuXG4gIGNvbnN0IHJlbWVtYmVySW5wdXRTdGF0ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50OiB7IHNlbGVjdGlvbkVuZCwgc2VsZWN0aW9uU3RhcnQsIHZhbHVlIH1cbiAgICB9ID0gaW5wdXRFbGVtZW50UmVmO1xuXG4gICAgcHJldklucHV0U3RhdGVSZWYuY3VycmVudCA9IHsgc2VsZWN0aW9uRW5kLCBzZWxlY3Rpb25TdGFydCwgdmFsdWUgfTtcbiAgfSwgW2lucHV0RWxlbWVudFJlZiwgcHJldklucHV0U3RhdGVSZWZdKTtcblxuICAvLyBUaGlzIGlzIGZvciBUeXBlRm9jdXNTaW5rLiBXaGVuIHRoZSBmb2N1cyBpbiBvbiB0aGUgc2NyaXB0LCB0aGVuIHN0YXJ0aW5nIHByZXNzIFwiYVwiLCB3aXRob3V0IHRoaXMgbGluZSwgaXQgd291bGQgY2F1c2UgZXJyb3JzLlxuICAvLyBXZSBjYWxsIHJlbWVtYmVySW5wdXRTdGF0ZSgpIHdoZW4gXCJvbkZvY3VzXCIgZXZlbnQgaXMgZmlyZWQsIGJ1dCBzaW5jZSB0aGlzIGlzIGZyb20gVHlwZUZvY3VzU2luaywgd2UgYXJlIG5vdCBhYmxlIHRvIHJlY2VpdmUgXCJvbkZvY3VzXCIgZXZlbnQgYmVmb3JlIGl0IGhhcHBlbi5cbiAgdXNlRWZmZWN0KHJlbWVtYmVySW5wdXRTdGF0ZSwgW3JlbWVtYmVySW5wdXRTdGF0ZV0pO1xuXG4gIC8vIFRoaXMgaXMgZm9yIG1vdmluZyB0aGUgc2VsZWN0aW9uIHdoaWxlIHNldHRpbmcgdGhlIHNlbmQgYm94IHZhbHVlLlxuICAvLyBJZiB3ZSBvbmx5IHVzZSBzZXRTZW5kQm94LCB3ZSB3aWxsIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgcmVuZGVyIGN5Y2xlIHRvIGdldCB0aGUgdmFsdWUgaW4sIGJlZm9yZSB3ZSBjYW4gc2V0IHNlbGVjdGlvbkVuZC9TdGFydC5cbiAgY29uc3Qgc2V0U2VsZWN0aW9uUmFuZ2VBbmRWYWx1ZSA9IHVzZUNhbGxiYWNrKFxuICAgICh7IHNlbGVjdGlvbkVuZCwgc2VsZWN0aW9uU3RhcnQsIHZhbHVlIH0pID0+IHtcbiAgICAgIGlmIChpbnB1dEVsZW1lbnRSZWYuY3VycmVudCkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHNldCB0aGUgdmFsdWUsIGJlZm9yZSBzZWxlY3Rpb25TdGFydC9zZWxlY3Rpb25FbmQuXG4gICAgICAgIGlucHV0RWxlbWVudFJlZi5jdXJyZW50LnZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgaW5wdXRFbGVtZW50UmVmLmN1cnJlbnQuc2VsZWN0aW9uU3RhcnQgPSBzZWxlY3Rpb25TdGFydDtcbiAgICAgICAgaW5wdXRFbGVtZW50UmVmLmN1cnJlbnQuc2VsZWN0aW9uRW5kID0gc2VsZWN0aW9uRW5kO1xuICAgICAgfVxuXG4gICAgICBzZXRTZW5kQm94KHZhbHVlKTtcbiAgICB9LFxuICAgIFtpbnB1dEVsZW1lbnRSZWYsIHNldFNlbmRCb3hdXG4gICk7XG5cbiAgY29uc3QgaGFuZGxlQ2hhbmdlID0gdXNlQ2FsbGJhY2soXG4gICAgZXZlbnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0YXJnZXQ6IHsgc2VsZWN0aW9uRW5kLCBzZWxlY3Rpb25TdGFydCwgdmFsdWUgfVxuICAgICAgfSA9IGV2ZW50O1xuXG4gICAgICBpZiAocGxhY2VDaGVja3BvaW50T25DaGFuZ2VSZWYuY3VycmVudCkge1xuICAgICAgICB1bmRvU3RhY2tSZWYuY3VycmVudC5wdXNoKHsgLi4ucHJldklucHV0U3RhdGVSZWYuY3VycmVudCB9KTtcblxuICAgICAgICBwbGFjZUNoZWNrcG9pbnRPbkNoYW5nZVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5leHRJbnB1dFN0YXRlID0gc2V0VGV4dEJveFZhbHVlKHZhbHVlLCB7IHNlbGVjdGlvbkVuZCwgc2VsZWN0aW9uU3RhcnQgfSk7XG5cbiAgICAgIC8vIElmIGFuIGVtb3RpY29uIGlzIGNvbnZlcnRlZCB0byBlbW9qaSwgcGxhY2UgYW5vdGhlciBjaGVja3BvaW50LlxuICAgICAgaWYgKG5leHRJbnB1dFN0YXRlLnZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICB1bmRvU3RhY2tSZWYuY3VycmVudC5wdXNoKHsgc2VsZWN0aW9uRW5kLCBzZWxlY3Rpb25TdGFydCwgdmFsdWUgfSk7XG5cbiAgICAgICAgcGxhY2VDaGVja3BvaW50T25DaGFuZ2VSZWYuY3VycmVudCA9IHRydWU7XG5cbiAgICAgICAgc2V0U2VsZWN0aW9uUmFuZ2VBbmRWYWx1ZShuZXh0SW5wdXRTdGF0ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbcGxhY2VDaGVja3BvaW50T25DaGFuZ2VSZWYsIHByZXZJbnB1dFN0YXRlUmVmLCBzZXRTZWxlY3Rpb25SYW5nZUFuZFZhbHVlLCBzZXRUZXh0Qm94VmFsdWUsIHVuZG9TdGFja1JlZl1cbiAgKTtcblxuICBjb25zdCBoYW5kbGVGb2N1cyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICByZW1lbWJlcklucHV0U3RhdGUoKTtcblxuICAgIHBsYWNlQ2hlY2twb2ludE9uQ2hhbmdlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICB9LCBbcGxhY2VDaGVja3BvaW50T25DaGFuZ2VSZWYsIHJlbWVtYmVySW5wdXRTdGF0ZV0pO1xuXG4gIGNvbnN0IGhhbmRsZUtleURvd24gPSB1c2VDYWxsYmFjayhcbiAgICBldmVudCA9PiB7XG4gICAgICBjb25zdCB7IGN0cmxLZXksIGtleSwgbWV0YUtleSB9ID0gZXZlbnQ7XG5cbiAgICAgIGlmICgoY3RybEtleSB8fCBtZXRhS2V5KSAmJiAoa2V5ID09PSAnWicgfHwga2V5ID09PSAneicpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgY29uc3QgcG9wcGVkSW5wdXRTdGF0ZSA9IHVuZG9TdGFja1JlZi5jdXJyZW50LnBvcCgpO1xuXG4gICAgICAgIGlmIChwb3BwZWRJbnB1dFN0YXRlKSB7XG4gICAgICAgICAgcHJldklucHV0U3RhdGVSZWYuY3VycmVudCA9IHsgLi4ucG9wcGVkSW5wdXRTdGF0ZSB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZJbnB1dFN0YXRlUmVmLmN1cnJlbnQgPSB7IHNlbGVjdGlvbkVuZDogMCwgc2VsZWN0aW9uU3RhcnQ6IDAsIHZhbHVlOiAnJyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0U2VsZWN0aW9uUmFuZ2VBbmRWYWx1ZShwcmV2SW5wdXRTdGF0ZVJlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtwcmV2SW5wdXRTdGF0ZVJlZiwgc2V0U2VsZWN0aW9uUmFuZ2VBbmRWYWx1ZSwgdW5kb1N0YWNrUmVmXVxuICApO1xuXG4gIGNvbnN0IGhhbmRsZUtleVByZXNzID0gdXNlQ2FsbGJhY2soXG4gICAgZXZlbnQgPT4ge1xuICAgICAgY29uc3QgeyBrZXksIHNoaWZ0S2V5IH0gPSBldmVudDtcblxuICAgICAgaWYgKGtleSA9PT0gJ0VudGVyJyAmJiAhc2hpZnRLZXkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAvLyBJZiB0ZXh0IGJveCBpcyBzdWJtaXR0ZWQsIGZvY3VzIG9uIHRoZSBzZW5kIGJveFxuICAgICAgICBzdWJtaXRUZXh0Qm94KCdzZW5kQm94Jyk7XG5cbiAgICAgICAgLy8gQWZ0ZXIgc3VibWl0LCB3ZSB3aWxsIGNsZWFyIHRoZSB1bmRvIHN0YWNrLlxuICAgICAgICB1bmRvU3RhY2tSZWYuY3VycmVudCA9IFtdO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3N1Ym1pdFRleHRCb3gsIHVuZG9TdGFja1JlZl1cbiAgKTtcblxuICBjb25zdCBoYW5kbGVTZWxlY3QgPSB1c2VDYWxsYmFjayhcbiAgICAoeyB0YXJnZXQ6IHsgc2VsZWN0aW9uRW5kLCBzZWxlY3Rpb25TdGFydCwgdmFsdWUgfSB9KSA9PiB7XG4gICAgICBpZiAodmFsdWUgPT09IHByZXZJbnB1dFN0YXRlUmVmLmN1cnJlbnQudmFsdWUpIHtcbiAgICAgICAgLy8gV2hlbiBjYXJldCBtb3ZlLCB3ZSBzaG91bGQgcHVzaCB0byB1bmRvIHN0YWNrIG9uIGNoYW5nZS5cbiAgICAgICAgcGxhY2VDaGVja3BvaW50T25DaGFuZ2VSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHByZXZJbnB1dFN0YXRlUmVmLmN1cnJlbnQgPSB7IHNlbGVjdGlvbkVuZCwgc2VsZWN0aW9uU3RhcnQsIHZhbHVlIH07XG4gICAgfSxcbiAgICBbcGxhY2VDaGVja3BvaW50T25DaGFuZ2VSZWYsIHByZXZJbnB1dFN0YXRlUmVmXVxuICApO1xuXG4gIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IHVzZUNhbGxiYWNrKFxuICAgIGV2ZW50ID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIC8vIENvbnNpZGVyIGNsZWFyaW5nIHRoZSBzZW5kIGJveCBvbmx5IGFmdGVyIHdlIHJlY2VpdmVkIFBPU1RfQUNUSVZJVFlfUEVORElOR1xuICAgICAgLy8gRS5nLiBpZiB0aGUgY29ubmVjdGlvbiBpcyBiYWQsIHNlbmRpbmcgdGhlIG1lc3NhZ2UgZXNzZW50aWFsbHkgZG8gbm90aGluZyBidXQganVzdCBjbGVhcmluZyB0aGUgc2VuZCBib3hcbiAgICAgIHN1Ym1pdFRleHRCb3goKTtcblxuICAgICAgLy8gQWZ0ZXIgc3VibWl0LCB3ZSB3aWxsIGNsZWFyIHRoZSB1bmRvIHN0YWNrLlxuICAgICAgdW5kb1N0YWNrUmVmLmN1cnJlbnQgPSBbXTtcbiAgICB9LFxuICAgIFtzdWJtaXRUZXh0Qm94LCB1bmRvU3RhY2tSZWZdXG4gICk7XG5cbiAgcmV0dXJuIChcbiAgICA8Zm9ybVxuICAgICAgYXJpYS1kaXNhYmxlZD17ZGlzYWJsZWR9XG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXG4gICAgICAgICd3ZWJjaGF0X19zZW5kLWJveC10ZXh0LWJveCcsXG4gICAgICAgIHJvb3RDbGFzc05hbWUsXG4gICAgICAgIHNlbmRCb3hUZXh0QXJlYVN0eWxlU2V0ICsgJycsXG4gICAgICAgIHNlbmRCb3hUZXh0Qm94U3R5bGVTZXQgKyAnJyxcbiAgICAgICAgKGNsYXNzTmFtZSB8fCAnJykgKyAnJ1xuICAgICAgKX1cbiAgICAgIG9uU3VibWl0PXtkaXNhYmxlZCA/IFBSRVZFTlRfREVGQVVMVF9IQU5ETEVSIDogaGFuZGxlU3VibWl0fVxuICAgID5cbiAgICAgIHshc2VuZEJveFRleHRXcmFwID8gKFxuICAgICAgICA8QWNjZXNzaWJsZUlucHV0VGV4dFxuICAgICAgICAgIGFyaWEtbGFiZWw9e3NlbmRCb3hTdHJpbmd9XG4gICAgICAgICAgY2xhc3NOYW1lPVwid2ViY2hhdF9fc2VuZC1ib3gtdGV4dC1ib3hfX2lucHV0XCJcbiAgICAgICAgICBkYXRhLWlkPVwid2ViY2hhdC1zZW5kYm94LWlucHV0XCJcbiAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XG4gICAgICAgICAgZW50ZXJrZXloaW50PVwic2VuZFwiIC8vIFRoZSB2ZXJzaW9uIG9mIFJlYWN0IHdlIGFyZSB1c2luZyBkb2VzIG5vdCBzdXBwb3J0IFwiZW50ZXJLZXlIaW50XCIgeWV0XG4gICAgICAgICAgaW5wdXRNb2RlPVwidGV4dFwiXG4gICAgICAgICAgb25DaGFuZ2U9e2Rpc2FibGVkID8gdW5kZWZpbmVkIDogaGFuZGxlQ2hhbmdlfVxuICAgICAgICAgIG9uRm9jdXM9e2Rpc2FibGVkID8gdW5kZWZpbmVkIDogaGFuZGxlRm9jdXN9XG4gICAgICAgICAgb25LZXlEb3duPXtkaXNhYmxlZCA/IHVuZGVmaW5lZCA6IGhhbmRsZUtleURvd259XG4gICAgICAgICAgb25LZXlQcmVzcz17ZGlzYWJsZWQgPyB1bmRlZmluZWQgOiBoYW5kbGVLZXlQcmVzc31cbiAgICAgICAgICBvblNlbGVjdD17ZGlzYWJsZWQgPyB1bmRlZmluZWQgOiBoYW5kbGVTZWxlY3R9XG4gICAgICAgICAgcGxhY2Vob2xkZXI9e3R5cGVZb3VyTWVzc2FnZVN0cmluZ31cbiAgICAgICAgICByZWFkT25seT17ZGlzYWJsZWR9XG4gICAgICAgICAgcmVmPXtpbnB1dFJlZkNhbGxiYWNrfVxuICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICB2YWx1ZT17dGV4dEJveFZhbHVlfVxuICAgICAgICAvPlxuICAgICAgKSA6IChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3ZWJjaGF0X19zZW5kLWJveC10ZXh0LWJveF9fdGV4dC1hcmVhLWJveFwiPlxuICAgICAgICAgIDxBY2Nlc3NpYmxlVGV4dEFyZWFcbiAgICAgICAgICAgIGFyaWEtbGFiZWw9e3NlbmRCb3hTdHJpbmd9XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJ3ZWJjaGF0X19zZW5kLWJveC10ZXh0LWJveF9fdGV4dC1hcmVhXCJcbiAgICAgICAgICAgIGRhdGEtaWQ9XCJ3ZWJjaGF0LXNlbmRib3gtaW5wdXRcIlxuICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgICAgICAgZW50ZXJrZXloaW50PVwic2VuZFwiIC8vIFRoZSB2ZXJzaW9uIG9mIFJlYWN0IHdlIGFyZSB1c2luZyBkb2VzIG5vdCBzdXBwb3J0IFwiZW50ZXJLZXlIaW50XCIgeWV0XG4gICAgICAgICAgICBpbnB1dE1vZGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgIG9uQ2hhbmdlPXtkaXNhYmxlZCA/IHVuZGVmaW5lZCA6IGhhbmRsZUNoYW5nZX1cbiAgICAgICAgICAgIG9uRm9jdXM9e2Rpc2FibGVkID8gdW5kZWZpbmVkIDogaGFuZGxlRm9jdXN9XG4gICAgICAgICAgICBvbktleURvd249e2Rpc2FibGVkID8gdW5kZWZpbmVkIDogaGFuZGxlS2V5RG93bn1cbiAgICAgICAgICAgIG9uS2V5UHJlc3M9e2Rpc2FibGVkID8gdW5kZWZpbmVkIDogaGFuZGxlS2V5UHJlc3N9XG4gICAgICAgICAgICBvblNlbGVjdD17ZGlzYWJsZWQgPyB1bmRlZmluZWQgOiBoYW5kbGVTZWxlY3R9XG4gICAgICAgICAgICBwbGFjZWhvbGRlcj17dHlwZVlvdXJNZXNzYWdlU3RyaW5nfVxuICAgICAgICAgICAgcmVhZE9ubHk9e2Rpc2FibGVkfVxuICAgICAgICAgICAgcmVmPXtpbnB1dFJlZkNhbGxiYWNrfVxuICAgICAgICAgICAgcm93cz1cIjFcIlxuICAgICAgICAgICAgdmFsdWU9e3RleHRCb3hWYWx1ZX1cbiAgICAgICAgICAvPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwid2ViY2hhdF9fc2VuZC1ib3gtdGV4dC1ib3hfX3RleHQtYXJlYS1kb3BwZWxnYW5nZXJcIj57dGV4dEJveFZhbHVlICsgJ1xcbid9PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICAgIHtkaXNhYmxlZCAmJiA8ZGl2IGNsYXNzTmFtZT1cIndlYmNoYXRfX3NlbmQtYm94LXRleHQtYm94X19nbGFzc1wiIC8+fVxuICAgIDwvZm9ybT5cbiAgKTtcbn0pO1xuXG5UZXh0Qm94Q29yZS5kZWZhdWx0UHJvcHMgPSB7XG4gIGNsYXNzTmFtZTogJydcbn07XG5cblRleHRCb3hDb3JlLnByb3BUeXBlcyA9IHtcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nXG59O1xuXG5jb25zdCBUZXh0Qm94ID0gKHsgY2xhc3NOYW1lIH0pID0+IChcbiAgLy8gRm9yIERPTSBub2RlIHJlZmVyZW5jZWQgYnkgc2VuZEZvY3VzUmVmLCB3ZSBhcmUgdXNpbmcgYSBoYWNrIHRvIGZvY3VzIG9uIGl0LlxuICAvLyBCeSBmbGlwcGluZyByZWFkT25seSBhdHRyaWJ1dGUgd2hpbGUgc2V0dGluZyBmb2N1cywgd2UgY2FuIGZvY3VzIG9uIHRleHQgYm94IHdpdGhvdXQgcG9wcGluZyB0aGUgdmlydHVhbCBrZXlib2FyZCBvbiBtb2JpbGUgZGV2aWNlLlxuICA8VHlwZUZvY3VzU2lua0NvbnRleHQuQ29uc3VtZXI+XG4gICAgeyh7IHNlbmRGb2N1c1JlZiB9KSA9PiA8VGV4dEJveENvcmUgY2xhc3NOYW1lPXtjbGFzc05hbWV9IHJlZj17c2VuZEZvY3VzUmVmfSAvPn1cbiAgPC9UeXBlRm9jdXNTaW5rQ29udGV4dC5Db25zdW1lcj5cbik7XG5cblRleHRCb3guZGVmYXVsdFByb3BzID0ge1xuICBjbGFzc05hbWU6ICcnXG59O1xuXG5UZXh0Qm94LnByb3BUeXBlcyA9IHtcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nXG59O1xuXG5leHBvcnQgZGVmYXVsdCBUZXh0Qm94O1xuXG5leHBvcnQgeyBjb25uZWN0U2VuZFRleHRCb3gsIHVzZVRleHRCb3hTdWJtaXQsIHVzZVRleHRCb3hWYWx1ZSB9O1xuIl19