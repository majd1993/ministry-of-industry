"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = playCognitiveServicesStream;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _cognitiveServicesAsyncFunctionToESAsyncFunction = _interopRequireDefault(require("./cognitiveServicesAsyncFunctionToESAsyncFunction"));

var _createMultiBufferingPlayer = _interopRequireDefault(require("./createMultiBufferingPlayer"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Safari requires an audio buffer with a sample rate of 22050 Hz.
// Using a minimum sample rate of 44100 Hz as an example, the Speech SDK's default 16000 Hz will be upsampled to 48000 Hz.
var MIN_SAMPLE_RATE = 44100; // The Speech SDK is hardcoded to chop packets to 4096 bytes.
// Web Chat's multi-buffering player is set up with 3 buffers; each is 4096 bytes (2048 16-bit samples).
// For simplicity, the multi-buffer player currently does not support progressive buffering.
// Progressive buffering allows queuing at any sample size and will be concatenated.
// If 1000 samples are queued, then 1048 samples are queued, they will be concatenated into a single buffer of size 2048.
// For simplicity, data will be queued to two buffers.
// The first buffer is 1000 samples followed by 1048 zeroes, and the second buffer is 1048 samples followed by 1000 zeroes.
// There is no plan to support progressive buffering until the Speech SDK chops data at dynamic size.

var DEFAULT_BUFFER_SIZE = 4096;

function average(array) {
  return array.reduce(function (sum, value) {
    return sum + value;
  }, 0) / array.length;
}

function formatTypedBitArrayToFloatArray(audioData, maxValue) {
  var float32Data = new Float32Array(audioData.length);

  for (var i = 0; i < audioData.length; i++) {
    float32Data[i] = audioData[i] / maxValue;
  }

  return float32Data;
}

function formatAudioDataArrayBufferToFloatArray(_ref, arrayBuffer) {
  var bitsPerSample = _ref.bitsPerSample;

  switch (bitsPerSample) {
    case 8:
      return formatTypedBitArrayToFloatArray(new Int8Array(arrayBuffer), 128);

    case 16:
      return formatTypedBitArrayToFloatArray(new Int16Array(arrayBuffer), 32768);

    case 32:
      return formatTypedBitArrayToFloatArray(new Int32Array(arrayBuffer), 2147483648);

    default:
      throw new Error('Only WAVE_FORMAT_PCM (8/16/32 bps) format supported at this time');
  }
}

function abortToReject(signal) {
  return new Promise(function (_, reject) {
    signal.onabort = function () {
      return reject(new Error('aborted'));
    };
  });
} // In a 2 channel audio (e.g. A/B), the data arrives as interleaved, like "ABABABABAB".
// This function will take "ABABABABAB" and return an array ["AAAAA", "BBBBB"].


function deinterleave(channelInterleavedAudioData, _ref2) {
  var channels = _ref2.channels;
  var multiChannelArrayBuffer = new Array(channels);
  var frameSize = channelInterleavedAudioData.length / channels;

  for (var channel = 0; channel < channels; channel++) {
    var audioData = new Float32Array(frameSize);
    multiChannelArrayBuffer[channel] = audioData;

    for (var offset = 0; offset < frameSize; offset++) {
      audioData[offset] = channelInterleavedAudioData[offset * channels + channel];
    }
  }

  return multiChannelArrayBuffer;
} // This function upsamples the audio data via an integer multiplier.
// Web Chat uses simple anti-aliasing. For simplicity, the anti-aliasing does not roll over to next buffer.


function multiplySampleRate(source, sampleRateMultiplier) {
  if (sampleRateMultiplier === 1) {
    return source;
  }

  var lastValues = new Array(sampleRateMultiplier).fill(source[0]);
  var target = new Float32Array(source.length * sampleRateMultiplier);

  for (var sourceOffset = 0; sourceOffset < source.length; sourceOffset++) {
    var value = source[sourceOffset];
    var targetOffset = sourceOffset * sampleRateMultiplier;

    for (var multiplierIndex = 0; multiplierIndex < sampleRateMultiplier; multiplierIndex++) {
      lastValues.shift();
      lastValues.push(value);
      target[targetOffset + multiplierIndex] = average(lastValues);
    }
  }

  return target;
}

function playCognitiveServicesStream(_x, _x2) {
  return _playCognitiveServicesStream.apply(this, arguments);
}

function _playCognitiveServicesStream() {
  _playCognitiveServicesStream = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(audioContext, stream) {
    var _ref3,
        _ref3$signal,
        signal,
        queuedBufferSourceNodes,
        _args2 = arguments;

    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _ref3 = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {}, _ref3$signal = _ref3.signal, signal = _ref3$signal === void 0 ? {} : _ref3$signal;

            if (audioContext) {
              _context2.next = 5;
              break;
            }

            throw new Error('botframework-directlinespeech-sdk: audioContext must be specified.');

          case 5:
            if (stream) {
              _context2.next = 9;
              break;
            }

            throw new Error('botframework-directlinespeech-sdk: stream must be specified.');

          case 9:
            if (stream.format) {
              _context2.next = 13;
              break;
            }

            throw new Error('botframework-directlinespeech-sdk: stream is missing format.');

          case 13:
            if (!(typeof stream.read !== 'function')) {
              _context2.next = 15;
              break;
            }

            throw new Error('botframework-directlinespeech-sdk: stream is missing read().');

          case 15:
            queuedBufferSourceNodes = [];
            _context2.prev = 16;
            return _context2.delegateYield( /*#__PURE__*/_regenerator.default.mark(function _callee() {
              var format, abortPromise, array, streamRead, read, newSamplesPerSec, sampleRateMultiplier, player, chunk, maxChunks, interleavedArray, multiChannelArray, upsampledMultiChannelArray;
              return _regenerator.default.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      format = stream.format;
                      abortPromise = abortToReject(signal);
                      array = new Uint8Array(DEFAULT_BUFFER_SIZE);
                      streamRead = (0, _cognitiveServicesAsyncFunctionToESAsyncFunction.default)(stream.read.bind(stream));

                      read = function read() {
                        return Promise.race([// Abort will gracefully end the queue. We will check signal.aborted later to throw abort exception.
                        // eslint-disable-next-line no-empty-function
                        abortPromise.catch(function () {}), streamRead(array.buffer).then(function (numBytes) {
                          return numBytes === array.byteLength ? array : numBytes ? array.slice(0, numBytes) : undefined;
                        })]);
                      };

                      if (!signal.aborted) {
                        _context.next = 7;
                        break;
                      }

                      throw new Error('aborted');

                    case 7:
                      newSamplesPerSec = format.samplesPerSec;
                      sampleRateMultiplier = 1; // Safari requires a minimum sample rate of 22100 Hz.
                      // A multiplier is calculated the the data meets the minimum sample rate.
                      // An integer-based multiplier to simplify our upsampler.
                      // For security, data will only be upsampled up to 96000 Hz.

                      while (newSamplesPerSec < MIN_SAMPLE_RATE && newSamplesPerSec < 96000) {
                        sampleRateMultiplier++;
                        newSamplesPerSec = format.samplesPerSec * sampleRateMultiplier;
                      } // The third parameter is the sample size in bytes.
                      // For example, if the Speech SDK sends Web Chat 4096 bytes of 16-bit samples, there will be 2048 samples per channel.
                      // The multi-buffering player is set up to handle 2048 samples per buffer.
                      // If the multiplier 3x, it will handle 6144 samples per buffer.


                      player = (0, _createMultiBufferingPlayer.default)(audioContext, _objectSpread(_objectSpread({}, format), {}, {
                        samplesPerSec: newSamplesPerSec
                      }), DEFAULT_BUFFER_SIZE / (format.bitsPerSample / 8) * sampleRateMultiplier); // For security, the maximum number of chunks handled will be 1000.

                      _context.next = 13;
                      return read();

                    case 13:
                      chunk = _context.sent;
                      maxChunks = 0;

                    case 15:
                      if (!(chunk && maxChunks < 1000 && !signal.aborted)) {
                        _context.next = 28;
                        break;
                      }

                      if (!signal.aborted) {
                        _context.next = 18;
                        break;
                      }

                      return _context.abrupt("break", 28);

                    case 18:
                      // Data received from Speech SDK is interleaved; 2 channels (e.g. A and B) will be sent as "ABABABABAB"
                      // And each sample (A/B) will be an 8 to 32-bit number.
                      // Convert the 8 - 32-bit number into a floating-point number, as required by Web Audio API.
                      interleavedArray = formatAudioDataArrayBufferToFloatArray(format, chunk.buffer); // Deinterleave data back into two array buffer, e.g. "AAAAA" and "BBBBB".

                      multiChannelArray = deinterleave(interleavedArray, format); // Upsample data if necessary. If the multiplier is 2x, "AAAAA" will be upsampled to "AAAAAAAAAA" (with anti-alias).

                      upsampledMultiChannelArray = multiChannelArray.map(function (array) {
                        return multiplySampleRate(array, sampleRateMultiplier);
                      }); // Queue to the buffering player.

                      player.push(upsampledMultiChannelArray);

                    case 22:
                      _context.next = 24;
                      return read();

                    case 24:
                      chunk = _context.sent;
                      maxChunks++;
                      _context.next = 15;
                      break;

                    case 28:
                      abortPromise.catch(function () {
                        return player.cancelAll();
                      });

                      if (!signal.aborted) {
                        _context.next = 31;
                        break;
                      }

                      throw new Error('aborted');

                    case 31:
                      _context.next = 33;
                      return Promise.race([abortPromise, player.flush()]);

                    case 33:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            })(), "t0", 18);

          case 18:
            _context2.prev = 18;
            queuedBufferSourceNodes.forEach(function (node) {
              return node.stop();
            });
            return _context2.finish(18);

          case 21:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[16,, 18, 21]]);
  }));
  return _playCognitiveServicesStream.apply(this, arguments);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wbGF5Q29nbml0aXZlU2VydmljZXNTdHJlYW0uanMiXSwibmFtZXMiOlsiTUlOX1NBTVBMRV9SQVRFIiwiREVGQVVMVF9CVUZGRVJfU0laRSIsImF2ZXJhZ2UiLCJhcnJheSIsInJlZHVjZSIsInN1bSIsInZhbHVlIiwibGVuZ3RoIiwiZm9ybWF0VHlwZWRCaXRBcnJheVRvRmxvYXRBcnJheSIsImF1ZGlvRGF0YSIsIm1heFZhbHVlIiwiZmxvYXQzMkRhdGEiLCJGbG9hdDMyQXJyYXkiLCJpIiwiZm9ybWF0QXVkaW9EYXRhQXJyYXlCdWZmZXJUb0Zsb2F0QXJyYXkiLCJhcnJheUJ1ZmZlciIsImJpdHNQZXJTYW1wbGUiLCJJbnQ4QXJyYXkiLCJJbnQxNkFycmF5IiwiSW50MzJBcnJheSIsIkVycm9yIiwiYWJvcnRUb1JlamVjdCIsInNpZ25hbCIsIlByb21pc2UiLCJfIiwicmVqZWN0Iiwib25hYm9ydCIsImRlaW50ZXJsZWF2ZSIsImNoYW5uZWxJbnRlcmxlYXZlZEF1ZGlvRGF0YSIsImNoYW5uZWxzIiwibXVsdGlDaGFubmVsQXJyYXlCdWZmZXIiLCJBcnJheSIsImZyYW1lU2l6ZSIsImNoYW5uZWwiLCJvZmZzZXQiLCJtdWx0aXBseVNhbXBsZVJhdGUiLCJzb3VyY2UiLCJzYW1wbGVSYXRlTXVsdGlwbGllciIsImxhc3RWYWx1ZXMiLCJmaWxsIiwidGFyZ2V0Iiwic291cmNlT2Zmc2V0IiwidGFyZ2V0T2Zmc2V0IiwibXVsdGlwbGllckluZGV4Iiwic2hpZnQiLCJwdXNoIiwicGxheUNvZ25pdGl2ZVNlcnZpY2VzU3RyZWFtIiwiYXVkaW9Db250ZXh0Iiwic3RyZWFtIiwiZm9ybWF0IiwicmVhZCIsInF1ZXVlZEJ1ZmZlclNvdXJjZU5vZGVzIiwiYWJvcnRQcm9taXNlIiwiVWludDhBcnJheSIsInN0cmVhbVJlYWQiLCJiaW5kIiwicmFjZSIsImNhdGNoIiwiYnVmZmVyIiwidGhlbiIsIm51bUJ5dGVzIiwiYnl0ZUxlbmd0aCIsInNsaWNlIiwidW5kZWZpbmVkIiwiYWJvcnRlZCIsIm5ld1NhbXBsZXNQZXJTZWMiLCJzYW1wbGVzUGVyU2VjIiwicGxheWVyIiwiY2h1bmsiLCJtYXhDaHVua3MiLCJpbnRlcmxlYXZlZEFycmF5IiwibXVsdGlDaGFubmVsQXJyYXkiLCJ1cHNhbXBsZWRNdWx0aUNoYW5uZWxBcnJheSIsIm1hcCIsImNhbmNlbEFsbCIsImZsdXNoIiwiZm9yRWFjaCIsIm5vZGUiLCJzdG9wIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFJQTs7QUFDQTs7Ozs7O0FBRUE7QUFDQTtBQUNBLElBQU1BLGVBQWUsR0FBRyxLQUF4QixDLENBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7QUFDQSxJQUFNQyxtQkFBbUIsR0FBRyxJQUE1Qjs7QUFFQSxTQUFTQyxPQUFULENBQWlCQyxLQUFqQixFQUF3QjtBQUN0QixTQUFPQSxLQUFLLENBQUNDLE1BQU4sQ0FBYSxVQUFDQyxHQUFELEVBQU1DLEtBQU47QUFBQSxXQUFnQkQsR0FBRyxHQUFHQyxLQUF0QjtBQUFBLEdBQWIsRUFBMEMsQ0FBMUMsSUFBK0NILEtBQUssQ0FBQ0ksTUFBNUQ7QUFDRDs7QUFFRCxTQUFTQywrQkFBVCxDQUF5Q0MsU0FBekMsRUFBb0RDLFFBQXBELEVBQThEO0FBQzVELE1BQU1DLFdBQVcsR0FBRyxJQUFJQyxZQUFKLENBQWlCSCxTQUFTLENBQUNGLE1BQTNCLENBQXBCOztBQUVBLE9BQUssSUFBSU0sQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0osU0FBUyxDQUFDRixNQUE5QixFQUFzQ00sQ0FBQyxFQUF2QyxFQUEyQztBQUN6Q0YsSUFBQUEsV0FBVyxDQUFDRSxDQUFELENBQVgsR0FBaUJKLFNBQVMsQ0FBQ0ksQ0FBRCxDQUFULEdBQWVILFFBQWhDO0FBQ0Q7O0FBRUQsU0FBT0MsV0FBUDtBQUNEOztBQUVELFNBQVNHLHNDQUFULE9BQW1FQyxXQUFuRSxFQUFnRjtBQUFBLE1BQTlCQyxhQUE4QixRQUE5QkEsYUFB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Q0FBQ2lDLElBQVIsQ0FBYSxDQUFDSixZQUFELEVBQWVlLE1BQU0sQ0FBQ1EsS0FBUCxFQUFmLENBQWIsQ0F6Rks7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQTJGWHhCLFlBQUFBLHVCQUF1QixDQUFDeUIsT0FBeEIsQ0FBZ0MsVUFBQUMsSUFBSTtBQUFBLHFCQUFJQSxJQUFJLENBQUNDLElBQUwsRUFBSjtBQUFBLGFBQXBDO0FBM0ZXOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEciLCJzb3VyY2VSb290IjoiZGlyZWN0bGluZXNwZWVjaDovLy8iLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tbWFnaWMtbnVtYmVyczogW1wiZXJyb3JcIiwgeyBcImlnbm9yZVwiOiBbMCwgMSwgOCwgMTYsIDMyLCAxMjgsIDEwMDAsIDMyNzY4LCA5NjAwMCwgMjE0NzQ4MzY0OF0gfV0gKi9cbi8qIGVzbGludCBuby1hd2FpdC1pbi1sb29wOiBcIm9mZlwiICovXG4vKiBlc2xpbnQgcHJlZmVyLWRlc3RydWN0dXJpbmc6IFwib2ZmXCIgKi9cblxuaW1wb3J0IGNvZ25pdGl2ZVNlcnZpY2VzQXN5bmNGdW5jdGlvblRvRVNBc3luY0Z1bmN0aW9uIGZyb20gJy4vY29nbml0aXZlU2VydmljZXNBc3luY0Z1bmN0aW9uVG9FU0FzeW5jRnVuY3Rpb24nO1xuaW1wb3J0IGNyZWF0ZU11bHRpQnVmZmVyaW5nUGxheWVyIGZyb20gJy4vY3JlYXRlTXVsdGlCdWZmZXJpbmdQbGF5ZXInO1xuXG4vLyBTYWZhcmkgcmVxdWlyZXMgYW4gYXVkaW8gYnVmZmVyIHdpdGggYSBzYW1wbGUgcmF0ZSBvZiAyMjA1MCBIei5cbi8vIFVzaW5nIGEgbWluaW11bSBzYW1wbGUgcmF0ZSBvZiA0NDEwMCBIeiBhcyBhbiBleGFtcGxlLCB0aGUgU3BlZWNoIFNESydzIGRlZmF1bHQgMTYwMDAgSHogd2lsbCBiZSB1cHNhbXBsZWQgdG8gNDgwMDAgSHouXG5jb25zdCBNSU5fU0FNUExFX1JBVEUgPSA0NDEwMDtcblxuLy8gVGhlIFNwZWVjaCBTREsgaXMgaGFyZGNvZGVkIHRvIGNob3AgcGFja2V0cyB0byA0MDk2IGJ5dGVzLlxuLy8gV2ViIENoYXQncyBtdWx0aS1idWZmZXJpbmcgcGxheWVyIGlzIHNldCB1cCB3aXRoIDMgYnVmZmVyczsgZWFjaCBpcyA0MDk2IGJ5dGVzICgyMDQ4IDE2LWJpdCBzYW1wbGVzKS5cbi8vIEZvciBzaW1wbGljaXR5LCB0aGUgbXVsdGktYnVmZmVyIHBsYXllciBjdXJyZW50bHkgZG9lcyBub3Qgc3VwcG9ydCBwcm9ncmVzc2l2ZSBidWZmZXJpbmcuXG5cbi8vIFByb2dyZXNzaXZlIGJ1ZmZlcmluZyBhbGxvd3MgcXVldWluZyBhdCBhbnkgc2FtcGxlIHNpemUgYW5kIHdpbGwgYmUgY29uY2F0ZW5hdGVkLlxuLy8gSWYgMTAwMCBzYW1wbGVzIGFyZSBxdWV1ZWQsIHRoZW4gMTA0OCBzYW1wbGVzIGFyZSBxdWV1ZWQsIHRoZXkgd2lsbCBiZSBjb25jYXRlbmF0ZWQgaW50byBhIHNpbmdsZSBidWZmZXIgb2Ygc2l6ZSAyMDQ4LlxuXG4vLyBGb3Igc2ltcGxpY2l0eSwgZGF0YSB3aWxsIGJlIHF1ZXVlZCB0byB0d28gYnVmZmVycy5cbi8vIFRoZSBmaXJzdCBidWZmZXIgaXMgMTAwMCBzYW1wbGVzIGZvbGxvd2VkIGJ5IDEwNDggemVyb2VzLCBhbmQgdGhlIHNlY29uZCBidWZmZXIgaXMgMTA0OCBzYW1wbGVzIGZvbGxvd2VkIGJ5IDEwMDAgemVyb2VzLlxuXG4vLyBUaGVyZSBpcyBubyBwbGFuIHRvIHN1cHBvcnQgcHJvZ3Jlc3NpdmUgYnVmZmVyaW5nIHVudGlsIHRoZSBTcGVlY2ggU0RLIGNob3BzIGRhdGEgYXQgZHluYW1pYyBzaXplLlxuY29uc3QgREVGQVVMVF9CVUZGRVJfU0laRSA9IDQwOTY7XG5cbmZ1bmN0aW9uIGF2ZXJhZ2UoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5LnJlZHVjZSgoc3VtLCB2YWx1ZSkgPT4gc3VtICsgdmFsdWUsIDApIC8gYXJyYXkubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRUeXBlZEJpdEFycmF5VG9GbG9hdEFycmF5KGF1ZGlvRGF0YSwgbWF4VmFsdWUpIHtcbiAgY29uc3QgZmxvYXQzMkRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGF1ZGlvRGF0YS5sZW5ndGgpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXVkaW9EYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgZmxvYXQzMkRhdGFbaV0gPSBhdWRpb0RhdGFbaV0gLyBtYXhWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiBmbG9hdDMyRGF0YTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0QXVkaW9EYXRhQXJyYXlCdWZmZXJUb0Zsb2F0QXJyYXkoeyBiaXRzUGVyU2FtcGxlIH0sIGFycmF5QnVmZmVyKSB7XG4gIHN3aXRjaCAoYml0c1BlclNhbXBsZSkge1xuICAgIGNhc2UgODpcbiAgICAgIHJldHVybiBmb3JtYXRUeXBlZEJpdEFycmF5VG9GbG9hdEFycmF5KG5ldyBJbnQ4QXJyYXkoYXJyYXlCdWZmZXIpLCAxMjgpO1xuXG4gICAgY2FzZSAxNjpcbiAgICAgIHJldHVybiBmb3JtYXRUeXBlZEJpdEFycmF5VG9GbG9hdEFycmF5KG5ldyBJbnQxNkFycmF5KGFycmF5QnVmZmVyKSwgMzI3NjgpO1xuXG4gICAgY2FzZSAzMjpcbiAgICAgIHJldHVybiBmb3JtYXRUeXBlZEJpdEFycmF5VG9GbG9hdEFycmF5KG5ldyBJbnQzMkFycmF5KGFycmF5QnVmZmVyKSwgMjE0NzQ4MzY0OCk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IFdBVkVfRk9STUFUX1BDTSAoOC8xNi8zMiBicHMpIGZvcm1hdCBzdXBwb3J0ZWQgYXQgdGhpcyB0aW1lJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWJvcnRUb1JlamVjdChzaWduYWwpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICBzaWduYWwub25hYm9ydCA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoJ2Fib3J0ZWQnKSk7XG4gIH0pO1xufVxuXG4vLyBJbiBhIDIgY2hhbm5lbCBhdWRpbyAoZS5nLiBBL0IpLCB0aGUgZGF0YSBhcnJpdmVzIGFzIGludGVybGVhdmVkLCBsaWtlIFwiQUJBQkFCQUJBQlwiLlxuLy8gVGhpcyBmdW5jdGlvbiB3aWxsIHRha2UgXCJBQkFCQUJBQkFCXCIgYW5kIHJldHVybiBhbiBhcnJheSBbXCJBQUFBQVwiLCBcIkJCQkJCXCJdLlxuZnVuY3Rpb24gZGVpbnRlcmxlYXZlKGNoYW5uZWxJbnRlcmxlYXZlZEF1ZGlvRGF0YSwgeyBjaGFubmVscyB9KSB7XG4gIGNvbnN0IG11bHRpQ2hhbm5lbEFycmF5QnVmZmVyID0gbmV3IEFycmF5KGNoYW5uZWxzKTtcbiAgY29uc3QgZnJhbWVTaXplID0gY2hhbm5lbEludGVybGVhdmVkQXVkaW9EYXRhLmxlbmd0aCAvIGNoYW5uZWxzO1xuXG4gIGZvciAobGV0IGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgY2hhbm5lbHM7IGNoYW5uZWwrKykge1xuICAgIGNvbnN0IGF1ZGlvRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZnJhbWVTaXplKTtcblxuICAgIG11bHRpQ2hhbm5lbEFycmF5QnVmZmVyW2NoYW5uZWxdID0gYXVkaW9EYXRhO1xuXG4gICAgZm9yIChsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgZnJhbWVTaXplOyBvZmZzZXQrKykge1xuICAgICAgYXVkaW9EYXRhW29mZnNldF0gPSBjaGFubmVsSW50ZXJsZWF2ZWRBdWRpb0RhdGFbb2Zmc2V0ICogY2hhbm5lbHMgKyBjaGFubmVsXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbXVsdGlDaGFubmVsQXJyYXlCdWZmZXI7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gdXBzYW1wbGVzIHRoZSBhdWRpbyBkYXRhIHZpYSBhbiBpbnRlZ2VyIG11bHRpcGxpZXIuXG4vLyBXZWIgQ2hhdCB1c2VzIHNpbXBsZSBhbnRpLWFsaWFzaW5nLiBGb3Igc2ltcGxpY2l0eSwgdGhlIGFudGktYWxpYXNpbmcgZG9lcyBub3Qgcm9sbCBvdmVyIHRvIG5leHQgYnVmZmVyLlxuZnVuY3Rpb24gbXVsdGlwbHlTYW1wbGVSYXRlKHNvdXJjZSwgc2FtcGxlUmF0ZU11bHRpcGxpZXIpIHtcbiAgaWYgKHNhbXBsZVJhdGVNdWx0aXBsaWVyID09PSAxKSB7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIGNvbnN0IGxhc3RWYWx1ZXMgPSBuZXcgQXJyYXkoc2FtcGxlUmF0ZU11bHRpcGxpZXIpLmZpbGwoc291cmNlWzBdKTtcbiAgY29uc3QgdGFyZ2V0ID0gbmV3IEZsb2F0MzJBcnJheShzb3VyY2UubGVuZ3RoICogc2FtcGxlUmF0ZU11bHRpcGxpZXIpO1xuXG4gIGZvciAobGV0IHNvdXJjZU9mZnNldCA9IDA7IHNvdXJjZU9mZnNldCA8IHNvdXJjZS5sZW5ndGg7IHNvdXJjZU9mZnNldCsrKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzb3VyY2Vbc291cmNlT2Zmc2V0XTtcbiAgICBjb25zdCB0YXJnZXRPZmZzZXQgPSBzb3VyY2VPZmZzZXQgKiBzYW1wbGVSYXRlTXVsdGlwbGllcjtcblxuICAgIGZvciAobGV0IG11bHRpcGxpZXJJbmRleCA9IDA7IG11bHRpcGxpZXJJbmRleCA8IHNhbXBsZVJhdGVNdWx0aXBsaWVyOyBtdWx0aXBsaWVySW5kZXgrKykge1xuICAgICAgbGFzdFZhbHVlcy5zaGlmdCgpO1xuICAgICAgbGFzdFZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgIHRhcmdldFt0YXJnZXRPZmZzZXQgKyBtdWx0aXBsaWVySW5kZXhdID0gYXZlcmFnZShsYXN0VmFsdWVzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBwbGF5Q29nbml0aXZlU2VydmljZXNTdHJlYW0oYXVkaW9Db250ZXh0LCBzdHJlYW0sIHsgc2lnbmFsID0ge30gfSA9IHt9KSB7XG4gIGlmICghYXVkaW9Db250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdib3RmcmFtZXdvcmstZGlyZWN0bGluZXNwZWVjaC1zZGs6IGF1ZGlvQ29udGV4dCBtdXN0IGJlIHNwZWNpZmllZC4nKTtcbiAgfSBlbHNlIGlmICghc3RyZWFtKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdib3RmcmFtZXdvcmstZGlyZWN0bGluZXNwZWVjaC1zZGs6IHN0cmVhbSBtdXN0IGJlIHNwZWNpZmllZC4nKTtcbiAgfSBlbHNlIGlmICghc3RyZWFtLmZvcm1hdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYm90ZnJhbWV3b3JrLWRpcmVjdGxpbmVzcGVlY2gtc2RrOiBzdHJlYW0gaXMgbWlzc2luZyBmb3JtYXQuJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHN0cmVhbS5yZWFkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdib3RmcmFtZXdvcmstZGlyZWN0bGluZXNwZWVjaC1zZGs6IHN0cmVhbSBpcyBtaXNzaW5nIHJlYWQoKS4nKTtcbiAgfVxuXG4gIGNvbnN0IHF1ZXVlZEJ1ZmZlclNvdXJjZU5vZGVzID0gW107XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB7IGZvcm1hdCB9ID0gc3RyZWFtO1xuICAgIGNvbnN0IGFib3J0UHJvbWlzZSA9IGFib3J0VG9SZWplY3Qoc2lnbmFsKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KERFRkFVTFRfQlVGRkVSX1NJWkUpO1xuICAgIGNvbnN0IHN0cmVhbVJlYWQgPSBjb2duaXRpdmVTZXJ2aWNlc0FzeW5jRnVuY3Rpb25Ub0VTQXN5bmNGdW5jdGlvbihzdHJlYW0ucmVhZC5iaW5kKHN0cmVhbSkpO1xuXG4gICAgY29uc3QgcmVhZCA9ICgpID0+XG4gICAgICBQcm9taXNlLnJhY2UoW1xuICAgICAgICAvLyBBYm9ydCB3aWxsIGdyYWNlZnVsbHkgZW5kIHRoZSBxdWV1ZS4gV2Ugd2lsbCBjaGVjayBzaWduYWwuYWJvcnRlZCBsYXRlciB0byB0aHJvdyBhYm9ydCBleGNlcHRpb24uXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eS1mdW5jdGlvblxuICAgICAgICBhYm9ydFByb21pc2UuY2F0Y2goKCkgPT4ge30pLFxuICAgICAgICBzdHJlYW1SZWFkKGFycmF5LmJ1ZmZlcikudGhlbihudW1CeXRlcyA9PlxuICAgICAgICAgIG51bUJ5dGVzID09PSBhcnJheS5ieXRlTGVuZ3RoID8gYXJyYXkgOiBudW1CeXRlcyA/IGFycmF5LnNsaWNlKDAsIG51bUJ5dGVzKSA6IHVuZGVmaW5lZFxuICAgICAgICApXG4gICAgICBdKTtcblxuICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhYm9ydGVkJyk7XG4gICAgfVxuXG4gICAgbGV0IG5ld1NhbXBsZXNQZXJTZWMgPSBmb3JtYXQuc2FtcGxlc1BlclNlYztcbiAgICBsZXQgc2FtcGxlUmF0ZU11bHRpcGxpZXIgPSAxO1xuXG4gICAgLy8gU2FmYXJpIHJlcXVpcmVzIGEgbWluaW11bSBzYW1wbGUgcmF0ZSBvZiAyMjEwMCBIei5cbiAgICAvLyBBIG11bHRpcGxpZXIgaXMgY2FsY3VsYXRlZCB0aGUgdGhlIGRhdGEgbWVldHMgdGhlIG1pbmltdW0gc2FtcGxlIHJhdGUuXG4gICAgLy8gQW4gaW50ZWdlci1iYXNlZCBtdWx0aXBsaWVyIHRvIHNpbXBsaWZ5IG91ciB1cHNhbXBsZXIuXG4gICAgLy8gRm9yIHNlY3VyaXR5LCBkYXRhIHdpbGwgb25seSBiZSB1cHNhbXBsZWQgdXAgdG8gOTYwMDAgSHouXG4gICAgd2hpbGUgKG5ld1NhbXBsZXNQZXJTZWMgPCBNSU5fU0FNUExFX1JBVEUgJiYgbmV3U2FtcGxlc1BlclNlYyA8IDk2MDAwKSB7XG4gICAgICBzYW1wbGVSYXRlTXVsdGlwbGllcisrO1xuICAgICAgbmV3U2FtcGxlc1BlclNlYyA9IGZvcm1hdC5zYW1wbGVzUGVyU2VjICogc2FtcGxlUmF0ZU11bHRpcGxpZXI7XG4gICAgfVxuXG4gICAgLy8gVGhlIHRoaXJkIHBhcmFtZXRlciBpcyB0aGUgc2FtcGxlIHNpemUgaW4gYnl0ZXMuXG4gICAgLy8gRm9yIGV4YW1wbGUsIGlmIHRoZSBTcGVlY2ggU0RLIHNlbmRzIFdlYiBDaGF0IDQwOTYgYnl0ZXMgb2YgMTYtYml0IHNhbXBsZXMsIHRoZXJlIHdpbGwgYmUgMjA0OCBzYW1wbGVzIHBlciBjaGFubmVsLlxuICAgIC8vIFRoZSBtdWx0aS1idWZmZXJpbmcgcGxheWVyIGlzIHNldCB1cCB0byBoYW5kbGUgMjA0OCBzYW1wbGVzIHBlciBidWZmZXIuXG4gICAgLy8gSWYgdGhlIG11bHRpcGxpZXIgM3gsIGl0IHdpbGwgaGFuZGxlIDYxNDQgc2FtcGxlcyBwZXIgYnVmZmVyLlxuICAgIGNvbnN0IHBsYXllciA9IGNyZWF0ZU11bHRpQnVmZmVyaW5nUGxheWVyKFxuICAgICAgYXVkaW9Db250ZXh0LFxuICAgICAgeyAuLi5mb3JtYXQsIHNhbXBsZXNQZXJTZWM6IG5ld1NhbXBsZXNQZXJTZWMgfSxcbiAgICAgIChERUZBVUxUX0JVRkZFUl9TSVpFIC8gKGZvcm1hdC5iaXRzUGVyU2FtcGxlIC8gOCkpICogc2FtcGxlUmF0ZU11bHRpcGxpZXJcbiAgICApO1xuXG4gICAgLy8gRm9yIHNlY3VyaXR5LCB0aGUgbWF4aW11bSBudW1iZXIgb2YgY2h1bmtzIGhhbmRsZWQgd2lsbCBiZSAxMDAwLlxuICAgIGZvciAoXG4gICAgICBsZXQgY2h1bmsgPSBhd2FpdCByZWFkKCksIG1heENodW5rcyA9IDA7XG4gICAgICBjaHVuayAmJiBtYXhDaHVua3MgPCAxMDAwICYmICFzaWduYWwuYWJvcnRlZDtcbiAgICAgIGNodW5rID0gYXdhaXQgcmVhZCgpLCBtYXhDaHVua3MrK1xuICAgICkge1xuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBEYXRhIHJlY2VpdmVkIGZyb20gU3BlZWNoIFNESyBpcyBpbnRlcmxlYXZlZDsgMiBjaGFubmVscyAoZS5nLiBBIGFuZCBCKSB3aWxsIGJlIHNlbnQgYXMgXCJBQkFCQUJBQkFCXCJcbiAgICAgIC8vIEFuZCBlYWNoIHNhbXBsZSAoQS9CKSB3aWxsIGJlIGFuIDggdG8gMzItYml0IG51bWJlci5cblxuICAgICAgLy8gQ29udmVydCB0aGUgOCAtIDMyLWJpdCBudW1iZXIgaW50byBhIGZsb2F0aW5nLXBvaW50IG51bWJlciwgYXMgcmVxdWlyZWQgYnkgV2ViIEF1ZGlvIEFQSS5cbiAgICAgIGNvbnN0IGludGVybGVhdmVkQXJyYXkgPSBmb3JtYXRBdWRpb0RhdGFBcnJheUJ1ZmZlclRvRmxvYXRBcnJheShmb3JtYXQsIGNodW5rLmJ1ZmZlcik7XG5cbiAgICAgIC8vIERlaW50ZXJsZWF2ZSBkYXRhIGJhY2sgaW50byB0d28gYXJyYXkgYnVmZmVyLCBlLmcuIFwiQUFBQUFcIiBhbmQgXCJCQkJCQlwiLlxuICAgICAgY29uc3QgbXVsdGlDaGFubmVsQXJyYXkgPSBkZWludGVybGVhdmUoaW50ZXJsZWF2ZWRBcnJheSwgZm9ybWF0KTtcblxuICAgICAgLy8gVXBzYW1wbGUgZGF0YSBpZiBuZWNlc3NhcnkuIElmIHRoZSBtdWx0aXBsaWVyIGlzIDJ4LCBcIkFBQUFBXCIgd2lsbCBiZSB1cHNhbXBsZWQgdG8gXCJBQUFBQUFBQUFBXCIgKHdpdGggYW50aS1hbGlhcykuXG4gICAgICBjb25zdCB1cHNhbXBsZWRNdWx0aUNoYW5uZWxBcnJheSA9IG11bHRpQ2hhbm5lbEFycmF5Lm1hcChhcnJheSA9PlxuICAgICAgICBtdWx0aXBseVNhbXBsZVJhdGUoYXJyYXksIHNhbXBsZVJhdGVNdWx0aXBsaWVyKVxuICAgICAgKTtcblxuICAgICAgLy8gUXVldWUgdG8gdGhlIGJ1ZmZlcmluZyBwbGF5ZXIuXG4gICAgICBwbGF5ZXIucHVzaCh1cHNhbXBsZWRNdWx0aUNoYW5uZWxBcnJheSk7XG4gICAgfVxuXG4gICAgYWJvcnRQcm9taXNlLmNhdGNoKCgpID0+IHBsYXllci5jYW5jZWxBbGwoKSk7XG5cbiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYWJvcnRlZCcpO1xuICAgIH1cblxuICAgIGF3YWl0IFByb21pc2UucmFjZShbYWJvcnRQcm9taXNlLCBwbGF5ZXIuZmx1c2goKV0pO1xuICB9IGZpbmFsbHkge1xuICAgIHF1ZXVlZEJ1ZmZlclNvdXJjZU5vZGVzLmZvckVhY2gobm9kZSA9PiBub2RlLnN0b3AoKSk7XG4gIH1cbn1cbiJdfQ==