{"ast":null,"code":"import _toConsumableArray from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _inherits from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// Multi-device Conversation is a Preview feature.\nimport { ConversationConnectionConfig, ConversationManager, ConversationTranslatorCommandTypes, ConversationTranslatorMessageTypes, ConversationTranslatorRecognizer, InternalParticipants } from \"../../common.speech/Exports\";\nimport { Contracts } from \"../Contracts\";\nimport { Connection, ConversationParticipantsChangedEventArgs, ConversationTranslationEventArgs, Participant, ParticipantChangedReason, ProfanityOption, PropertyCollection, PropertyId } from \"../Exports\";\nexport var Conversation = /*#__PURE__*/function () {\n  function Conversation() {\n    _classCallCheck(this, Conversation);\n  }\n  /**\n   * Create a conversation\n   * @param speechConfig\n   * @param cb\n   * @param err\n   */\n\n\n  _createClass(Conversation, null, [{\n    key: \"createConversationAsync\",\n    value: function createConversationAsync(speechConfig, cb, err) {\n      Contracts.throwIfNullOrUndefined(speechConfig, ConversationConnectionConfig.restErrors.invalidArgs.replace(\"{arg}\", \"config\"));\n      Contracts.throwIfNullOrUndefined(speechConfig.region, ConversationConnectionConfig.restErrors.invalidArgs.replace(\"{arg}\", \"SpeechServiceConnection_Region\"));\n\n      if (!speechConfig.subscriptionKey && !speechConfig.getProperty(PropertyId[PropertyId.SpeechServiceAuthorization_Token])) {\n        Contracts.throwIfNullOrUndefined(speechConfig.subscriptionKey, ConversationConnectionConfig.restErrors.invalidArgs.replace(\"{arg}\", \"SpeechServiceConnection_Key\"));\n      }\n\n      var conversationImpl = new ConversationImpl(speechConfig);\n      conversationImpl.createConversationAsync(function () {\n        if (!!cb) {\n          cb();\n        }\n      }, function (error) {\n        if (!!err) {\n          err(error);\n        }\n      });\n      return conversationImpl;\n    }\n  }]);\n\n  return Conversation;\n}(); // tslint:disable-next-line:max-classes-per-file\n\nexport var ConversationImpl = /*#__PURE__*/function (_Conversation) {\n  _inherits(ConversationImpl, _Conversation);\n\n  var _super = _createSuper(ConversationImpl);\n\n  /**\n   * Create a conversation impl\n   * @param speechConfig\n   */\n  function ConversationImpl(speechConfig) {\n    var _this;\n\n    _classCallCheck(this, ConversationImpl);\n\n    _this = _super.call(this);\n    _this.privIsDisposed = false;\n    _this.privIsConnected = false;\n    _this.privErrors = ConversationConnectionConfig.restErrors;\n    /** websocket callbacks */\n\n    _this.onConnected = function (e) {\n      _this.privIsConnected = true;\n\n      try {\n        if (!!_this.privConversationTranslator.sessionStarted) {\n          _this.privConversationTranslator.sessionStarted(_this.privConversationTranslator, e);\n        }\n      } catch (e) {//\n      }\n    };\n\n    _this.onDisconnected = function (e) {\n      _this.close(false);\n\n      try {\n        if (!!_this.privConversationTranslator.sessionStopped) {\n          _this.privConversationTranslator.sessionStopped(_this.privConversationTranslator, e);\n        }\n      } catch (e) {//\n      }\n    };\n\n    _this.onCanceled = function (r, e) {\n      _this.close(false); // ?\n\n\n      try {\n        if (!!_this.privConversationTranslator.canceled) {\n          _this.privConversationTranslator.canceled(_this.privConversationTranslator, e);\n        }\n      } catch (e) {//\n      }\n    };\n\n    _this.onParticipantUpdateCommandReceived = function (r, e) {\n      var _a, _b;\n\n      try {\n        var updatedParticipant = _this.privParticipants.getParticipant(e.id);\n\n        if (updatedParticipant !== undefined) {\n          switch (e.key) {\n            case ConversationTranslatorCommandTypes.changeNickname:\n              updatedParticipant.displayName = e.value;\n              break;\n\n            case ConversationTranslatorCommandTypes.setUseTTS:\n              updatedParticipant.useTts = e.value;\n              break;\n\n            case ConversationTranslatorCommandTypes.setProfanityFiltering:\n              updatedParticipant.profanity = e.value;\n              break;\n\n            case ConversationTranslatorCommandTypes.setMute:\n              updatedParticipant.isMuted = e.value;\n              break;\n\n            case ConversationTranslatorCommandTypes.setTranslateToLanguages:\n              updatedParticipant.translateToLanguages = e.value;\n              break;\n          }\n\n          _this.privParticipants.addOrUpdateParticipant(updatedParticipant);\n\n          if (!!((_a = _this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.participantsChanged)) {\n            (_b = _this.privConversationTranslator) === null || _b === void 0 ? void 0 : _b.participantsChanged(_this.privConversationTranslator, new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.Updated, [_this.toParticipant(updatedParticipant)], e.sessionId));\n          }\n        }\n      } catch (e) {//\n      }\n    };\n\n    _this.onLockRoomCommandReceived = function (r, e) {// TODO\n    };\n\n    _this.onMuteAllCommandReceived = function (r, e) {\n      var _a, _b;\n\n      try {\n        _this.privParticipants.participants.forEach(function (p) {\n          return p.isMuted = p.isHost ? false : e.isMuted;\n        });\n\n        if (!!((_a = _this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.participantsChanged)) {\n          (_b = _this.privConversationTranslator) === null || _b === void 0 ? void 0 : _b.participantsChanged(_this.privConversationTranslator, new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.Updated, _this.toParticipants(false), e.sessionId));\n        }\n      } catch (e) {//\n      }\n    };\n\n    _this.onParticipantJoinCommandReceived = function (r, e) {\n      var _a, _b;\n\n      try {\n        var newParticipant = _this.privParticipants.addOrUpdateParticipant(e.participant);\n\n        if (newParticipant !== undefined) {\n          if (!!((_a = _this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.participantsChanged)) {\n            (_b = _this.privConversationTranslator) === null || _b === void 0 ? void 0 : _b.participantsChanged(_this.privConversationTranslator, new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.JoinedConversation, [_this.toParticipant(newParticipant)], e.sessionId));\n          }\n        }\n      } catch (e) {//\n      }\n    };\n\n    _this.onParticipantLeaveCommandReceived = function (r, e) {\n      var _a, _b;\n\n      try {\n        var ejectedParticipant = _this.privParticipants.getParticipant(e.participant.id);\n\n        if (ejectedParticipant !== undefined) {\n          // remove the participant from the internal participants list\n          _this.privParticipants.deleteParticipant(e.participant.id);\n\n          if (!!((_a = _this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.participantsChanged)) {\n            // notify subscribers that the participant has left the conversation\n            (_b = _this.privConversationTranslator) === null || _b === void 0 ? void 0 : _b.participantsChanged(_this.privConversationTranslator, new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.LeftConversation, [_this.toParticipant(ejectedParticipant)], e.sessionId));\n          }\n        }\n      } catch (e) {//\n      }\n    };\n\n    _this.onTranslationReceived = function (r, e) {\n      var _a, _b, _c, _d, _e, _f;\n\n      try {\n        switch (e.command) {\n          case ConversationTranslatorMessageTypes.final:\n            if (!!((_a = _this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.transcribed)) {\n              (_b = _this.privConversationTranslator) === null || _b === void 0 ? void 0 : _b.transcribed(_this.privConversationTranslator, new ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));\n            }\n\n            break;\n\n          case ConversationTranslatorMessageTypes.partial:\n            if (!!((_c = _this.privConversationTranslator) === null || _c === void 0 ? void 0 : _c.transcribing)) {\n              (_d = _this.privConversationTranslator) === null || _d === void 0 ? void 0 : _d.transcribing(_this.privConversationTranslator, new ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));\n            }\n\n            break;\n\n          case ConversationTranslatorMessageTypes.instantMessage:\n            if (!!((_e = _this.privConversationTranslator) === null || _e === void 0 ? void 0 : _e.textMessageReceived)) {\n              (_f = _this.privConversationTranslator) === null || _f === void 0 ? void 0 : _f.textMessageReceived(_this.privConversationTranslator, new ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));\n            }\n\n            break;\n        }\n      } catch (e) {//\n      }\n    };\n\n    _this.onParticipantsListReceived = function (r, e) {\n      var _a, _b;\n\n      try {\n        // check if the session token needs to be updated\n        if (e.sessionToken !== undefined && e.sessionToken !== null) {\n          _this.privRoom.token = e.sessionToken;\n        } // save the participants\n\n\n        _this.privParticipants.participants = _toConsumableArray(e.participants); // enable the conversation\n\n        if (_this.privParticipants.me !== undefined) {\n          _this.privIsReady = true;\n        }\n\n        if (!!((_a = _this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.participantsChanged)) {\n          (_b = _this.privConversationTranslator) === null || _b === void 0 ? void 0 : _b.participantsChanged(_this.privConversationTranslator, new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.JoinedConversation, _this.toParticipants(true), e.sessionId));\n        } // if this is the host, update the nickname if needed\n\n\n        if (_this.me.isHost) {\n          var nickname = _this.privConversationTranslator.properties.getProperty(PropertyId.ConversationTranslator_Name);\n\n          if (nickname !== undefined && nickname.length > 0 && nickname !== _this.me.displayName) {\n            // issue a change nickname request\n            _this.changeNicknameAsync(nickname);\n          }\n        }\n      } catch (e) {//\n      }\n    };\n\n    _this.onConversationExpiration = function (r, e) {\n      var _a, _b;\n\n      try {\n        if (!!((_a = _this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.conversationExpiration)) {\n          (_b = _this.privConversationTranslator) === null || _b === void 0 ? void 0 : _b.conversationExpiration(_this.privConversationTranslator, e);\n        }\n      } catch (e) {//\n      }\n    };\n\n    _this.privProperties = new PropertyCollection();\n    _this.privManager = new ConversationManager(); // check the speech language\n\n    var language = speechConfig.getProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage]);\n\n    if (!language) {\n      speechConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage], ConversationConnectionConfig.defaultLanguageCode);\n    }\n\n    _this.privLanguage = speechConfig.getProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage]); // check the target language(s)\n\n    if (speechConfig.targetLanguages.length === 0) {\n      speechConfig.addTargetLanguage(_this.privLanguage);\n    } // check the profanity setting: speech and conversationTranslator should be in sync\n\n\n    var profanity = speechConfig.getProperty(PropertyId[PropertyId.SpeechServiceResponse_ProfanityOption]);\n\n    if (!profanity) {\n      speechConfig.setProfanity(ProfanityOption.Masked);\n    } // check the nickname: it should pass this regex: ^\\w+([\\s-][\\w\\(\\)]+)*$\"\n    // TODO: specify the regex required. Nicknames must be unique or get the duplicate nickname error\n    // TODO: check what the max length is and if a truncation is required or if the service handles it without an error\n\n\n    var hostNickname = speechConfig.getProperty(PropertyId[PropertyId.ConversationTranslator_Name]);\n\n    if (hostNickname === undefined || hostNickname === null || hostNickname.length <= 1 || hostNickname.length > 50) {\n      hostNickname = \"Host\";\n    }\n\n    speechConfig.setProperty(PropertyId[PropertyId.ConversationTranslator_Name], hostNickname); // save the speech config for future usage\n\n    _this.privConfig = speechConfig; // save the config properties\n\n    var configImpl = speechConfig;\n    Contracts.throwIfNull(configImpl, \"speechConfig\");\n    _this.privProperties = configImpl.properties.clone();\n    _this.privIsConnected = false;\n    _this.privParticipants = new InternalParticipants();\n    _this.privIsReady = false;\n    _this.privTextMessageMaxLength = 1000;\n    return _this;\n  }\n\n  _createClass(ConversationImpl, [{\n    key: \"conversationTranslator\",\n    set: function set(value) {\n      this.privConversationTranslator = value;\n    } // get the internal data about a conversation\n\n  }, {\n    key: \"room\",\n    get: function get() {\n      return this.privRoom;\n    } // get the wrapper for connecting to the websockets\n\n  }, {\n    key: \"connection\",\n    get: function get() {\n      return this.privConversationRecognizer; // this.privConnection;\n    } // get / set the speech auth token\n\n  }, {\n    key: \"authorizationToken\",\n    get: function get() {\n      return this.privToken;\n    },\n    set: function set(value) {\n      Contracts.throwIfNullOrWhitespace(value, \"authorizationToken\");\n      this.privToken = value;\n    } // get the config\n\n  }, {\n    key: \"config\",\n    get: function get() {\n      return this.privConfig;\n    } // get the conversation Id\n\n  }, {\n    key: \"conversationId\",\n    get: function get() {\n      return this.privRoom ? this.privRoom.roomId : \"\";\n    } // get the properties\n\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return this.privProperties;\n    } // get the speech language\n\n  }, {\n    key: \"speechRecognitionLanguage\",\n    get: function get() {\n      return this.privLanguage;\n    }\n  }, {\n    key: \"isMutedByHost\",\n    get: function get() {\n      var _a, _b;\n\n      return ((_a = this.privParticipants.me) === null || _a === void 0 ? void 0 : _a.isHost) ? false : (_b = this.privParticipants.me) === null || _b === void 0 ? void 0 : _b.isMuted;\n    }\n  }, {\n    key: \"isConnected\",\n    get: function get() {\n      return this.privIsConnected && this.privIsReady;\n    }\n  }, {\n    key: \"participants\",\n    get: function get() {\n      return this.toParticipants(true);\n    }\n  }, {\n    key: \"me\",\n    get: function get() {\n      return this.toParticipant(this.privParticipants.me);\n    }\n  }, {\n    key: \"host\",\n    get: function get() {\n      return this.toParticipant(this.privParticipants.host);\n    }\n    /**\n     * Create a new conversation as Host\n     * @param cb\n     * @param err\n     */\n\n  }, {\n    key: \"createConversationAsync\",\n    value: function createConversationAsync(cb, err) {\n      var _this2 = this;\n\n      try {\n        if (!!this.privConversationRecognizer) {\n          this.handleError(new Error(this.privErrors.permissionDeniedStart), err);\n        }\n\n        this.privManager.createOrJoin(this.privProperties, undefined, function (room) {\n          if (!room) {\n            _this2.handleError(new Error(_this2.privErrors.permissionDeniedConnect), err);\n          }\n\n          _this2.privRoom = room;\n\n          _this2.handleCallback(cb, err);\n        }, function (error) {\n          _this2.handleError(error, err);\n        });\n      } catch (error) {\n        this.handleError(error, err);\n      }\n    }\n    /**\n     * Starts a new conversation as host.\n     * @param cb\n     * @param err\n     */\n\n  }, {\n    key: \"startConversationAsync\",\n    value: function startConversationAsync(cb, err) {\n      var _this3 = this;\n\n      try {\n        // check if there is already a recognizer\n        if (!!this.privConversationRecognizer) {\n          this.handleError(new Error(this.privErrors.permissionDeniedStart), err);\n        } // check if there is conversation data available\n\n\n        Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedConnect); // connect to the conversation websocket\n\n        this.privParticipants.meId = this.privRoom.participantId;\n        this.privConversationRecognizer = new ConversationTranslatorRecognizer(this.privConfig);\n        this.privConversationRecognizer.conversation = this.privRoom;\n        this.privConversationRecognizerConnection = Connection.fromRecognizer(this.privConversationRecognizer);\n        this.privConversationRecognizerConnection.connected = this.onConnected;\n        this.privConversationRecognizerConnection.disconnected = this.onDisconnected;\n        this.privConversationRecognizer.canceled = this.onCanceled;\n        this.privConversationRecognizer.participantUpdateCommandReceived = this.onParticipantUpdateCommandReceived;\n        this.privConversationRecognizer.lockRoomCommandReceived = this.onLockRoomCommandReceived;\n        this.privConversationRecognizer.muteAllCommandReceived = this.onMuteAllCommandReceived;\n        this.privConversationRecognizer.participantJoinCommandReceived = this.onParticipantJoinCommandReceived;\n        this.privConversationRecognizer.participantLeaveCommandReceived = this.onParticipantLeaveCommandReceived;\n        this.privConversationRecognizer.translationReceived = this.onTranslationReceived;\n        this.privConversationRecognizer.participantsListReceived = this.onParticipantsListReceived;\n        this.privConversationRecognizer.conversationExpiration = this.onConversationExpiration;\n        this.privConversationRecognizer.connect(this.privRoom.token, function () {\n          _this3.handleCallback(cb, err);\n        }, function (error) {\n          _this3.handleError(error, err);\n        });\n      } catch (error) {\n        this.handleError(error, err);\n      }\n    }\n    /**\n     * Join a conversation as a participant.\n     * @param conversation\n     * @param nickname\n     * @param lang\n     * @param cb\n     * @param err\n     */\n\n  }, {\n    key: \"joinConversationAsync\",\n    value: function joinConversationAsync(conversationId, nickname, lang, cb, err) {\n      var _this4 = this;\n\n      try {\n        // TODO\n        // if (!!this.privConversationRecognizer) {\n        //     throw new Error(this.privErrors.permissionDeniedStart);\n        // }\n        Contracts.throwIfNullOrWhitespace(conversationId, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversationId\"));\n        Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\n        Contracts.throwIfNullOrWhitespace(lang, this.privErrors.invalidArgs.replace(\"{arg}\", \"language\")); // join the conversation\n\n        this.privManager.createOrJoin(this.privProperties, conversationId, function (room) {\n          Contracts.throwIfNullOrUndefined(room, _this4.privErrors.permissionDeniedConnect);\n          _this4.privRoom = room;\n          _this4.privConfig.authorizationToken = room.cognitiveSpeechAuthToken; // join callback\n\n          if (!!cb) {\n            cb(room.cognitiveSpeechAuthToken);\n          }\n        }, function (error) {\n          _this4.handleError(error, err);\n        });\n      } catch (error) {\n        this.handleError(error, err);\n      }\n    }\n    /**\n     * Deletes a conversation\n     * @param cb\n     * @param err\n     */\n\n  }, {\n    key: \"deleteConversationAsync\",\n    value: function deleteConversationAsync(cb, err) {\n      var _this5 = this;\n\n      try {\n        Contracts.throwIfNullOrUndefined(this.privProperties, this.privErrors.permissionDeniedConnect);\n        Contracts.throwIfNullOrWhitespace(this.privRoom.token, this.privErrors.permissionDeniedConnect);\n        this.privManager.leave(this.privProperties, this.privRoom.token, function () {\n          _this5.handleCallback(cb, err);\n        }, function (error) {\n          _this5.handleError(error, err);\n        });\n        this.dispose();\n      } catch (error) {\n        this.handleError(error, err);\n      }\n    }\n    /**\n     * Issues a request to close the client websockets\n     * @param cb\n     * @param err\n     */\n\n  }, {\n    key: \"endConversationAsync\",\n    value: function endConversationAsync(cb, err) {\n      try {\n        this.close(true);\n        this.handleCallback(cb, err);\n      } catch (error) {\n        this.handleError(error, err);\n      }\n    }\n    /**\n     * Issues a request to lock the conversation\n     * @param cb\n     * @param err\n     */\n\n  }, {\n    key: \"lockConversationAsync\",\n    value: function lockConversationAsync(cb, err) {\n      var _this6 = this;\n\n      var _a;\n\n      try {\n        Contracts.throwIfDisposed(this.privIsDisposed);\n        Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n        Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n\n        if (!this.canSendAsHost) {\n          this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"lock\")), err);\n        }\n\n        (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.sendLockRequest(true, function () {\n          _this6.handleCallback(cb, err);\n        }, function (error) {\n          _this6.handleError(error, err);\n        });\n      } catch (error) {\n        this.handleError(error, err);\n      }\n    }\n    /**\n     * Issues a request to mute the conversation\n     * @param cb\n     * @param err\n     */\n\n  }, {\n    key: \"muteAllParticipantsAsync\",\n    value: function muteAllParticipantsAsync(cb, err) {\n      var _this7 = this;\n\n      var _a;\n\n      try {\n        Contracts.throwIfDisposed(this.privIsDisposed);\n        Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n        Contracts.throwIfNullOrUndefined(this.privConversationRecognizer, this.privErrors.permissionDeniedSend);\n        Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend); // check the user's permissions\n\n        if (!this.canSendAsHost) {\n          this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"mute\")), err);\n        }\n\n        (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.sendMuteAllRequest(true, function () {\n          _this7.handleCallback(cb, err);\n        }, function (error) {\n          _this7.handleError(error, err);\n        });\n      } catch (error) {\n        this.handleError(error, err);\n      }\n    }\n    /**\n     * Issues a request to mute a participant in the conversation\n     * @param userId\n     * @param cb\n     * @param err\n     */\n\n  }, {\n    key: \"muteParticipantAsync\",\n    value: function muteParticipantAsync(userId, cb, err) {\n      var _this8 = this;\n\n      var _a;\n\n      try {\n        Contracts.throwIfDisposed(this.privIsDisposed);\n        Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n        Contracts.throwIfNullOrWhitespace(userId, this.privErrors.invalidArgs.replace(\"{arg}\", \"userId\"));\n        Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend); // check the connection is open (host + participant can perform the mute command)\n\n        if (!this.canSend) {\n          this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n        } // if not host, check the participant is not muting another participant\n\n\n        if (!this.me.isHost && this.me.id !== userId) {\n          this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace(\"{command}\", \"mute\")), err);\n        } // check the user exists\n\n\n        var exists = this.privParticipants.getParticipantIndex(userId);\n\n        if (exists === -1) {\n          this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);\n        }\n\n        (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.sendMuteRequest(userId, true, function () {\n          _this8.handleCallback(cb, err);\n        }, function (error) {\n          _this8.handleError(error, err);\n        });\n      } catch (error) {\n        this.handleError(error, err);\n      }\n    }\n    /**\n     * Issues a request to remove a participant from the conversation\n     * @param userId\n     * @param cb\n     * @param err\n     */\n\n  }, {\n    key: \"removeParticipantAsync\",\n    value: function removeParticipantAsync(userId, cb, err) {\n      var _this9 = this;\n\n      var _a;\n\n      try {\n        Contracts.throwIfDisposed(this.privIsDisposed);\n        Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n        Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n\n        if (!this.canSendAsHost) {\n          this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace(\"{command}\", \"remove\")), err);\n        }\n\n        var participantId = \"\";\n\n        if (typeof userId === \"string\") {\n          participantId = userId;\n        } else if (userId.hasOwnProperty(\"id\")) {\n          var participant = userId;\n          participantId = participant.id;\n        } else if (userId.hasOwnProperty(\"userId\")) {\n          var user = userId;\n          participantId = user.userId;\n        }\n\n        Contracts.throwIfNullOrWhitespace(participantId, this.privErrors.invalidArgs.replace(\"{arg}\", \"userId\")); // check the participant exists\n\n        var index = this.participants.findIndex(function (p) {\n          return p.id === participantId;\n        });\n\n        if (index === -1) {\n          this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);\n        }\n\n        (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.sendEjectRequest(participantId, function () {\n          _this9.handleCallback(cb, err);\n        }, function (error) {\n          _this9.handleError(error, err);\n        });\n      } catch (error) {\n        this.handleError(error, err);\n      }\n    }\n    /**\n     * Issues a request to unlock the conversation\n     * @param cb\n     * @param err\n     */\n\n  }, {\n    key: \"unlockConversationAsync\",\n    value: function unlockConversationAsync(cb, err) {\n      var _this10 = this;\n\n      var _a;\n\n      try {\n        Contracts.throwIfDisposed(this.privIsDisposed);\n        Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n        Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n\n        if (!this.canSendAsHost) {\n          this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"unlock\")), err);\n        }\n\n        (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.sendLockRequest(false, function () {\n          _this10.handleCallback(cb, err);\n        }, function (error) {\n          _this10.handleError(error, err);\n        });\n      } catch (error) {\n        this.handleError(error, err);\n      }\n    }\n    /**\n     * Issues a request to unmute all participants in the conversation\n     * @param cb\n     * @param err\n     */\n\n  }, {\n    key: \"unmuteAllParticipantsAsync\",\n    value: function unmuteAllParticipantsAsync(cb, err) {\n      var _this11 = this;\n\n      var _a;\n\n      try {\n        Contracts.throwIfDisposed(this.privIsDisposed);\n        Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n        Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n\n        if (!this.canSendAsHost) {\n          this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"unmute all\")), err);\n        }\n\n        (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.sendMuteAllRequest(false, function () {\n          _this11.handleCallback(cb, err);\n        }, function (error) {\n          _this11.handleError(error, err);\n        });\n      } catch (error) {\n        this.handleError(error, err);\n      }\n    }\n    /**\n     * Issues a request to unmute a participant in the conversation\n     * @param userId\n     * @param cb\n     * @param err\n     */\n\n  }, {\n    key: \"unmuteParticipantAsync\",\n    value: function unmuteParticipantAsync(userId, cb, err) {\n      var _this12 = this;\n\n      var _a;\n\n      try {\n        Contracts.throwIfDisposed(this.privIsDisposed);\n        Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n        Contracts.throwIfNullOrWhitespace(userId, this.privErrors.invalidArgs.replace(\"{arg}\", \"userId\"));\n        Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend); // check the connection is open (host + participant can perform the mute command)\n\n        if (!this.canSend) {\n          this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n        } // if not host, check the participant is not muting another participant\n\n\n        if (!this.me.isHost && this.me.id !== userId) {\n          this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace(\"{command}\", \"mute\")), err);\n        } // check the user exists\n\n\n        var exists = this.privParticipants.getParticipantIndex(userId);\n\n        if (exists === -1) {\n          this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);\n        }\n\n        (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.sendMuteRequest(userId, false, function () {\n          _this12.handleCallback(cb, err);\n        }, function (error) {\n          _this12.handleError(error, err);\n        });\n      } catch (error) {\n        this.handleError(error, err);\n      }\n    }\n    /**\n     * Send a text message\n     * @param message\n     * @param cb\n     * @param err\n     */\n\n  }, {\n    key: \"sendTextMessageAsync\",\n    value: function sendTextMessageAsync(message, cb, err) {\n      var _this13 = this;\n\n      var _a;\n\n      try {\n        Contracts.throwIfDisposed(this.privIsDisposed);\n        Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n        Contracts.throwIfNullOrWhitespace(message, this.privErrors.invalidArgs.replace(\"{arg}\", \"message\"));\n        Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n\n        if (!this.canSend) {\n          this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n        } // TODO: is a max length check required?\n\n\n        if (message.length > this.privTextMessageMaxLength) {\n          this.handleError(new Error(this.privErrors.invalidArgs.replace(\"{arg}\", \"message length\")), err);\n        }\n\n        (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.sendMessageRequest(message, function () {\n          _this13.handleCallback(cb, err);\n        }, function (error) {\n          _this13.handleError(error, err);\n        });\n      } catch (error) {\n        this.handleError(error, err);\n      }\n    }\n    /**\n     * Change nickname\n     * @param message\n     * @param cb\n     * @param err\n     */\n\n  }, {\n    key: \"changeNicknameAsync\",\n    value: function changeNicknameAsync(nickname, cb, err) {\n      var _this14 = this;\n\n      var _a;\n\n      try {\n        Contracts.throwIfDisposed(this.privIsDisposed);\n        Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n        Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\n        Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n\n        if (!this.canSend) {\n          this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n        }\n\n        (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.sendChangeNicknameRequest(nickname, function () {\n          _this14.handleCallback(cb, err);\n        }, function (error) {\n          _this14.handleError(error, err);\n        });\n      } catch (error) {\n        this.handleError(error, err);\n      }\n    }\n  }, {\n    key: \"isDisposed\",\n    value: function isDisposed() {\n      return this.privIsDisposed;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose(reason) {\n      var _a;\n\n      if (this.isDisposed) {\n        return;\n      }\n\n      this.privIsDisposed = true;\n      (_a = this.config) === null || _a === void 0 ? void 0 : _a.close();\n\n      if (this.privConversationRecognizerConnection) {\n        this.privConversationRecognizerConnection.closeConnection();\n        this.privConversationRecognizerConnection.close();\n        this.privConversationRecognizerConnection = undefined;\n      }\n\n      this.privConfig = undefined;\n      this.privLanguage = undefined;\n      this.privProperties = undefined;\n      this.privRoom = undefined;\n      this.privToken = undefined;\n      this.privManager = undefined;\n      this.privConversationRecognizer = undefined;\n      this.privIsConnected = false;\n      this.privIsReady = false;\n      this.privParticipants = undefined;\n      this.privRoom = undefined;\n    }\n  }, {\n    key: \"close\",\n    value: function close(dispose) {\n      var _a, _b, _c;\n\n      try {\n        this.privIsConnected = false;\n        (_a = this.privConversationRecognizerConnection) === null || _a === void 0 ? void 0 : _a.closeConnection();\n        (_b = this.privConversationRecognizerConnection) === null || _b === void 0 ? void 0 : _b.close();\n        this.privConversationRecognizer.close();\n        this.privConversationRecognizerConnection = undefined;\n        this.privConversationRecognizer = undefined;\n        (_c = this.privConversationTranslator) === null || _c === void 0 ? void 0 : _c.dispose();\n      } catch (e) {// ignore error\n      }\n\n      if (dispose) {\n        this.dispose();\n      }\n    }\n    /** Helpers */\n\n  }, {\n    key: \"canSend\",\n    get: function get() {\n      var _a;\n\n      return this.privIsConnected && !((_a = this.privParticipants.me) === null || _a === void 0 ? void 0 : _a.isMuted);\n    }\n  }, {\n    key: \"canSendAsHost\",\n    get: function get() {\n      var _a;\n\n      return this.privIsConnected && ((_a = this.privParticipants.me) === null || _a === void 0 ? void 0 : _a.isHost);\n    }\n  }, {\n    key: \"handleCallback\",\n    value: function handleCallback(cb, err) {\n      if (!!cb) {\n        try {\n          cb();\n        } catch (e) {\n          if (!!err) {\n            err(e);\n          }\n        }\n\n        cb = undefined;\n      }\n    }\n  }, {\n    key: \"handleError\",\n    value: function handleError(error, err) {\n      if (!!err) {\n        if (error instanceof Error) {\n          var typedError = error;\n          err(typedError.name + \": \" + typedError.message);\n        } else {\n          err(error);\n        }\n      }\n    }\n    /** Participant Helpers */\n\n  }, {\n    key: \"toParticipants\",\n    value: function toParticipants(includeHost) {\n      var _this15 = this;\n\n      var participants = this.privParticipants.participants.map(function (p) {\n        return _this15.toParticipant(p);\n      });\n\n      if (!includeHost) {\n        return participants.filter(function (p) {\n          return p.isHost === false;\n        });\n      } else {\n        return participants;\n      }\n    }\n  }, {\n    key: \"toParticipant\",\n    value: function toParticipant(p) {\n      return new Participant(p.id, p.avatar, p.displayName, p.isHost, p.isMuted, p.isUsingTts, p.preferredLanguage);\n    }\n  }]);\n\n  return ConversationImpl;\n}(Conversation);","map":{"version":3,"sources":["src/sdk/Transcription/Conversation.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n// Multi-device Conversation is a Preview feature.\r\n\r\nimport {\r\n    ConversationConnectionConfig,\r\n    ConversationManager,\r\n    ConversationReceivedTranslationEventArgs,\r\n    ConversationTranslatorCommandTypes,\r\n    ConversationTranslatorMessageTypes,\r\n    ConversationTranslatorRecognizer,\r\n    IInternalConversation,\r\n    IInternalParticipant,\r\n    InternalParticipants,\r\n    LockRoomEventArgs,\r\n    MuteAllEventArgs,\r\n    ParticipantAttributeEventArgs,\r\n    ParticipantEventArgs,\r\n    ParticipantsListEventArgs\r\n} from \"../../common.speech/Exports\";\r\nimport { IDisposable, IErrorMessages } from \"../../common/Exports\";\r\nimport { Contracts } from \"../Contracts\";\r\nimport {\r\n    Connection,\r\n    ConnectionEventArgs,\r\n    ConversationExpirationEventArgs,\r\n    ConversationParticipantsChangedEventArgs,\r\n    ConversationTranslationCanceledEventArgs,\r\n    ConversationTranslationEventArgs,\r\n    ConversationTranslator,\r\n    Participant,\r\n    ParticipantChangedReason,\r\n    ProfanityOption,\r\n    PropertyCollection,\r\n    PropertyId,\r\n    SpeechTranslationConfig\r\n} from \"../Exports\";\r\nimport { SpeechTranslationConfigImpl } from \"../SpeechTranslationConfig\";\r\nimport { Callback, IConversation } from \"./IConversation\";\r\nimport { IParticipant, IUser } from \"./IParticipant\";\r\n\r\nexport abstract class Conversation implements IConversation {\r\n\r\n    public abstract get authorizationToken(): string;\r\n    public abstract set authorizationToken(value: string);\r\n\r\n    public abstract get config(): SpeechTranslationConfig;\r\n\r\n    public abstract get conversationId(): string;\r\n    public abstract get properties(): PropertyCollection;\r\n    public abstract get speechRecognitionLanguage(): string;\r\n\r\n    protected constructor() { }\r\n\r\n    /**\r\n     * Create a conversation\r\n     * @param speechConfig\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public static createConversationAsync(speechConfig: SpeechTranslationConfig, cb?: Callback, err?: Callback): Conversation {\r\n        Contracts.throwIfNullOrUndefined(speechConfig, ConversationConnectionConfig.restErrors.invalidArgs.replace(\"{arg}\", \"config\"));\r\n        Contracts.throwIfNullOrUndefined(speechConfig.region, ConversationConnectionConfig.restErrors.invalidArgs.replace(\"{arg}\", \"SpeechServiceConnection_Region\"));\r\n        if (!speechConfig.subscriptionKey && !speechConfig.getProperty(PropertyId[PropertyId.SpeechServiceAuthorization_Token])) {\r\n            Contracts.throwIfNullOrUndefined(speechConfig.subscriptionKey, ConversationConnectionConfig.restErrors.invalidArgs.replace(\"{arg}\", \"SpeechServiceConnection_Key\"));\r\n        }\r\n        const conversationImpl: ConversationImpl = new ConversationImpl(speechConfig);\r\n\r\n        conversationImpl.createConversationAsync(\r\n            (() => {\r\n                if (!!cb) {\r\n                    cb();\r\n                }\r\n            }),\r\n            (error: any) => {\r\n                if (!!err) {\r\n                    err(error);\r\n                }\r\n            });\r\n\r\n        return conversationImpl;\r\n    }\r\n\r\n    /** Start a conversation. */\r\n    public abstract startConversationAsync(cb?: Callback, err?: Callback): void;\r\n\r\n    /** Delete a conversation. After this no one will be able to join the conversation. */\r\n    public abstract deleteConversationAsync(cb?: Callback, err?: Callback): void;\r\n\r\n    /** End a conversation. */\r\n    public abstract endConversationAsync(cb?: Callback, err?: Callback): void;\r\n\r\n    /** Lock a conversation. This will prevent new participants from joining. */\r\n    public abstract lockConversationAsync(cb?: Callback, err?: Callback): void;\r\n\r\n    /**\r\n     * Mute all other participants in the conversation. After this no other participants will\r\n     * have their speech recognitions broadcast, nor be able to send text messages.\r\n     */\r\n    public abstract muteAllParticipantsAsync(cb?: Callback, err?: Callback): void;\r\n\r\n    /**\r\n     * Mute a participant.\r\n     * @param userId A user identifier\r\n     */\r\n    public abstract muteParticipantAsync(userId: string, cb?: Callback, err?: Callback): void;\r\n\r\n    /**\r\n     * Remove a participant from a conversation using the user id, Participant or User object\r\n     * @param userId A user identifier\r\n     */\r\n    public abstract removeParticipantAsync(userId: string | IParticipant | IUser, cb?: Callback, err?: Callback): void;\r\n\r\n    /** Unlocks a conversation. */\r\n    public abstract unlockConversationAsync(cb?: Callback, err?: Callback): void;\r\n\r\n    /** Unmute all other participants in the conversation. */\r\n    public abstract unmuteAllParticipantsAsync(cb?: Callback, err?: Callback): void;\r\n\r\n    /**\r\n     * Unmute a participant.\r\n     * @param userId A user identifier\r\n     */\r\n    public abstract unmuteParticipantAsync(userId: string, cb?: Callback, err?: Callback): void;\r\n}\r\n\r\n// tslint:disable-next-line:max-classes-per-file\r\nexport class ConversationImpl extends Conversation implements IDisposable {\r\n\r\n    private privConfig: SpeechTranslationConfig;\r\n    private privProperties: PropertyCollection;\r\n    private privLanguage: string;\r\n    private privToken: string;\r\n    private privIsDisposed: boolean = false;\r\n    private privRoom: IInternalConversation;\r\n    private privManager: ConversationManager;\r\n    private privConversationRecognizer: ConversationTranslatorRecognizer;\r\n    private privConversationRecognizerConnection: Connection;\r\n    private privIsConnected: boolean = false;\r\n    private privParticipants: InternalParticipants;\r\n    private privIsReady: boolean;\r\n    private privConversationTranslator: ConversationTranslator;\r\n    private privErrors: IErrorMessages = ConversationConnectionConfig.restErrors;\r\n    private readonly privTextMessageMaxLength: number;\r\n\r\n    public set conversationTranslator(value: ConversationTranslator) {\r\n        this.privConversationTranslator = value;\r\n    }\r\n\r\n    // get the internal data about a conversation\r\n    public get room(): IInternalConversation {\r\n        return this.privRoom;\r\n    }\r\n\r\n    // get the wrapper for connecting to the websockets\r\n    public get connection(): ConversationTranslatorRecognizer {\r\n        return this.privConversationRecognizer; // this.privConnection;\r\n    }\r\n\r\n    // get / set the speech auth token\r\n    public get authorizationToken(): string {\r\n        return this.privToken;\r\n    }\r\n    public set authorizationToken(value: string) {\r\n        Contracts.throwIfNullOrWhitespace(value, \"authorizationToken\");\r\n        this.privToken = value;\r\n    }\r\n\r\n    // get the config\r\n    public get config(): SpeechTranslationConfig {\r\n        return this.privConfig;\r\n    }\r\n    // get the conversation Id\r\n    public get conversationId(): string {\r\n        return this.privRoom ? this.privRoom.roomId : \"\";\r\n    }\r\n\r\n    // get the properties\r\n    public get properties(): PropertyCollection {\r\n        return this.privProperties;\r\n    }\r\n\r\n    // get the speech language\r\n    public get speechRecognitionLanguage(): string {\r\n        return this.privLanguage;\r\n    }\r\n\r\n    public get isMutedByHost(): boolean {\r\n        return this.privParticipants.me?.isHost ? false : this.privParticipants.me?.isMuted;\r\n    }\r\n\r\n    public get isConnected(): boolean {\r\n        return this.privIsConnected && this.privIsReady;\r\n    }\r\n\r\n    public get participants(): Participant[] {\r\n        return this.toParticipants(true);\r\n    }\r\n\r\n    public get me(): Participant {\r\n        return this.toParticipant(this.privParticipants.me);\r\n    }\r\n\r\n    public get host(): Participant {\r\n        return this.toParticipant(this.privParticipants.host);\r\n    }\r\n\r\n    /**\r\n     * Create a conversation impl\r\n     * @param speechConfig\r\n     */\r\n    public constructor(speechConfig: SpeechTranslationConfig) {\r\n        super();\r\n        this.privProperties = new PropertyCollection();\r\n        this.privManager = new ConversationManager();\r\n\r\n        // check the speech language\r\n        const language: string = speechConfig.getProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage]);\r\n        if (!language) {\r\n            speechConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage], ConversationConnectionConfig.defaultLanguageCode);\r\n        }\r\n        this.privLanguage = speechConfig.getProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage]);\r\n\r\n        // check the target language(s)\r\n        if (speechConfig.targetLanguages.length === 0) {\r\n            speechConfig.addTargetLanguage(this.privLanguage);\r\n        }\r\n\r\n        // check the profanity setting: speech and conversationTranslator should be in sync\r\n        const profanity: string = speechConfig.getProperty(PropertyId[PropertyId.SpeechServiceResponse_ProfanityOption]);\r\n        if (!profanity) {\r\n            speechConfig.setProfanity(ProfanityOption.Masked);\r\n        }\r\n\r\n        // check the nickname: it should pass this regex: ^\\w+([\\s-][\\w\\(\\)]+)*$\"\r\n        // TODO: specify the regex required. Nicknames must be unique or get the duplicate nickname error\r\n        // TODO: check what the max length is and if a truncation is required or if the service handles it without an error\r\n        let hostNickname: string = speechConfig.getProperty(PropertyId[PropertyId.ConversationTranslator_Name]);\r\n        if (hostNickname === undefined || hostNickname === null || hostNickname.length <= 1 || hostNickname.length > 50) {\r\n            hostNickname = \"Host\";\r\n        }\r\n        speechConfig.setProperty(PropertyId[PropertyId.ConversationTranslator_Name], hostNickname);\r\n\r\n        // save the speech config for future usage\r\n        this.privConfig = speechConfig;\r\n\r\n        // save the config properties\r\n        const configImpl = speechConfig as SpeechTranslationConfigImpl;\r\n        Contracts.throwIfNull(configImpl, \"speechConfig\");\r\n        this.privProperties = configImpl.properties.clone();\r\n        this.privIsConnected = false;\r\n        this.privParticipants = new InternalParticipants();\r\n        this.privIsReady = false;\r\n        this.privTextMessageMaxLength = 1000;\r\n    }\r\n\r\n    /**\r\n     * Create a new conversation as Host\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public createConversationAsync(cb?: Callback, err?: Callback): void {\r\n        try {\r\n            if (!!this.privConversationRecognizer) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedStart), err);\r\n            }\r\n            this.privManager.createOrJoin(this.privProperties, undefined,\r\n                ((room: IInternalConversation) => {\r\n                    if (!room) {\r\n                        this.handleError(new Error(this.privErrors.permissionDeniedConnect), err);\r\n                    }\r\n                    this.privRoom = room;\r\n                    this.handleCallback(cb, err);\r\n                }),\r\n                ((error: any) => {\r\n                    this.handleError(error, err);\r\n                }));\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts a new conversation as host.\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public startConversationAsync(cb?: Callback, err?: Callback): void {\r\n        try {\r\n            // check if there is already a recognizer\r\n            if (!!this.privConversationRecognizer) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedStart), err);\r\n            }\r\n            // check if there is conversation data available\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedConnect);\r\n            // connect to the conversation websocket\r\n            this.privParticipants.meId = this.privRoom.participantId;\r\n            this.privConversationRecognizer = new ConversationTranslatorRecognizer(this.privConfig);\r\n            this.privConversationRecognizer.conversation = this.privRoom;\r\n            this.privConversationRecognizerConnection = Connection.fromRecognizer(this.privConversationRecognizer);\r\n            this.privConversationRecognizerConnection.connected = this.onConnected;\r\n            this.privConversationRecognizerConnection.disconnected = this.onDisconnected;\r\n            this.privConversationRecognizer.canceled = this.onCanceled;\r\n            this.privConversationRecognizer.participantUpdateCommandReceived = this.onParticipantUpdateCommandReceived;\r\n            this.privConversationRecognizer.lockRoomCommandReceived = this.onLockRoomCommandReceived;\r\n            this.privConversationRecognizer.muteAllCommandReceived = this.onMuteAllCommandReceived;\r\n            this.privConversationRecognizer.participantJoinCommandReceived = this.onParticipantJoinCommandReceived;\r\n            this.privConversationRecognizer.participantLeaveCommandReceived = this.onParticipantLeaveCommandReceived;\r\n            this.privConversationRecognizer.translationReceived = this.onTranslationReceived;\r\n            this.privConversationRecognizer.participantsListReceived = this.onParticipantsListReceived;\r\n            this.privConversationRecognizer.conversationExpiration = this.onConversationExpiration;\r\n            this.privConversationRecognizer.connect(this.privRoom.token,\r\n                (() => {\r\n                    this.handleCallback(cb, err);\r\n                }),\r\n                ((error: any) => {\r\n                    this.handleError(error, err);\r\n                }));\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Join a conversation as a participant.\r\n     * @param conversation\r\n     * @param nickname\r\n     * @param lang\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public joinConversationAsync(conversationId: string, nickname: string, lang: string, cb?: Callback, err?: Callback): void {\r\n        try {\r\n            // TODO\r\n            // if (!!this.privConversationRecognizer) {\r\n            //     throw new Error(this.privErrors.permissionDeniedStart);\r\n            // }\r\n            Contracts.throwIfNullOrWhitespace(conversationId, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversationId\"));\r\n            Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\r\n            Contracts.throwIfNullOrWhitespace(lang, this.privErrors.invalidArgs.replace(\"{arg}\", \"language\"));\r\n            // join the conversation\r\n            this.privManager.createOrJoin(this.privProperties, conversationId,\r\n                ((room: IInternalConversation) => {\r\n                    Contracts.throwIfNullOrUndefined(room, this.privErrors.permissionDeniedConnect);\r\n                    this.privRoom = room;\r\n                    this.privConfig.authorizationToken = room.cognitiveSpeechAuthToken;\r\n                    // join callback\r\n                    if (!!cb) {\r\n                        cb(room.cognitiveSpeechAuthToken);\r\n                    }\r\n                }),\r\n                ((error: any) => {\r\n                    this.handleError(error, err);\r\n                }));\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deletes a conversation\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public deleteConversationAsync(cb?: Callback, err?: Callback): void {\r\n        try {\r\n            Contracts.throwIfNullOrUndefined(this.privProperties, this.privErrors.permissionDeniedConnect);\r\n            Contracts.throwIfNullOrWhitespace(this.privRoom.token, this.privErrors.permissionDeniedConnect);\r\n            this.privManager.leave(this.privProperties, this.privRoom.token,\r\n                (() => {\r\n                    this.handleCallback(cb, err);\r\n                }),\r\n                ((error: any) => {\r\n                    this.handleError(error, err);\r\n                }));\r\n            this.dispose();\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Issues a request to close the client websockets\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public endConversationAsync(cb?: Callback, err?: Callback): void {\r\n        try {\r\n            this.close(true);\r\n            this.handleCallback(cb, err);\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Issues a request to lock the conversation\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public lockConversationAsync(cb?: Callback, err?: Callback): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\r\n            if (!this.canSendAsHost) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"lock\")), err);\r\n            }\r\n            this.privConversationRecognizer?.sendLockRequest(true,\r\n                (() => {\r\n                    this.handleCallback(cb, err);\r\n                }),\r\n                ((error: any) => {\r\n                    this.handleError(error, err);\r\n                }));\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Issues a request to mute the conversation\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public muteAllParticipantsAsync(cb?: Callback, err?: Callback): void {\r\n\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\r\n            Contracts.throwIfNullOrUndefined(this.privConversationRecognizer, this.privErrors.permissionDeniedSend);\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\r\n            // check the user's permissions\r\n            if (!this.canSendAsHost) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"mute\")), err);\r\n            }\r\n            this.privConversationRecognizer?.sendMuteAllRequest(true,\r\n                (() => {\r\n                    this.handleCallback(cb, err);\r\n                }),\r\n                ((error: any) => {\r\n                    this.handleError(error, err);\r\n                }));\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Issues a request to mute a participant in the conversation\r\n     * @param userId\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public muteParticipantAsync(userId: string, cb?: Callback, err?: Callback): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\r\n            Contracts.throwIfNullOrWhitespace(userId, this.privErrors.invalidArgs.replace(\"{arg}\", \"userId\"));\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\r\n            // check the connection is open (host + participant can perform the mute command)\r\n            if (!this.canSend) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\r\n            }\r\n            // if not host, check the participant is not muting another participant\r\n            if (!this.me.isHost && this.me.id !== userId) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace(\"{command}\", \"mute\")), err);\r\n            }\r\n            // check the user exists\r\n            const exists: number = this.privParticipants.getParticipantIndex(userId);\r\n            if (exists === -1) {\r\n                this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);\r\n            }\r\n            this.privConversationRecognizer?.sendMuteRequest(userId, true, (() => {\r\n                this.handleCallback(cb, err);\r\n            }),\r\n                ((error: any) => {\r\n                    this.handleError(error, err);\r\n                }));\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Issues a request to remove a participant from the conversation\r\n     * @param userId\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public removeParticipantAsync(userId: string | IParticipant | IUser, cb?: Callback, err?: Callback): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\r\n            if (!this.canSendAsHost) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace(\"{command}\", \"remove\")), err);\r\n            }\r\n            let participantId: string = \"\";\r\n            if (typeof userId === \"string\") {\r\n                participantId = userId as string;\r\n            } else if (userId.hasOwnProperty(\"id\")) {\r\n                const participant: IParticipant = userId as IParticipant;\r\n                participantId = participant.id;\r\n            } else if (userId.hasOwnProperty(\"userId\")) {\r\n                const user: IUser = userId as IUser;\r\n                participantId = user.userId;\r\n            }\r\n            Contracts.throwIfNullOrWhitespace(participantId, this.privErrors.invalidArgs.replace(\"{arg}\", \"userId\"));\r\n            // check the participant exists\r\n            const index: number = this.participants.findIndex((p: Participant) => p.id === participantId);\r\n            if (index === -1) {\r\n                this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);\r\n            }\r\n            this.privConversationRecognizer?.sendEjectRequest(participantId, (() => {\r\n                this.handleCallback(cb, err);\r\n            }),\r\n                ((error: any) => {\r\n                    this.handleError(error, err);\r\n                }));\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Issues a request to unlock the conversation\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public unlockConversationAsync(cb?: Callback, err?: Callback): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\r\n            if (!this.canSendAsHost) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"unlock\")), err);\r\n            }\r\n            this.privConversationRecognizer?.sendLockRequest(false, (() => {\r\n                this.handleCallback(cb, err);\r\n            }),\r\n                ((error: any) => {\r\n                    this.handleError(error, err);\r\n                }));\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Issues a request to unmute all participants in the conversation\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public unmuteAllParticipantsAsync(cb?: Callback, err?: Callback): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\r\n            if (!this.canSendAsHost) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"unmute all\")), err);\r\n            }\r\n            this.privConversationRecognizer?.sendMuteAllRequest(false, (() => {\r\n                this.handleCallback(cb, err);\r\n            }),\r\n                ((error: any) => {\r\n                    this.handleError(error, err);\r\n                }));\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Issues a request to unmute a participant in the conversation\r\n     * @param userId\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public unmuteParticipantAsync(userId: string, cb?: Callback, err?: Callback): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\r\n            Contracts.throwIfNullOrWhitespace(userId, this.privErrors.invalidArgs.replace(\"{arg}\", \"userId\"));\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\r\n            // check the connection is open (host + participant can perform the mute command)\r\n            if (!this.canSend) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\r\n            }\r\n            // if not host, check the participant is not muting another participant\r\n            if (!this.me.isHost && this.me.id !== userId) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace(\"{command}\", \"mute\")), err);\r\n            }\r\n            // check the user exists\r\n            const exists: number = this.privParticipants.getParticipantIndex(userId);\r\n            if (exists === -1) {\r\n                this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);\r\n            }\r\n            this.privConversationRecognizer?.sendMuteRequest(userId, false, (() => {\r\n                this.handleCallback(cb, err);\r\n            }),\r\n                ((error: any) => {\r\n                    this.handleError(error, err);\r\n                }));\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send a text message\r\n     * @param message\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public sendTextMessageAsync(message: string, cb?: Callback, err?: Callback): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\r\n            Contracts.throwIfNullOrWhitespace(message, this.privErrors.invalidArgs.replace(\"{arg}\", \"message\"));\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\r\n            if (!this.canSend) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\r\n            }\r\n            // TODO: is a max length check required?\r\n            if (message.length > this.privTextMessageMaxLength) {\r\n                this.handleError(new Error(this.privErrors.invalidArgs.replace(\"{arg}\", \"message length\")), err);\r\n            }\r\n            this.privConversationRecognizer?.sendMessageRequest(message, (() => {\r\n                this.handleCallback(cb, err);\r\n            }),\r\n                ((error: any) => {\r\n                    this.handleError(error, err);\r\n                }));\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change nickname\r\n     * @param message\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public changeNicknameAsync(nickname: string, cb?: Callback, err?: Callback): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\r\n            Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\r\n            if (!this.canSend) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\r\n            }\r\n            this.privConversationRecognizer?.sendChangeNicknameRequest(nickname, (() => {\r\n                this.handleCallback(cb, err);\r\n            }),\r\n                ((error: any) => {\r\n                    this.handleError(error, err);\r\n                }));\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return this.privIsDisposed;\r\n    }\r\n\r\n    public dispose(reason?: string): void {\r\n        if (this.isDisposed) {\r\n            return;\r\n        }\r\n        this.privIsDisposed = true;\r\n        this.config?.close();\r\n        if (this.privConversationRecognizerConnection) {\r\n            this.privConversationRecognizerConnection.closeConnection();\r\n            this.privConversationRecognizerConnection.close();\r\n            this.privConversationRecognizerConnection = undefined;\r\n        }\r\n        this.privConfig = undefined;\r\n        this.privLanguage = undefined;\r\n        this.privProperties = undefined;\r\n        this.privRoom = undefined;\r\n        this.privToken = undefined;\r\n        this.privManager = undefined;\r\n        this.privConversationRecognizer = undefined;\r\n        this.privIsConnected = false;\r\n        this.privIsReady = false;\r\n        this.privParticipants = undefined;\r\n        this.privRoom = undefined;\r\n    }\r\n\r\n    /** websocket callbacks */\r\n    private onConnected = (e: ConnectionEventArgs): void => {\r\n        this.privIsConnected = true;\r\n        try {\r\n            if (!!this.privConversationTranslator.sessionStarted) {\r\n                this.privConversationTranslator.sessionStarted(this.privConversationTranslator, e);\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    }\r\n\r\n    private onDisconnected = (e: ConnectionEventArgs): void => {\r\n        this.close(false);\r\n        try {\r\n            if (!!this.privConversationTranslator.sessionStopped) {\r\n                this.privConversationTranslator.sessionStopped(this.privConversationTranslator, e);\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    }\r\n\r\n    private onCanceled = (r: ConversationTranslatorRecognizer, e: ConversationTranslationCanceledEventArgs): void => {\r\n        this.close(false); // ?\r\n        try {\r\n            if (!!this.privConversationTranslator.canceled) {\r\n                this.privConversationTranslator.canceled(this.privConversationTranslator, e);\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    }\r\n\r\n    private onParticipantUpdateCommandReceived = (r: ConversationTranslatorRecognizer, e: ParticipantAttributeEventArgs): void => {\r\n        try {\r\n            const updatedParticipant: any = this.privParticipants.getParticipant(e.id);\r\n            if (updatedParticipant !== undefined) {\r\n\r\n                switch (e.key) {\r\n                    case ConversationTranslatorCommandTypes.changeNickname:\r\n                        updatedParticipant.displayName = e.value;\r\n                        break;\r\n                    case ConversationTranslatorCommandTypes.setUseTTS:\r\n                        updatedParticipant.useTts = e.value;\r\n                        break;\r\n                    case ConversationTranslatorCommandTypes.setProfanityFiltering:\r\n                        updatedParticipant.profanity = e.value;\r\n                        break;\r\n                    case ConversationTranslatorCommandTypes.setMute:\r\n                        updatedParticipant.isMuted = e.value;\r\n                        break;\r\n                    case ConversationTranslatorCommandTypes.setTranslateToLanguages:\r\n                        updatedParticipant.translateToLanguages = e.value;\r\n                        break;\r\n                }\r\n                this.privParticipants.addOrUpdateParticipant(updatedParticipant);\r\n\r\n                if (!!this.privConversationTranslator?.participantsChanged) {\r\n                    this.privConversationTranslator?.participantsChanged(\r\n                        this.privConversationTranslator,\r\n                        new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.Updated,\r\n                            [this.toParticipant(updatedParticipant)], e.sessionId));\r\n                }\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    }\r\n\r\n    private onLockRoomCommandReceived = (r: ConversationTranslatorRecognizer, e: LockRoomEventArgs): void => {\r\n        // TODO\r\n    }\r\n\r\n    private onMuteAllCommandReceived = (r: ConversationTranslatorRecognizer, e: MuteAllEventArgs): void => {\r\n        try {\r\n            this.privParticipants.participants.forEach((p: IInternalParticipant) => p.isMuted = (p.isHost ? false : e.isMuted));\r\n            if (!!this.privConversationTranslator?.participantsChanged) {\r\n                this.privConversationTranslator?.participantsChanged(\r\n                    this.privConversationTranslator,\r\n                    new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.Updated,\r\n                        this.toParticipants(false), e.sessionId));\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    }\r\n\r\n    private onParticipantJoinCommandReceived = (r: ConversationTranslatorRecognizer, e: ParticipantEventArgs): void => {\r\n        try {\r\n            const newParticipant: IInternalParticipant = this.privParticipants.addOrUpdateParticipant(e.participant);\r\n            if (newParticipant !== undefined) {\r\n                if (!!this.privConversationTranslator?.participantsChanged) {\r\n                    this.privConversationTranslator?.participantsChanged(\r\n                        this.privConversationTranslator,\r\n                        new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.JoinedConversation,\r\n                            [this.toParticipant(newParticipant)], e.sessionId));\r\n                }\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    }\r\n\r\n    private onParticipantLeaveCommandReceived = (r: ConversationTranslatorRecognizer, e: ParticipantEventArgs): void => {\r\n        try {\r\n            const ejectedParticipant: IInternalParticipant = this.privParticipants.getParticipant(e.participant.id);\r\n            if (ejectedParticipant !== undefined) {\r\n                // remove the participant from the internal participants list\r\n                this.privParticipants.deleteParticipant(e.participant.id);\r\n                if (!!this.privConversationTranslator?.participantsChanged) {\r\n                    // notify subscribers that the participant has left the conversation\r\n                    this.privConversationTranslator?.participantsChanged(\r\n                        this.privConversationTranslator,\r\n                        new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.LeftConversation,\r\n                            [this.toParticipant(ejectedParticipant)], e.sessionId));\r\n                }\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    }\r\n\r\n    private onTranslationReceived = (r: ConversationTranslatorRecognizer, e: ConversationReceivedTranslationEventArgs): void => {\r\n        try {\r\n            switch (e.command) {\r\n                case ConversationTranslatorMessageTypes.final:\r\n                    if (!!this.privConversationTranslator?.transcribed) {\r\n                        this.privConversationTranslator?.transcribed(\r\n                            this.privConversationTranslator,\r\n                            new ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));\r\n                    }\r\n                    break;\r\n                case ConversationTranslatorMessageTypes.partial:\r\n                    if (!!this.privConversationTranslator?.transcribing) {\r\n                        this.privConversationTranslator?.transcribing(\r\n                            this.privConversationTranslator,\r\n                            new ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));\r\n                    }\r\n                    break;\r\n                case ConversationTranslatorMessageTypes.instantMessage:\r\n                    if (!!this.privConversationTranslator?.textMessageReceived) {\r\n                        this.privConversationTranslator?.textMessageReceived(\r\n                            this.privConversationTranslator,\r\n                            new ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));\r\n                    }\r\n                    break;\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    }\r\n\r\n    private onParticipantsListReceived = (r: ConversationTranslatorRecognizer, e: ParticipantsListEventArgs): void => {\r\n        try {\r\n            // check if the session token needs to be updated\r\n            if (e.sessionToken !== undefined && e.sessionToken !== null) {\r\n                this.privRoom.token = e.sessionToken;\r\n            }\r\n            // save the participants\r\n            this.privParticipants.participants = [...e.participants];\r\n            // enable the conversation\r\n            if (this.privParticipants.me !== undefined) {\r\n                this.privIsReady = true;\r\n            }\r\n            if (!!this.privConversationTranslator?.participantsChanged) {\r\n                this.privConversationTranslator?.participantsChanged(\r\n                    this.privConversationTranslator,\r\n                    new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.JoinedConversation, this.toParticipants(true), e.sessionId));\r\n            }\r\n            // if this is the host, update the nickname if needed\r\n            if (this.me.isHost) {\r\n                const nickname: string = this.privConversationTranslator.properties.getProperty(PropertyId.ConversationTranslator_Name);\r\n                if (nickname !== undefined && nickname.length > 0 && nickname !== this.me.displayName) {\r\n                    // issue a change nickname request\r\n                    this.changeNicknameAsync(nickname);\r\n                }\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    }\r\n\r\n    private onConversationExpiration = (r: ConversationTranslatorRecognizer, e: ConversationExpirationEventArgs): void => {\r\n        try {\r\n            if (!!this.privConversationTranslator?.conversationExpiration) {\r\n                this.privConversationTranslator?.conversationExpiration(\r\n                    this.privConversationTranslator,\r\n                    e);\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    }\r\n\r\n    private close(dispose: boolean): void {\r\n        try {\r\n            this.privIsConnected = false;\r\n            this.privConversationRecognizerConnection?.closeConnection();\r\n            this.privConversationRecognizerConnection?.close();\r\n            this.privConversationRecognizer.close();\r\n            this.privConversationRecognizerConnection = undefined;\r\n            this.privConversationRecognizer = undefined;\r\n            this.privConversationTranslator?.dispose();\r\n        } catch (e) {\r\n            // ignore error\r\n        }\r\n        if (dispose) {\r\n            this.dispose();\r\n        }\r\n    }\r\n\r\n    /** Helpers */\r\n    private get canSend(): boolean {\r\n        return this.privIsConnected && !this.privParticipants.me?.isMuted;\r\n    }\r\n\r\n    private get canSendAsHost(): boolean {\r\n        return this.privIsConnected && this.privParticipants.me?.isHost;\r\n    }\r\n\r\n    private handleCallback(cb: any, err: any): void {\r\n        if (!!cb) {\r\n            try {\r\n                cb();\r\n            } catch (e) {\r\n                if (!!err) {\r\n                    err(e);\r\n                }\r\n            }\r\n            cb = undefined;\r\n        }\r\n    }\r\n\r\n    private handleError(error: any, err: any): void {\r\n        if (!!err) {\r\n            if (error instanceof Error) {\r\n                const typedError: Error = error as Error;\r\n                err(typedError.name + \": \" + typedError.message);\r\n\r\n            } else {\r\n                err(error);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Participant Helpers */\r\n    private toParticipants(includeHost: boolean): Participant[] {\r\n\r\n        const participants: Participant[] = this.privParticipants.participants.map((p: IInternalParticipant) => {\r\n            return this.toParticipant(p);\r\n        });\r\n        if (!includeHost) {\r\n            return participants.filter((p: Participant) => p.isHost === false);\r\n        } else {\r\n            return participants;\r\n        }\r\n    }\r\n\r\n    private toParticipant(p: IInternalParticipant): Participant {\r\n        return new Participant(p.id, p.avatar, p.displayName, p.isHost, p.isMuted, p.isUsingTts, p.preferredLanguage);\r\n    }\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}