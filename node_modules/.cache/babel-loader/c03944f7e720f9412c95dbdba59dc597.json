{"ast":null,"code":"/**\n * Globalize Runtime v1.5.0\n *\n * http://github.com/jquery/globalize\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2020-03-25T12:19Z\n */\n\n/*!\n * Globalize Runtime v1.5.0 2020-03-25T12:19Z Released under the MIT license\n * http://git.io/TrdQbw\n */\n(function (root, factory) {\n  \"use strict\"; // UMD returnExports\n\n  if (typeof define === \"function\" && define.amd) {\n    // AMD\n    define([\"../globalize-runtime\"], factory);\n  } else if (typeof exports === \"object\") {\n    // Node, CommonJS\n    module.exports = factory(require(\"../globalize-runtime\"));\n  } else {\n    // Extend global\n    factory(root.Globalize);\n  }\n})(this, function (Globalize) {\n  var createError = Globalize._createError,\n      partsJoin = Globalize._partsJoin,\n      partsPush = Globalize._partsPush,\n      regexpEscape = Globalize._regexpEscape,\n      runtimeKey = Globalize._runtimeKey,\n      stringPad = Globalize._stringPad,\n      validateParameterType = Globalize._validateParameterType,\n      validateParameterPresence = Globalize._validateParameterPresence,\n      validateParameterTypeString = Globalize._validateParameterTypeString;\n\n  var createErrorUnsupportedFeature = function createErrorUnsupportedFeature(feature) {\n    return createError(\"E_UNSUPPORTED\", \"Unsupported {feature}.\", {\n      feature: feature\n    });\n  };\n\n  var validateParameterTypeNumber = function validateParameterTypeNumber(value, name) {\n    validateParameterType(value, name, value === undefined || typeof value === \"number\", \"Number\");\n  };\n  /**\n   * EBNF representation:\n   *\n   * compact_pattern_re =       prefix?\n   *                            number_pattern_re\n   *                            suffix?\n   *\n   * number_pattern_re =        0+\n   *\n   * Regexp groups:\n   *\n   *  0: compact_pattern_re\n   *  1: prefix\n   *  2: number_pattern_re (the number pattern to use in compact mode)\n   *  3: suffix\n   */\n\n\n  var numberCompactPatternRe = /^([^0]*)(0+)([^0]*)$/;\n  /**\n   * goupingSeparator( number, primaryGroupingSize, secondaryGroupingSize )\n   *\n   * @number [Number].\n   *\n   * @primaryGroupingSize [Number]\n   *\n   * @secondaryGroupingSize [Number]\n   *\n   * Return the formatted number with group separator.\n   */\n\n  var numberFormatGroupingSeparator = function numberFormatGroupingSeparator(number, primaryGroupingSize, secondaryGroupingSize) {\n    var index,\n        currentGroupingSize = primaryGroupingSize,\n        ret = \"\",\n        sep = \",\",\n        switchToSecondary = secondaryGroupingSize ? true : false;\n    number = String(number).split(\".\");\n    index = number[0].length;\n\n    while (index > currentGroupingSize) {\n      ret = number[0].slice(index - currentGroupingSize, index) + (ret.length ? sep : \"\") + ret;\n      index -= currentGroupingSize;\n\n      if (switchToSecondary) {\n        currentGroupingSize = secondaryGroupingSize;\n        switchToSecondary = false;\n      }\n    }\n\n    number[0] = number[0].slice(0, index) + (ret.length ? sep : \"\") + ret;\n    return number.join(\".\");\n  };\n  /**\n   * integerFractionDigits( number, minimumIntegerDigits, minimumFractionDigits,\n   * maximumFractionDigits, round, roundIncrement )\n   *\n   * @number [Number]\n   *\n   * @minimumIntegerDigits [Number]\n   *\n   * @minimumFractionDigits [Number]\n   *\n   * @maximumFractionDigits [Number]\n   *\n   * @round [Function]\n   *\n   * @roundIncrement [Function]\n   *\n   * Return the formatted integer and fraction digits.\n   */\n\n\n  var numberFormatIntegerFractionDigits = function numberFormatIntegerFractionDigits(number, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, round, roundIncrement) {\n    // Fraction\n    if (maximumFractionDigits) {\n      // Rounding\n      if (roundIncrement) {\n        number = round(number, roundIncrement); // Maximum fraction digits\n      } else {\n        number = round(number, {\n          exponent: -maximumFractionDigits\n        });\n      }\n    } else {\n      number = round(number);\n    }\n\n    number = String(number); // Maximum integer digits (post string phase)\n\n    if (maximumFractionDigits && /e-/.test(number)) {\n      // Use toFixed( maximumFractionDigits ) to make sure small numbers like 1e-7 are\n      // displayed using plain digits instead of scientific notation.\n      // 1: Remove leading decimal zeros.\n      // 2: Remove leading decimal separator.\n      // Note: String() is still preferred so it doesn't mess up with a number precision\n      // unnecessarily, e.g., (123456789.123).toFixed(10) === \"123456789.1229999959\",\n      // String(123456789.123) === \"123456789.123\".\n      number = (+number).toFixed(maximumFractionDigits).replace(/0+$/, \"\")\n      /* 1 */\n      .replace(/\\.$/, \"\")\n      /* 2 */\n      ;\n    } // Minimum fraction digits (post string phase)\n\n\n    if (minimumFractionDigits) {\n      number = number.split(\".\");\n      number[1] = stringPad(number[1] || \"\", minimumFractionDigits, true);\n      number = number.join(\".\");\n    } // Minimum integer digits\n\n\n    if (minimumIntegerDigits) {\n      number = number.split(\".\");\n      number[0] = stringPad(number[0], minimumIntegerDigits);\n      number = number.join(\".\");\n    }\n\n    return number;\n  };\n  /**\n   * toPrecision( number, precision, round )\n   *\n   * @number (Number)\n   *\n   * @precision (Number) significant figures precision (not decimal precision).\n   *\n   * @round (Function)\n   *\n   * Return number.toPrecision( precision ) using the given round function.\n   */\n\n\n  var numberToPrecision = function numberToPrecision(number, precision, round) {\n    var roundOrder;\n\n    if (number === 0) {\n      // Fix #706\n      return number;\n    }\n\n    roundOrder = Math.ceil(Math.log(Math.abs(number)) / Math.log(10));\n    roundOrder -= precision;\n    return round(number, {\n      exponent: roundOrder\n    });\n  };\n  /**\n   * toPrecision( number, minimumSignificantDigits, maximumSignificantDigits, round )\n   *\n   * @number [Number]\n   *\n   * @minimumSignificantDigits [Number]\n   *\n   * @maximumSignificantDigits [Number]\n   *\n   * @round [Function]\n   *\n   * Return the formatted significant digits number.\n   */\n\n\n  var numberFormatSignificantDigits = function numberFormatSignificantDigits(number, minimumSignificantDigits, maximumSignificantDigits, round) {\n    var atMinimum, atMaximum; // Sanity check.\n\n    if (minimumSignificantDigits > maximumSignificantDigits) {\n      maximumSignificantDigits = minimumSignificantDigits;\n    }\n\n    atMinimum = numberToPrecision(number, minimumSignificantDigits, round);\n    atMaximum = numberToPrecision(number, maximumSignificantDigits, round); // Use atMaximum only if it has more significant digits than atMinimum.\n\n    number = +atMinimum === +atMaximum ? atMinimum : atMaximum; // Expand integer numbers, eg. 123e5 to 12300.\n\n    number = (+number).toString(10);\n\n    if (/e/.test(number)) {\n      throw createErrorUnsupportedFeature({\n        feature: \"integers out of (1e21, 1e-7)\"\n      });\n    } // Add trailing zeros if necessary.\n\n\n    if (minimumSignificantDigits - number.replace(/^0+|\\./g, \"\").length > 0) {\n      number = number.split(\".\");\n      number[1] = stringPad(number[1] || \"\", minimumSignificantDigits - number[0].replace(/^0+/, \"\").length, true);\n      number = number.join(\".\");\n    }\n\n    return number;\n  };\n  /**\n   * EBNF representation:\n   *\n   * number_pattern_re =        prefix?\n   *                            padding?\n   *                            (integer_fraction_pattern | significant_pattern)\n   *                            scientific_notation?\n   *                            suffix?\n   *\n   * prefix =                   non_number_stuff\n   *\n   * padding =                  \"*\" regexp(.)\n   *\n   * integer_fraction_pattern = integer_pattern\n   *                            fraction_pattern?\n   *\n   * integer_pattern =          regexp([#,]*[0,]*0+)\n   *\n   * fraction_pattern =         \".\" regexp(0*[0-9]*#*)\n   *\n   * significant_pattern =      regexp([#,]*@+#*)\n   *\n   * scientific_notation =      regexp(E\\+?0+)\n   *\n   * suffix =                   non_number_stuff\n   *\n   * non_number_stuff =         regexp(('[^']+'|''|[^*#@0,.E])*)\n   *\n   *\n   * Regexp groups:\n   *\n   *  0: number_pattern_re\n   *  1: prefix\n   *  2: -\n   *  3: -\n   *  4: padding\n   *  5: (integer_fraction_pattern | significant_pattern)\n   *  6: integer_fraction_pattern\n   *  7: integer_pattern\n   *  8: fraction_pattern\n   *  9: significant_pattern\n   * 10: scientific_notation\n   * 11: suffix\n   * 12: -\n   */\n\n\n  var numberPatternRe = /^(('([^']|'')*'|[^*#@0,.E])*)(\\*.)?((([#,]*[0,]*0+)(\\.0*[0-9]*#*)?)|([#,]*@+#*))(E\\+?0+)?(('[^']+'|''|[^*#@0,.E])*)$/;\n  var numberSymbolName = {\n    \".\": \"decimal\",\n    \",\": \"group\",\n    \"%\": \"percentSign\",\n    \"+\": \"plusSign\",\n    \"-\": \"minusSign\",\n    \"E\": \"exponential\",\n    \"\\u2030\": \"perMille\"\n  };\n  /**\n   * removeLiteralQuotes( string )\n   *\n   * Return:\n   * - `'` if input string is `''`.\n   * - `o'clock` if input string is `'o''clock'`.\n   * - `foo` if input string is `foo`, i.e., return the same value in case it isn't a single-quoted\n   *   string.\n   */\n\n  var removeLiteralQuotes = function removeLiteralQuotes(string) {\n    if (string[0] + string[string.length - 1] !== \"''\") {\n      return string;\n    }\n\n    if (string === \"''\") {\n      return \"'\";\n    }\n\n    return string.replace(/''/g, \"'\").slice(1, -1);\n  };\n  /**\n   * format( number, properties )\n   *\n   * @number [Number].\n   *\n   * @properties [Object] Output of number/format-properties.\n   *\n   * Return the formatted number.\n   * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\n   */\n\n\n  var numberFormat = function numberFormat(number, properties, pluralGenerator) {\n    var aux, compactMap, infinitySymbol, maximumFractionDigits, maximumSignificantDigits, minimumFractionDigits, minimumIntegerDigits, minimumSignificantDigits, nanSymbol, nuDigitsMap, padding, prefix, primaryGroupingSize, pattern, round, roundIncrement, secondaryGroupingSize, stringToParts, suffix, symbolMap;\n    padding = properties[1];\n    minimumIntegerDigits = properties[2];\n    minimumFractionDigits = properties[3];\n    maximumFractionDigits = properties[4];\n    minimumSignificantDigits = properties[5];\n    maximumSignificantDigits = properties[6];\n    roundIncrement = properties[7];\n    primaryGroupingSize = properties[8];\n    secondaryGroupingSize = properties[9];\n    round = properties[15];\n    infinitySymbol = properties[16];\n    nanSymbol = properties[17];\n    symbolMap = properties[18];\n    nuDigitsMap = properties[19];\n    compactMap = properties[20]; // NaN\n\n    if (isNaN(number)) {\n      return [{\n        type: \"nan\",\n        value: nanSymbol\n      }];\n    }\n\n    if (number < 0) {\n      pattern = properties[12];\n      prefix = properties[13];\n      suffix = properties[14];\n    } else {\n      pattern = properties[11];\n      prefix = properties[0];\n      suffix = properties[10];\n    } // For prefix, suffix, and number parts.\n\n\n    stringToParts = function stringToParts(string) {\n      var numberType = \"integer\",\n          parts = []; // TODO Move the tokenization of all parts that don't depend on number into\n      // format-properties.\n\n      string.replace(/('([^']|'')+'|'')|./g, function (character, literal) {\n        // Literals\n        if (literal) {\n          partsPush(parts, \"literal\", removeLiteralQuotes(literal));\n          return;\n        } // Currency symbol\n\n\n        if (character === \"\\xA4\") {\n          partsPush(parts, \"currency\", character);\n          return;\n        } // Symbols\n\n\n        character = character.replace(/[.,\\-+E%\\u2030]/, function (symbol) {\n          if (symbol === \".\") {\n            numberType = \"fraction\";\n          }\n\n          partsPush(parts, numberSymbolName[symbol], symbolMap[symbol]); // \"Erase\" handled character.\n\n          return \"\";\n        }); // Number\n\n        character = character.replace(/[0-9]/, function (digit) {\n          // Numbering system\n          if (nuDigitsMap) {\n            digit = nuDigitsMap[+digit];\n          }\n\n          partsPush(parts, numberType, digit); // \"Erase\" handled character.\n\n          return \"\";\n        }); // Etc\n\n        character.replace(/./, function (etc) {\n          partsPush(parts, \"literal\", etc);\n        });\n      });\n      return parts;\n    };\n\n    prefix = stringToParts(prefix);\n    suffix = stringToParts(suffix); // Infinity\n\n    if (!isFinite(number)) {\n      return prefix.concat({\n        type: \"infinity\",\n        value: infinitySymbol\n      }, suffix);\n    } // Percent\n\n\n    if (pattern.indexOf(\"%\") !== -1) {\n      number *= 100; // Per mille\n    } else if (pattern.indexOf(\"\\u2030\") !== -1) {\n      number *= 1000;\n    }\n\n    var compactPattern, compactDigits, compactProperties, divisor, numberExponent, pluralForm; // Compact mode: initial number digit processing\n\n    if (compactMap) {\n      numberExponent = Math.abs(Math.floor(number)).toString().length - 1;\n      numberExponent = Math.min(numberExponent, compactMap.maxExponent); // Use default plural form to perform initial decimal shift\n\n      if (numberExponent >= 3) {\n        compactPattern = compactMap[numberExponent] && compactMap[numberExponent].other;\n      }\n\n      if (compactPattern === \"0\") {\n        compactPattern = null;\n      } else if (compactPattern) {\n        compactDigits = compactPattern.split(\"0\").length - 1;\n        divisor = numberExponent - (compactDigits - 1);\n        number = number / Math.pow(10, divisor);\n      }\n    } // Significant digit format\n\n\n    if (!isNaN(minimumSignificantDigits * maximumSignificantDigits)) {\n      number = numberFormatSignificantDigits(number, minimumSignificantDigits, maximumSignificantDigits, round); // Integer and fractional format\n    } else {\n      number = numberFormatIntegerFractionDigits(number, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, round, roundIncrement);\n    } // Compact mode: apply formatting\n\n\n    if (compactMap && compactPattern) {\n      // Get plural form after possible roundings\n      pluralForm = pluralGenerator ? pluralGenerator(+number) : \"other\";\n      compactPattern = compactMap[numberExponent][pluralForm] || compactPattern;\n      compactProperties = compactPattern.match(numberCompactPatternRe); // TODO Move the tokenization of all parts that don't depend on number into\n      // format-properties.\n\n      aux = function aux(string) {\n        var parts = [];\n        string.replace(/(\\s+)|([^\\s0]+)/g, function (garbage, space, compact) {\n          // Literals\n          if (space) {\n            partsPush(parts, \"literal\", space);\n            return;\n          } // Compact value\n\n\n          if (compact) {\n            partsPush(parts, \"compact\", compact);\n            return;\n          }\n        });\n        return parts;\n      }; // update prefix/suffix with compact prefix/suffix\n\n\n      prefix = prefix.concat(aux(compactProperties[1]));\n      suffix = aux(compactProperties[3]).concat(suffix);\n    } // Remove the possible number minus sign\n\n\n    number = number.replace(/^-/, \"\"); // Grouping separators\n\n    if (primaryGroupingSize) {\n      number = numberFormatGroupingSeparator(number, primaryGroupingSize, secondaryGroupingSize);\n    } // Scientific notation\n    // TODO implement here\n    // Padding/'([^']|'')+'|''|[.,\\-+E%\\u2030]/g\n    // TODO implement here\n\n\n    return prefix.concat(stringToParts(number), suffix);\n  };\n\n  var numberFormatterFn = function numberFormatterFn(numberToPartsFormatter) {\n    return function numberFormatter(value) {\n      return partsJoin(numberToPartsFormatter(value));\n    };\n  };\n  /**\n   * Generated by:\n   *\n   * var regenerate = require( \"regenerate\" );\n   * var formatSymbols = require( * \"unicode-8.0.0/General_Category/Format/symbols\" );\n   * regenerate().add( formatSymbols ).toString();\n   *\n   * https://github.com/mathiasbynens/regenerate\n   * https://github.com/mathiasbynens/unicode-8.0.0\n   */\n\n\n  var regexpCfG = /[\\xAD\\u0600-\\u0605\\u061C\\u06DD\\u070F\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u2064\\u2066-\\u206F\\uFEFF\\uFFF9-\\uFFFB]|\\uD804\\uDCBD|\\uD82F[\\uDCA0-\\uDCA3]|\\uD834[\\uDD73-\\uDD7A]|\\uDB40[\\uDC01\\uDC20-\\uDC7F]/g;\n  /**\n   * Generated by:\n   *\n   * var regenerate = require( \"regenerate\" );\n   * var dashSymbols = require( * \"unicode-8.0.0/General_Category/Dash_Punctuation/symbols\" );\n   * regenerate().add( dashSymbols ).toString();\n   *\n   * https://github.com/mathiasbynens/regenerate\n   * https://github.com/mathiasbynens/unicode-8.0.0\n   *\n   * NOTE: In addition to [:dash:],  the below includes MINUS SIGN U+2212.\n   */\n\n  var regexpDashG = /[\\-\\u058A\\u05BE\\u1400\\u1806\\u2010-\\u2015\\u2E17\\u2E1A\\u2E3A\\u2E3B\\u2E40\\u301C\\u3030\\u30A0\\uFE31\\uFE32\\uFE58\\uFE63\\uFF0D\\u2212]/g;\n  /**\n   * Generated by:\n   *\n   * var regenerate = require( \"regenerate\" );\n   * var spaceSeparatorSymbols = require( \"unicode-8.0.0/General_Category/Space_Separator/symbols\" );\n   * regenerate().add( spaceSeparatorSymbols ).toString();\n   *\n   * https://github.com/mathiasbynens/regenerate\n   * https://github.com/mathiasbynens/unicode-8.0.0\n   */\n\n  var regexpZsG = /[ \\xA0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]/g;\n  /**\n   * Loose Matching:\n   * - Ignore all format characters, which includes RLM, LRM or ALM used to control BIDI\n   *   formatting.\n   * - Map all characters in [:Zs:] to U+0020 SPACE;\n   * - Map all characters in [:Dash:] to U+002D HYPHEN-MINUS;\n   */\n\n  var looseMatching = function looseMatching(value) {\n    return value.replace(regexpCfG, \"\").replace(regexpDashG, \"-\").replace(regexpZsG, \" \");\n  };\n  /**\n   * parse( value, properties )\n   *\n   * @value [String].\n   *\n   * @properties [Object] Parser properties is a reduced pre-processed cldr\n   * data set returned by numberParserProperties().\n   *\n   * Return the parsed Number (including Infinity) or NaN when value is invalid.\n   * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\n   */\n\n\n  var numberParse = function numberParse(value, properties) {\n    var grammar, invertedNuDigitsMap, invertedSymbolMap, negative, number, prefix, prefixNSuffix, suffix, tokenizer, valid; // Grammar:\n    // - Value <=           NaN | PositiveNumber | NegativeNumber\n    // - PositiveNumber <=  PositivePrefix NumberOrInf PositiveSufix\n    // - NegativeNumber <=  NegativePrefix NumberOrInf\n    // - NumberOrInf <=     Number | Inf\n\n    grammar = [[\"nan\"], [\"prefix\", \"infinity\", \"suffix\"], [\"prefix\", \"number\", \"suffix\"], [\"negativePrefix\", \"infinity\", \"negativeSuffix\"], [\"negativePrefix\", \"number\", \"negativeSuffix\"]];\n    invertedSymbolMap = properties[0];\n    invertedNuDigitsMap = properties[1] || {};\n    tokenizer = properties[2];\n    value = looseMatching(value);\n\n    function parse(type) {\n      return function (lexeme) {\n        // Reverse localized symbols and numbering system.\n        lexeme = lexeme.split(\"\").map(function (character) {\n          return invertedSymbolMap[character] || invertedNuDigitsMap[character] || character;\n        }).join(\"\");\n\n        switch (type) {\n          case \"infinity\":\n            number = Infinity;\n            break;\n\n          case \"nan\":\n            number = NaN;\n            break;\n\n          case \"number\":\n            // Remove grouping separators.\n            lexeme = lexeme.replace(/,/g, \"\");\n            number = +lexeme;\n            break;\n\n          case \"prefix\":\n          case \"negativePrefix\":\n            prefix = lexeme;\n            break;\n\n          case \"suffix\":\n            suffix = lexeme;\n            break;\n\n          case \"negativeSuffix\":\n            suffix = lexeme;\n            negative = true;\n            break;\n          // This should never be reached.\n\n          default:\n            throw new Error(\"Internal error\");\n        }\n\n        return \"\";\n      };\n    }\n\n    function tokenizeNParse(_value, grammar) {\n      return grammar.some(function (statement) {\n        var value = _value; // The whole grammar statement should be used (i.e., .every() return true) and value be\n        // entirely consumed (i.e., !value.length).\n\n        return statement.every(function (type) {\n          if (value.match(tokenizer[type]) === null) {\n            return false;\n          } // Consume and parse it.\n\n\n          value = value.replace(tokenizer[type], parse(type));\n          return true;\n        }) && !value.length;\n      });\n    }\n\n    valid = tokenizeNParse(value, grammar); // NaN\n\n    if (!valid || isNaN(number)) {\n      return NaN;\n    }\n\n    prefixNSuffix = \"\" + prefix + suffix; // Percent\n\n    if (prefixNSuffix.indexOf(\"%\") !== -1) {\n      number /= 100; // Per mille\n    } else if (prefixNSuffix.indexOf(\"\\u2030\") !== -1) {\n      number /= 1000;\n    } // Negative number\n\n\n    if (negative) {\n      number *= -1;\n    }\n\n    return number;\n  };\n\n  var numberParserFn = function numberParserFn(properties) {\n    return function numberParser(value) {\n      validateParameterPresence(value, \"value\");\n      validateParameterTypeString(value, \"value\");\n      return numberParse(value, properties);\n    };\n  };\n\n  var numberToPartsFormatterFn = function numberToPartsFormatterFn(properties, pluralGenerator) {\n    return function numberToPartsFormatter(value) {\n      validateParameterPresence(value, \"value\");\n      validateParameterTypeNumber(value, \"value\");\n      return numberFormat(value, properties, pluralGenerator);\n    };\n  };\n\n  var numberTruncate = function numberTruncate(value) {\n    if (isNaN(value)) {\n      return NaN;\n    }\n\n    return Math[value < 0 ? \"ceil\" : \"floor\"](value);\n  };\n  /**\n   * round( method )\n   *\n   * @method [String] with either \"round\", \"ceil\", \"floor\", or \"truncate\".\n   *\n   * Return function( value, incrementOrExp ):\n   *\n   *   @value [Number] eg. 123.45.\n   *\n   *   @incrementOrExp [Number] optional, eg. 0.1; or\n   *     [Object] Either { increment: <value> } or { exponent: <value> }\n   *\n   *   Return the rounded number, eg:\n   *   - round( \"round\" )( 123.45 ): 123;\n   *   - round( \"ceil\" )( 123.45 ): 124;\n   *   - round( \"floor\" )( 123.45 ): 123;\n   *   - round( \"truncate\" )( 123.45 ): 123;\n   *   - round( \"round\" )( 123.45, 0.1 ): 123.5;\n   *   - round( \"round\" )( 123.45, 10 ): 120;\n   *\n   *   Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round\n   *   Ref: #376\n   */\n\n\n  var numberRound = function numberRound(method) {\n    method = method || \"round\";\n    method = method === \"truncate\" ? numberTruncate : Math[method];\n    return function (value, incrementOrExp) {\n      var exp, increment;\n      value = +value; // If the value is not a number, return NaN.\n\n      if (isNaN(value)) {\n        return NaN;\n      } // Exponent given.\n\n\n      if (typeof incrementOrExp === \"object\" && incrementOrExp.exponent) {\n        exp = +incrementOrExp.exponent;\n        increment = 1;\n\n        if (exp === 0) {\n          return method(value);\n        } // If the exp is not an integer, return NaN.\n\n\n        if (!(typeof exp === \"number\" && exp % 1 === 0)) {\n          return NaN;\n        } // Increment given.\n\n      } else {\n        increment = +incrementOrExp || 1;\n\n        if (increment === 1) {\n          return method(value);\n        } // If the increment is not a number, return NaN.\n\n\n        if (isNaN(increment)) {\n          return NaN;\n        }\n\n        increment = increment.toExponential().split(\"e\");\n        exp = +increment[1];\n        increment = +increment[0];\n      } // Shift & Round\n\n\n      value = value.toString().split(\"e\");\n      value[0] = +value[0] / increment;\n      value[1] = value[1] ? +value[1] - exp : -exp;\n      value = method(+(value[0] + \"e\" + value[1])); // Shift back\n\n      value = value.toString().split(\"e\");\n      value[0] = +value[0] * increment;\n      value[1] = value[1] ? +value[1] + exp : exp;\n      return +(value[0] + \"e\" + value[1]);\n    };\n  };\n\n  Globalize._createErrorUnsupportedFeature = createErrorUnsupportedFeature;\n  Globalize._looseMatching = looseMatching;\n  Globalize._numberFormat = numberFormat;\n  Globalize._numberFormatterFn = numberFormatterFn;\n  Globalize._numberParse = numberParse;\n  Globalize._numberParserFn = numberParserFn;\n  Globalize._numberRound = numberRound;\n  Globalize._numberToPartsFormatterFn = numberToPartsFormatterFn;\n  Globalize._removeLiteralQuotes = removeLiteralQuotes;\n  Globalize._validateParameterPresence = validateParameterPresence;\n  Globalize._validateParameterTypeNumber = validateParameterTypeNumber;\n  Globalize._validateParameterTypeString = validateParameterTypeString; // Stamp runtimeKey and return cached fn.\n  // Note, this function isn't made common to all formatters and parsers, because in practice this is\n  // only used (at the moment) for numberFormatter used by unitFormatter.\n  // TODO: Move this function into a common place when this is used by different formatters.\n\n  function cached(runtimeKey) {\n    Globalize[runtimeKey].runtimeKey = runtimeKey;\n    return Globalize[runtimeKey];\n  }\n\n  Globalize.numberFormatter = Globalize.prototype.numberFormatter = function (options) {\n    options = options || {};\n    return cached(runtimeKey(\"numberFormatter\", this._locale, [options]));\n  };\n\n  Globalize.numberToPartsFormatter = Globalize.prototype.numberToPartsFormatter = function (options) {\n    options = options || {};\n    return cached(runtimeKey(\"numberToPartsFormatter\", this._locale, [options]));\n  };\n\n  Globalize.numberParser = Globalize.prototype.numberParser = function (options) {\n    options = options || {};\n    return Globalize[runtimeKey(\"numberParser\", this._locale, [options])];\n  };\n\n  Globalize.formatNumber = Globalize.prototype.formatNumber = function (value, options) {\n    validateParameterPresence(value, \"value\");\n    validateParameterTypeNumber(value, \"value\");\n    return this.numberFormatter(options)(value);\n  };\n\n  Globalize.formatNumberToParts = Globalize.prototype.formatNumberToParts = function (value, options) {\n    validateParameterPresence(value, \"value\");\n    validateParameterTypeNumber(value, \"value\");\n    return this.numberFormatter(options)(value);\n  };\n\n  Globalize.parseNumber = Globalize.prototype.parseNumber = function (value, options) {\n    validateParameterPresence(value, \"value\");\n    validateParameterTypeString(value, \"value\");\n    return this.numberParser(options)(value);\n  };\n\n  return Globalize;\n});","map":{"version":3,"sources":["/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/globalize/dist/globalize-runtime/number.js"],"names":["root","factory","define","amd","exports","module","require","Globalize","createError","_createError","partsJoin","_partsJoin","partsPush","_partsPush","regexpEscape","_regexpEscape","runtimeKey","_runtimeKey","stringPad","_stringPad","validateParameterType","_validateParameterType","validateParameterPresence","_validateParameterPresence","validateParameterTypeString","_validateParameterTypeString","createErrorUnsupportedFeature","feature","validateParameterTypeNumber","value","name","undefined","numberCompactPatternRe","numberFormatGroupingSeparator","number","primaryGroupingSize","secondaryGroupingSize","index","currentGroupingSize","ret","sep","switchToSecondary","String","split","length","slice","join","numberFormatIntegerFractionDigits","minimumIntegerDigits","minimumFractionDigits","maximumFractionDigits","round","roundIncrement","exponent","test","toFixed","replace","numberToPrecision","precision","roundOrder","Math","ceil","log","abs","numberFormatSignificantDigits","minimumSignificantDigits","maximumSignificantDigits","atMinimum","atMaximum","toString","numberPatternRe","numberSymbolName","removeLiteralQuotes","string","numberFormat","properties","pluralGenerator","aux","compactMap","infinitySymbol","nanSymbol","nuDigitsMap","padding","prefix","pattern","stringToParts","suffix","symbolMap","isNaN","type","numberType","parts","character","literal","symbol","digit","etc","isFinite","concat","indexOf","compactPattern","compactDigits","compactProperties","divisor","numberExponent","pluralForm","floor","min","maxExponent","other","pow","match","garbage","space","compact","numberFormatterFn","numberToPartsFormatter","numberFormatter","regexpCfG","regexpDashG","regexpZsG","looseMatching","numberParse","grammar","invertedNuDigitsMap","invertedSymbolMap","negative","prefixNSuffix","tokenizer","valid","parse","lexeme","map","Infinity","NaN","Error","tokenizeNParse","_value","some","statement","every","numberParserFn","numberParser","numberToPartsFormatterFn","numberTruncate","numberRound","method","incrementOrExp","exp","increment","toExponential","_createErrorUnsupportedFeature","_looseMatching","_numberFormat","_numberFormatterFn","_numberParse","_numberParserFn","_numberRound","_numberToPartsFormatterFn","_removeLiteralQuotes","_validateParameterTypeNumber","cached","prototype","options","_locale","formatNumber","formatNumberToParts","parseNumber"],"mappings":"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","sourcesContent":["/**\n * Globalize Runtime v1.5.0\n *\n * http://github.com/jquery/globalize\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2020-03-25T12:19Z\n */\n/*!\n * Globalize Runtime v1.5.0 2020-03-25T12:19Z Released under the MIT license\n * http://git.io/TrdQbw\n */\n(function( root, factory ) {\n\n\t\"use strict\";\n\n\t// UMD returnExports\n\tif ( typeof define === \"function\" && define.amd ) {\n\n\t\t// AMD\n\t\tdefine([\n\t\t\t\"../globalize-runtime\"\n\t\t], factory );\n\t} else if ( typeof exports === \"object\" ) {\n\n\t\t// Node, CommonJS\n\t\tmodule.exports = factory( require( \"../globalize-runtime\" ) );\n\t} else {\n\n\t\t// Extend global\n\t\tfactory( root.Globalize );\n\t}\n}(this, function( Globalize ) {\n\n\n\nvar createError = Globalize._createError,\n\tpartsJoin = Globalize._partsJoin,\n\tpartsPush = Globalize._partsPush,\n\tregexpEscape = Globalize._regexpEscape,\n\truntimeKey = Globalize._runtimeKey,\n\tstringPad = Globalize._stringPad,\n\tvalidateParameterType = Globalize._validateParameterType,\n\tvalidateParameterPresence = Globalize._validateParameterPresence,\n\tvalidateParameterTypeString = Globalize._validateParameterTypeString;\n\n\nvar createErrorUnsupportedFeature = function( feature ) {\n\treturn createError( \"E_UNSUPPORTED\", \"Unsupported {feature}.\", {\n\t\tfeature: feature\n\t});\n};\n\n\n\n\nvar validateParameterTypeNumber = function( value, name ) {\n\tvalidateParameterType(\n\t\tvalue,\n\t\tname,\n\t\tvalue === undefined || typeof value === \"number\",\n\t\t\"Number\"\n\t);\n};\n\n\n\n\n/**\n * EBNF representation:\n *\n * compact_pattern_re =       prefix?\n *                            number_pattern_re\n *                            suffix?\n *\n * number_pattern_re =        0+\n *\n * Regexp groups:\n *\n *  0: compact_pattern_re\n *  1: prefix\n *  2: number_pattern_re (the number pattern to use in compact mode)\n *  3: suffix\n */\nvar numberCompactPatternRe = ( /^([^0]*)(0+)([^0]*)$/ );\n\n\n\n\n/**\n * goupingSeparator( number, primaryGroupingSize, secondaryGroupingSize )\n *\n * @number [Number].\n *\n * @primaryGroupingSize [Number]\n *\n * @secondaryGroupingSize [Number]\n *\n * Return the formatted number with group separator.\n */\nvar numberFormatGroupingSeparator = function( number, primaryGroupingSize, secondaryGroupingSize ) {\n\tvar index,\n\t\tcurrentGroupingSize = primaryGroupingSize,\n\t\tret = \"\",\n\t\tsep = \",\",\n\t\tswitchToSecondary = secondaryGroupingSize ? true : false;\n\n\tnumber = String( number ).split( \".\" );\n\tindex = number[ 0 ].length;\n\n\twhile ( index > currentGroupingSize ) {\n\t\tret = number[ 0 ].slice( index - currentGroupingSize, index ) +\n\t\t\t( ret.length ? sep : \"\" ) + ret;\n\t\tindex -= currentGroupingSize;\n\t\tif ( switchToSecondary ) {\n\t\t\tcurrentGroupingSize = secondaryGroupingSize;\n\t\t\tswitchToSecondary = false;\n\t\t}\n\t}\n\n\tnumber[ 0 ] = number[ 0 ].slice( 0, index ) + ( ret.length ? sep : \"\" ) + ret;\n\treturn number.join( \".\" );\n};\n\n\n\n\n/**\n * integerFractionDigits( number, minimumIntegerDigits, minimumFractionDigits,\n * maximumFractionDigits, round, roundIncrement )\n *\n * @number [Number]\n *\n * @minimumIntegerDigits [Number]\n *\n * @minimumFractionDigits [Number]\n *\n * @maximumFractionDigits [Number]\n *\n * @round [Function]\n *\n * @roundIncrement [Function]\n *\n * Return the formatted integer and fraction digits.\n */\nvar numberFormatIntegerFractionDigits = function( number, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, round,\n\troundIncrement ) {\n\n\t// Fraction\n\tif ( maximumFractionDigits ) {\n\n\t\t// Rounding\n\t\tif ( roundIncrement ) {\n\t\t\tnumber = round( number, roundIncrement );\n\n\t\t// Maximum fraction digits\n\t\t} else {\n\t\t\tnumber = round( number, { exponent: -maximumFractionDigits } );\n\t\t}\n\n\t} else {\n\t\tnumber = round( number );\n\t}\n\n\tnumber = String( number );\n\n\t// Maximum integer digits (post string phase)\n\tif ( maximumFractionDigits && /e-/.test( number ) ) {\n\n\t\t// Use toFixed( maximumFractionDigits ) to make sure small numbers like 1e-7 are\n\t\t// displayed using plain digits instead of scientific notation.\n\t\t// 1: Remove leading decimal zeros.\n\t\t// 2: Remove leading decimal separator.\n\t\t// Note: String() is still preferred so it doesn't mess up with a number precision\n\t\t// unnecessarily, e.g., (123456789.123).toFixed(10) === \"123456789.1229999959\",\n\t\t// String(123456789.123) === \"123456789.123\".\n\t\tnumber = ( +number ).toFixed( maximumFractionDigits )\n\t\t\t.replace( /0+$/, \"\" ) /* 1 */\n\t\t\t.replace( /\\.$/, \"\" ) /* 2 */;\n\t}\n\n\t// Minimum fraction digits (post string phase)\n\tif ( minimumFractionDigits ) {\n\t\tnumber = number.split( \".\" );\n\t\tnumber[ 1 ] = stringPad( number[ 1 ] || \"\", minimumFractionDigits, true );\n\t\tnumber = number.join( \".\" );\n\t}\n\n\t// Minimum integer digits\n\tif ( minimumIntegerDigits ) {\n\t\tnumber = number.split( \".\" );\n\t\tnumber[ 0 ] = stringPad( number[ 0 ], minimumIntegerDigits );\n\t\tnumber = number.join( \".\" );\n\t}\n\n\treturn number;\n};\n\n\n\n\n/**\n * toPrecision( number, precision, round )\n *\n * @number (Number)\n *\n * @precision (Number) significant figures precision (not decimal precision).\n *\n * @round (Function)\n *\n * Return number.toPrecision( precision ) using the given round function.\n */\nvar numberToPrecision = function( number, precision, round ) {\n\tvar roundOrder;\n\n\tif ( number === 0 ) {  // Fix #706\n\t\treturn number;\n\t}\n\n\troundOrder = Math.ceil( Math.log( Math.abs( number ) ) / Math.log( 10 ) );\n\troundOrder -= precision;\n\n\treturn round( number, { exponent: roundOrder } );\n};\n\n\n\n\n/**\n * toPrecision( number, minimumSignificantDigits, maximumSignificantDigits, round )\n *\n * @number [Number]\n *\n * @minimumSignificantDigits [Number]\n *\n * @maximumSignificantDigits [Number]\n *\n * @round [Function]\n *\n * Return the formatted significant digits number.\n */\nvar numberFormatSignificantDigits = function( number, minimumSignificantDigits, maximumSignificantDigits, round ) {\n\tvar atMinimum, atMaximum;\n\n\t// Sanity check.\n\tif ( minimumSignificantDigits > maximumSignificantDigits ) {\n\t\tmaximumSignificantDigits = minimumSignificantDigits;\n\t}\n\n\tatMinimum = numberToPrecision( number, minimumSignificantDigits, round );\n\tatMaximum = numberToPrecision( number, maximumSignificantDigits, round );\n\n\t// Use atMaximum only if it has more significant digits than atMinimum.\n\tnumber = +atMinimum === +atMaximum ? atMinimum : atMaximum;\n\n\t// Expand integer numbers, eg. 123e5 to 12300.\n\tnumber = ( +number ).toString( 10 );\n\n\tif ( ( /e/ ).test( number ) ) {\n\t\tthrow createErrorUnsupportedFeature({\n\t\t\tfeature: \"integers out of (1e21, 1e-7)\"\n\t\t});\n\t}\n\n\t// Add trailing zeros if necessary.\n\tif ( minimumSignificantDigits - number.replace( /^0+|\\./g, \"\" ).length > 0 ) {\n\t\tnumber = number.split( \".\" );\n\t\tnumber[ 1 ] = stringPad( number[ 1 ] || \"\", minimumSignificantDigits - number[ 0 ].replace( /^0+/, \"\" ).length, true );\n\t\tnumber = number.join( \".\" );\n\t}\n\n\treturn number;\n};\n\n\n\n\n/**\n * EBNF representation:\n *\n * number_pattern_re =        prefix?\n *                            padding?\n *                            (integer_fraction_pattern | significant_pattern)\n *                            scientific_notation?\n *                            suffix?\n *\n * prefix =                   non_number_stuff\n *\n * padding =                  \"*\" regexp(.)\n *\n * integer_fraction_pattern = integer_pattern\n *                            fraction_pattern?\n *\n * integer_pattern =          regexp([#,]*[0,]*0+)\n *\n * fraction_pattern =         \".\" regexp(0*[0-9]*#*)\n *\n * significant_pattern =      regexp([#,]*@+#*)\n *\n * scientific_notation =      regexp(E\\+?0+)\n *\n * suffix =                   non_number_stuff\n *\n * non_number_stuff =         regexp(('[^']+'|''|[^*#@0,.E])*)\n *\n *\n * Regexp groups:\n *\n *  0: number_pattern_re\n *  1: prefix\n *  2: -\n *  3: -\n *  4: padding\n *  5: (integer_fraction_pattern | significant_pattern)\n *  6: integer_fraction_pattern\n *  7: integer_pattern\n *  8: fraction_pattern\n *  9: significant_pattern\n * 10: scientific_notation\n * 11: suffix\n * 12: -\n */\nvar numberPatternRe = ( /^(('([^']|'')*'|[^*#@0,.E])*)(\\*.)?((([#,]*[0,]*0+)(\\.0*[0-9]*#*)?)|([#,]*@+#*))(E\\+?0+)?(('[^']+'|''|[^*#@0,.E])*)$/ );\n\n\n\n\nvar numberSymbolName = {\n\t\".\": \"decimal\",\n\t\",\": \"group\",\n\t\"%\": \"percentSign\",\n\t\"+\": \"plusSign\",\n\t\"-\": \"minusSign\",\n\t\"E\": \"exponential\",\n\t\"\\u2030\": \"perMille\"\n};\n\n\n\n\n/**\n * removeLiteralQuotes( string )\n *\n * Return:\n * - `'` if input string is `''`.\n * - `o'clock` if input string is `'o''clock'`.\n * - `foo` if input string is `foo`, i.e., return the same value in case it isn't a single-quoted\n *   string.\n */\nvar removeLiteralQuotes = function( string ) {\n\tif ( string[ 0 ] + string[ string.length - 1 ] !== \"''\" ) {\n\t\treturn string;\n\t}\n\tif ( string === \"''\" ) {\n\t\treturn \"'\";\n\t}\n\treturn string.replace( /''/g, \"'\" ).slice( 1, -1 );\n};\n\n\n\n\n/**\n * format( number, properties )\n *\n * @number [Number].\n *\n * @properties [Object] Output of number/format-properties.\n *\n * Return the formatted number.\n * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\n */\nvar numberFormat = function( number, properties, pluralGenerator ) {\n\tvar aux, compactMap, infinitySymbol, maximumFractionDigits, maximumSignificantDigits,\n\t\tminimumFractionDigits, minimumIntegerDigits, minimumSignificantDigits, nanSymbol,\n\t\tnuDigitsMap, padding, prefix, primaryGroupingSize, pattern, round, roundIncrement,\n\t\tsecondaryGroupingSize, stringToParts, suffix, symbolMap;\n\n\tpadding = properties[ 1 ];\n\tminimumIntegerDigits = properties[ 2 ];\n\tminimumFractionDigits = properties[ 3 ];\n\tmaximumFractionDigits = properties[ 4 ];\n\tminimumSignificantDigits = properties[ 5 ];\n\tmaximumSignificantDigits = properties[ 6 ];\n\troundIncrement = properties[ 7 ];\n\tprimaryGroupingSize = properties[ 8 ];\n\tsecondaryGroupingSize = properties[ 9 ];\n\tround = properties[ 15 ];\n\tinfinitySymbol = properties[ 16 ];\n\tnanSymbol = properties[ 17 ];\n\tsymbolMap = properties[ 18 ];\n\tnuDigitsMap = properties[ 19 ];\n\tcompactMap = properties[ 20 ];\n\n\t// NaN\n\tif ( isNaN( number ) ) {\n\t\treturn [ { type: \"nan\", value: nanSymbol } ];\n\t}\n\n\tif ( number < 0 ) {\n\t\tpattern = properties[ 12 ];\n\t\tprefix = properties[ 13 ];\n\t\tsuffix = properties[ 14 ];\n\t} else {\n\t\tpattern = properties[ 11 ];\n\t\tprefix = properties[ 0 ];\n\t\tsuffix = properties[ 10 ];\n\t}\n\n\t// For prefix, suffix, and number parts.\n\tstringToParts = function( string ) {\n\t\tvar numberType = \"integer\",\n\t\t\tparts = [];\n\n\t\t// TODO Move the tokenization of all parts that don't depend on number into\n\t\t// format-properties.\n\t\tstring.replace( /('([^']|'')+'|'')|./g, function( character, literal ) {\n\n\t\t\t// Literals\n\t\t\tif ( literal ) {\n\t\t\t\tpartsPush( parts, \"literal\", removeLiteralQuotes( literal ) );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Currency symbol\n\t\t\tif ( character === \"\\u00A4\" ) {\n\t\t\t\tpartsPush( parts, \"currency\", character );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Symbols\n\t\t\tcharacter = character.replace( /[.,\\-+E%\\u2030]/, function( symbol ) {\n\t\t\t\tif ( symbol === \".\" ) {\n\t\t\t\t\tnumberType = \"fraction\";\n\t\t\t\t}\n\t\t\t\tpartsPush( parts, numberSymbolName[symbol], symbolMap[ symbol ] );\n\n\t\t\t\t// \"Erase\" handled character.\n\t\t\t\treturn \"\";\n\t\t\t});\n\n\t\t\t// Number\n\t\t\tcharacter = character.replace( /[0-9]/, function( digit ) {\n\n\t\t\t\t// Numbering system\n\t\t\t\tif ( nuDigitsMap ) {\n\t\t\t\t\tdigit = nuDigitsMap[ +digit ];\n\t\t\t\t}\n\t\t\t\tpartsPush( parts, numberType, digit );\n\n\t\t\t\t// \"Erase\" handled character.\n\t\t\t\treturn \"\";\n\t\t\t});\n\n\t\t\t// Etc\n\t\t\tcharacter.replace( /./, function( etc ) {\n\t\t\t\tpartsPush( parts, \"literal\", etc );\n\t\t\t});\n\t\t});\n\t\treturn parts;\n\t};\n\n\tprefix = stringToParts( prefix );\n\tsuffix = stringToParts( suffix );\n\n\t// Infinity\n\tif ( !isFinite( number ) ) {\n\t\treturn prefix.concat(\n\t\t\t{ type: \"infinity\", value: infinitySymbol },\n\t\t\tsuffix\n\t\t);\n\t}\n\n\t// Percent\n\tif ( pattern.indexOf( \"%\" ) !== -1 ) {\n\t\tnumber *= 100;\n\n\t// Per mille\n\t} else if ( pattern.indexOf( \"\\u2030\" ) !== -1 ) {\n\t\tnumber *= 1000;\n\t}\n\n\tvar compactPattern, compactDigits, compactProperties, divisor, numberExponent, pluralForm;\n\n\t// Compact mode: initial number digit processing\n\tif ( compactMap ) {\n\t\tnumberExponent = Math.abs( Math.floor( number ) ).toString().length - 1;\n\t\tnumberExponent = Math.min( numberExponent, compactMap.maxExponent );\n\n\t\t// Use default plural form to perform initial decimal shift\n\t\tif ( numberExponent >= 3 ) {\n\t\t\tcompactPattern = compactMap[ numberExponent ] && compactMap[ numberExponent ].other;\n\t\t}\n\n\t\tif ( compactPattern === \"0\" ) {\n\t\t\tcompactPattern = null;\n\t\t} else if ( compactPattern ) {\n\t\t\tcompactDigits = compactPattern.split( \"0\" ).length - 1;\n\t\t\tdivisor = numberExponent - ( compactDigits - 1 );\n\t\t\tnumber = number / Math.pow( 10, divisor );\n\t\t}\n\t}\n\n\t// Significant digit format\n\tif ( !isNaN( minimumSignificantDigits * maximumSignificantDigits ) ) {\n\t\tnumber = numberFormatSignificantDigits( number, minimumSignificantDigits,\n\t\t\tmaximumSignificantDigits, round );\n\n\t// Integer and fractional format\n\t} else {\n\t\tnumber = numberFormatIntegerFractionDigits( number, minimumIntegerDigits,\n\t\t\tminimumFractionDigits, maximumFractionDigits, round, roundIncrement );\n\t}\n\n\t// Compact mode: apply formatting\n\tif ( compactMap && compactPattern ) {\n\n\t\t// Get plural form after possible roundings\n\t\tpluralForm = pluralGenerator ? pluralGenerator( +number ) : \"other\";\n\n\t\tcompactPattern = compactMap[ numberExponent ][ pluralForm ] || compactPattern;\n\t\tcompactProperties = compactPattern.match( numberCompactPatternRe );\n\n\t\t// TODO Move the tokenization of all parts that don't depend on number into\n\t\t// format-properties.\n\t\taux = function( string ) {\n\t\t\tvar parts = [];\n\t\t\tstring.replace( /(\\s+)|([^\\s0]+)/g, function( garbage, space, compact ) {\n\n\t\t\t\t// Literals\n\t\t\t\tif ( space ) {\n\t\t\t\t\tpartsPush( parts, \"literal\", space );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Compact value\n\t\t\t\tif ( compact ) {\n\t\t\t\t\tpartsPush( parts, \"compact\", compact );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn parts;\n\t\t};\n\n\t\t// update prefix/suffix with compact prefix/suffix\n\t\tprefix = prefix.concat( aux( compactProperties[ 1 ] ) );\n\t\tsuffix = aux( compactProperties[ 3 ] ).concat( suffix );\n\t}\n\n\t// Remove the possible number minus sign\n\tnumber = number.replace( /^-/, \"\" );\n\n\t// Grouping separators\n\tif ( primaryGroupingSize ) {\n\t\tnumber = numberFormatGroupingSeparator( number, primaryGroupingSize,\n\t\t\tsecondaryGroupingSize );\n\t}\n\n\t// Scientific notation\n\t// TODO implement here\n\n\t// Padding/'([^']|'')+'|''|[.,\\-+E%\\u2030]/g\n\t// TODO implement here\n\n\treturn prefix.concat(\n\t\tstringToParts( number ),\n\t\tsuffix\n\t);\n};\n\n\n\n\nvar numberFormatterFn = function( numberToPartsFormatter ) {\n\treturn function numberFormatter( value ) {\n\t\treturn partsJoin( numberToPartsFormatter( value ));\n\t};\n};\n\n\n\n\n/**\n * Generated by:\n *\n * var regenerate = require( \"regenerate\" );\n * var formatSymbols = require( * \"unicode-8.0.0/General_Category/Format/symbols\" );\n * regenerate().add( formatSymbols ).toString();\n *\n * https://github.com/mathiasbynens/regenerate\n * https://github.com/mathiasbynens/unicode-8.0.0\n */\nvar regexpCfG = /[\\xAD\\u0600-\\u0605\\u061C\\u06DD\\u070F\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u2064\\u2066-\\u206F\\uFEFF\\uFFF9-\\uFFFB]|\\uD804\\uDCBD|\\uD82F[\\uDCA0-\\uDCA3]|\\uD834[\\uDD73-\\uDD7A]|\\uDB40[\\uDC01\\uDC20-\\uDC7F]/g;\n\n\n\n\n/**\n * Generated by:\n *\n * var regenerate = require( \"regenerate\" );\n * var dashSymbols = require( * \"unicode-8.0.0/General_Category/Dash_Punctuation/symbols\" );\n * regenerate().add( dashSymbols ).toString();\n *\n * https://github.com/mathiasbynens/regenerate\n * https://github.com/mathiasbynens/unicode-8.0.0\n *\n * NOTE: In addition to [:dash:],  the below includes MINUS SIGN U+2212.\n */\nvar regexpDashG = /[\\-\\u058A\\u05BE\\u1400\\u1806\\u2010-\\u2015\\u2E17\\u2E1A\\u2E3A\\u2E3B\\u2E40\\u301C\\u3030\\u30A0\\uFE31\\uFE32\\uFE58\\uFE63\\uFF0D\\u2212]/g;\n\n\n\n\n/**\n * Generated by:\n *\n * var regenerate = require( \"regenerate\" );\n * var spaceSeparatorSymbols = require( \"unicode-8.0.0/General_Category/Space_Separator/symbols\" );\n * regenerate().add( spaceSeparatorSymbols ).toString();\n *\n * https://github.com/mathiasbynens/regenerate\n * https://github.com/mathiasbynens/unicode-8.0.0\n */\nvar regexpZsG = /[ \\xA0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]/g;\n\n\n\n\n/**\n * Loose Matching:\n * - Ignore all format characters, which includes RLM, LRM or ALM used to control BIDI\n *   formatting.\n * - Map all characters in [:Zs:] to U+0020 SPACE;\n * - Map all characters in [:Dash:] to U+002D HYPHEN-MINUS;\n */\nvar looseMatching = function( value ) {\n\treturn value\n\t\t.replace( regexpCfG, \"\" )\n\t\t.replace( regexpDashG, \"-\" )\n\t\t.replace( regexpZsG, \" \" );\n};\n\n\n\n\n/**\n * parse( value, properties )\n *\n * @value [String].\n *\n * @properties [Object] Parser properties is a reduced pre-processed cldr\n * data set returned by numberParserProperties().\n *\n * Return the parsed Number (including Infinity) or NaN when value is invalid.\n * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\n */\nvar numberParse = function( value, properties ) {\n\tvar grammar, invertedNuDigitsMap, invertedSymbolMap, negative, number, prefix, prefixNSuffix,\n\t\tsuffix, tokenizer, valid;\n\n\t// Grammar:\n\t// - Value <=           NaN | PositiveNumber | NegativeNumber\n\t// - PositiveNumber <=  PositivePrefix NumberOrInf PositiveSufix\n\t// - NegativeNumber <=  NegativePrefix NumberOrInf\n\t// - NumberOrInf <=     Number | Inf\n\tgrammar = [\n\t\t[ \"nan\" ],\n\t\t[ \"prefix\", \"infinity\", \"suffix\" ],\n\t\t[ \"prefix\", \"number\", \"suffix\" ],\n\t\t[ \"negativePrefix\", \"infinity\", \"negativeSuffix\" ],\n\t\t[ \"negativePrefix\", \"number\", \"negativeSuffix\" ]\n\t];\n\n\tinvertedSymbolMap = properties[ 0 ];\n\tinvertedNuDigitsMap = properties[ 1 ] || {};\n\ttokenizer = properties[ 2 ];\n\n\tvalue = looseMatching( value );\n\n\tfunction parse( type ) {\n\t\treturn function( lexeme ) {\n\n\t\t\t// Reverse localized symbols and numbering system.\n\t\t\tlexeme = lexeme.split( \"\" ).map(function( character ) {\n\t\t\t\treturn invertedSymbolMap[ character ] ||\n\t\t\t\t\tinvertedNuDigitsMap[ character ] ||\n\t\t\t\t\tcharacter;\n\t\t\t}).join( \"\" );\n\n\t\t\tswitch ( type ) {\n\t\t\t\tcase \"infinity\":\n\t\t\t\t\tnumber = Infinity;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"nan\":\n\t\t\t\t\tnumber = NaN;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"number\":\n\n\t\t\t\t\t// Remove grouping separators.\n\t\t\t\t\tlexeme = lexeme.replace( /,/g, \"\" );\n\n\t\t\t\t\tnumber = +lexeme;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"prefix\":\n\t\t\t\tcase \"negativePrefix\":\n\t\t\t\t\tprefix = lexeme;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"suffix\":\n\t\t\t\t\tsuffix = lexeme;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"negativeSuffix\":\n\t\t\t\t\tsuffix = lexeme;\n\t\t\t\t\tnegative = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t// This should never be reached.\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( \"Internal error\" );\n\t\t\t}\n\t\t\treturn \"\";\n\t\t};\n\t}\n\n\tfunction tokenizeNParse( _value, grammar ) {\n\t\treturn grammar.some(function( statement ) {\n\t\t\tvar value = _value;\n\n\t\t\t// The whole grammar statement should be used (i.e., .every() return true) and value be\n\t\t\t// entirely consumed (i.e., !value.length).\n\t\t\treturn statement.every(function( type ) {\n\t\t\t\tif ( value.match( tokenizer[ type ] ) === null ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Consume and parse it.\n\t\t\t\tvalue = value.replace( tokenizer[ type ], parse( type ) );\n\t\t\t\treturn true;\n\t\t\t}) && !value.length;\n\t\t});\n\t}\n\n\tvalid = tokenizeNParse( value, grammar );\n\n\t// NaN\n\tif ( !valid || isNaN( number ) ) {\n\t\treturn NaN;\n\t}\n\n\tprefixNSuffix = \"\" + prefix + suffix;\n\n\t// Percent\n\tif ( prefixNSuffix.indexOf( \"%\" ) !== -1 ) {\n\t\tnumber /= 100;\n\n\t// Per mille\n\t} else if ( prefixNSuffix.indexOf( \"\\u2030\" ) !== -1 ) {\n\t\tnumber /= 1000;\n\t}\n\n\t// Negative number\n\tif ( negative ) {\n\t\tnumber *= -1;\n\t}\n\n\treturn number;\n};\n\n\n\n\nvar numberParserFn = function( properties ) {\n\treturn function numberParser( value ) {\n\t\tvalidateParameterPresence( value, \"value\" );\n\t\tvalidateParameterTypeString( value, \"value\" );\n\n\t\treturn numberParse( value, properties );\n\t};\n\n};\n\n\n\n\nvar numberToPartsFormatterFn = function( properties, pluralGenerator ) {\n\treturn function numberToPartsFormatter( value ) {\n\t\tvalidateParameterPresence( value, \"value\" );\n\t\tvalidateParameterTypeNumber( value, \"value\" );\n\n\t\treturn numberFormat( value, properties, pluralGenerator );\n\t};\n};\n\n\n\n\nvar numberTruncate = function( value ) {\n\tif ( isNaN( value ) ) {\n\t\treturn NaN;\n\t}\n\treturn Math[ value < 0 ? \"ceil\" : \"floor\" ]( value );\n};\n\n\n\n\n/**\n * round( method )\n *\n * @method [String] with either \"round\", \"ceil\", \"floor\", or \"truncate\".\n *\n * Return function( value, incrementOrExp ):\n *\n *   @value [Number] eg. 123.45.\n *\n *   @incrementOrExp [Number] optional, eg. 0.1; or\n *     [Object] Either { increment: <value> } or { exponent: <value> }\n *\n *   Return the rounded number, eg:\n *   - round( \"round\" )( 123.45 ): 123;\n *   - round( \"ceil\" )( 123.45 ): 124;\n *   - round( \"floor\" )( 123.45 ): 123;\n *   - round( \"truncate\" )( 123.45 ): 123;\n *   - round( \"round\" )( 123.45, 0.1 ): 123.5;\n *   - round( \"round\" )( 123.45, 10 ): 120;\n *\n *   Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round\n *   Ref: #376\n */\nvar numberRound = function( method ) {\n\tmethod = method || \"round\";\n\tmethod = method === \"truncate\" ? numberTruncate : Math[ method ];\n\n\treturn function( value, incrementOrExp ) {\n\t\tvar exp, increment;\n\n\t\tvalue = +value;\n\n\t\t// If the value is not a number, return NaN.\n\t\tif ( isNaN( value ) ) {\n\t\t\treturn NaN;\n\t\t}\n\n\t\t// Exponent given.\n\t\tif ( typeof incrementOrExp === \"object\" && incrementOrExp.exponent ) {\n\t\t\texp = +incrementOrExp.exponent;\n\t\t\tincrement = 1;\n\n\t\t\tif ( exp === 0 ) {\n\t\t\t\treturn method( value );\n\t\t\t}\n\n\t\t\t// If the exp is not an integer, return NaN.\n\t\t\tif ( !( typeof exp === \"number\" && exp % 1 === 0 ) ) {\n\t\t\t\treturn NaN;\n\t\t\t}\n\n\t\t// Increment given.\n\t\t} else {\n\t\t\tincrement = +incrementOrExp || 1;\n\n\t\t\tif ( increment === 1 ) {\n\t\t\t\treturn method( value );\n\t\t\t}\n\n\t\t\t// If the increment is not a number, return NaN.\n\t\t\tif ( isNaN( increment ) ) {\n\t\t\t\treturn NaN;\n\t\t\t}\n\n\t\t\tincrement = increment.toExponential().split( \"e\" );\n\t\t\texp = +increment[ 1 ];\n\t\t\tincrement = +increment[ 0 ];\n\t\t}\n\n\t\t// Shift & Round\n\t\tvalue = value.toString().split( \"e\" );\n\t\tvalue[ 0 ] = +value[ 0 ] / increment;\n\t\tvalue[ 1 ] = value[ 1 ] ? ( +value[ 1 ] - exp ) : -exp;\n\t\tvalue = method( +( value[ 0 ] + \"e\" + value[ 1 ] ) );\n\n\t\t// Shift back\n\t\tvalue = value.toString().split( \"e\" );\n\t\tvalue[ 0 ] = +value[ 0 ] * increment;\n\t\tvalue[ 1 ] = value[ 1 ] ? ( +value[ 1 ] + exp ) : exp;\n\t\treturn +( value[ 0 ] + \"e\" + value[ 1 ] );\n\t};\n};\n\n\n\n\nGlobalize._createErrorUnsupportedFeature = createErrorUnsupportedFeature;\nGlobalize._looseMatching = looseMatching;\nGlobalize._numberFormat = numberFormat;\nGlobalize._numberFormatterFn = numberFormatterFn;\nGlobalize._numberParse = numberParse;\nGlobalize._numberParserFn = numberParserFn;\nGlobalize._numberRound = numberRound;\nGlobalize._numberToPartsFormatterFn = numberToPartsFormatterFn;\nGlobalize._removeLiteralQuotes = removeLiteralQuotes;\nGlobalize._validateParameterPresence = validateParameterPresence;\nGlobalize._validateParameterTypeNumber = validateParameterTypeNumber;\nGlobalize._validateParameterTypeString = validateParameterTypeString;\n\n// Stamp runtimeKey and return cached fn.\n// Note, this function isn't made common to all formatters and parsers, because in practice this is\n// only used (at the moment) for numberFormatter used by unitFormatter.\n// TODO: Move this function into a common place when this is used by different formatters.\nfunction cached( runtimeKey ) {\n\tGlobalize[ runtimeKey ].runtimeKey = runtimeKey;\n\treturn Globalize[ runtimeKey ];\n}\n\nGlobalize.numberFormatter =\nGlobalize.prototype.numberFormatter = function( options ) {\n\toptions = options || {};\n\treturn cached( runtimeKey( \"numberFormatter\", this._locale, [ options ] ) );\n};\n\nGlobalize.numberToPartsFormatter =\nGlobalize.prototype.numberToPartsFormatter = function( options ) {\n\toptions = options || {};\n\treturn cached( runtimeKey( \"numberToPartsFormatter\", this._locale, [ options ] ) );\n};\n\nGlobalize.numberParser =\nGlobalize.prototype.numberParser = function( options ) {\n\toptions = options || {};\n\treturn Globalize[ runtimeKey( \"numberParser\", this._locale, [ options ] ) ];\n};\n\nGlobalize.formatNumber =\nGlobalize.prototype.formatNumber = function( value, options ) {\n\tvalidateParameterPresence( value, \"value\" );\n\tvalidateParameterTypeNumber( value, \"value\" );\n\n\treturn this.numberFormatter( options )( value );\n};\n\nGlobalize.formatNumberToParts =\nGlobalize.prototype.formatNumberToParts = function( value, options ) {\n\tvalidateParameterPresence( value, \"value\" );\n\tvalidateParameterTypeNumber( value, \"value\" );\n\n\treturn this.numberFormatter( options )( value );\n};\n\nGlobalize.parseNumber =\nGlobalize.prototype.parseNumber = function( value, options ) {\n\tvalidateParameterPresence( value, \"value\" );\n\tvalidateParameterTypeString( value, \"value\" );\n\n\treturn this.numberParser( options )( value );\n};\n\nreturn Globalize;\n\n\n\n\n}));\n"]},"metadata":{},"sourceType":"script"}