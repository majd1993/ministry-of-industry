{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Exports_1 = require(\"../../common/Exports\");\n\nvar Promise_1 = require(\"../../common/Promise\");\n\nvar Exports_2 = require(\"../../sdk/Exports\");\n\nvar Exports_3 = require(\"../Exports\");\n\nvar ConversationConnectionMessage_1 = require(\"./ConversationConnectionMessage\");\n\nvar ConversationRequestSession_1 = require(\"./ConversationRequestSession\");\n\nvar ConversationTranslatorEventArgs_1 = require(\"./ConversationTranslatorEventArgs\");\n\nvar ConversationTranslatorInterfaces_1 = require(\"./ConversationTranslatorInterfaces\");\n\nvar Exports_4 = require(\"./ServiceMessages/Exports\");\n/***\n * The service adapter handles sending and receiving messages to the Conversation Translator websocket.\n */\n\n\nvar ConversationServiceAdapter =\n/** @class */\nfunction (_super) {\n  __extends(ConversationServiceAdapter, _super);\n\n  function ConversationServiceAdapter(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector) {\n    var _this = _super.call(this, authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector) || this;\n\n    _this.privLastPartialUtteranceId = \"\";\n\n    _this.sendMessageAsync = function (message) {\n      var sink = new Promise_1.Sink();\n\n      _this.fetchConversationConnection().continueWith(function (antecedent) {\n        try {\n          if (antecedent.isError) {\n            sink.reject(antecedent.error);\n          } else {\n            antecedent.result.send(new ConversationConnectionMessage_1.ConversationConnectionMessage(Exports_1.MessageType.Text, message)).continueWith(function (innerAntecedent) {\n              try {\n                if (innerAntecedent.isError) {\n                  sink.reject(innerAntecedent.error);\n                } else {\n                  sink.resolve(innerAntecedent.result);\n                }\n              } catch (e) {\n                sink.reject(\"Unhandled inner error: \" + e);\n              }\n            });\n          }\n        } catch (e) {\n          sink.reject(\"Unhandled error: \" + e);\n        }\n      });\n\n      return new Exports_1.Promise(sink);\n    };\n\n    _this.noOp = function () {// operation not supported\n    };\n    /**\n     * Process incoming websocket messages\n     */\n\n\n    _this.receiveConversationMessageOverride = function (successCallback, errorCallBack) {\n      // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\n      var communicationCustodian = new Exports_1.Deferred();\n\n      _this.fetchConversationConnection().on(function (connection) {\n        return connection.read().onSuccessContinueWithPromise(function (message) {\n          var isDisposed = _this.isDisposed();\n\n          var terminateMessageLoop = !_this.isDisposed() && _this.terminateMessageLoop;\n          var sessionId = _this.privConversationRequestSession.sessionId;\n          var sendFinal = false;\n\n          if (isDisposed || terminateMessageLoop) {\n            // We're done.\n            communicationCustodian.resolve(undefined);\n            return Exports_1.PromiseHelper.fromResult(undefined);\n          }\n\n          if (!message) {\n            return _this.receiveConversationMessageOverride();\n          }\n\n          try {\n            switch (message.conversationMessageType.toLowerCase()) {\n              case \"info\":\n              case \"participant_command\":\n              case \"command\":\n                var commandPayload = Exports_4.CommandResponsePayload.fromJSON(message.textBody);\n\n                switch (commandPayload.command.toLowerCase()) {\n                  /**\n                   * 'ParticpantList' is the first message sent to the user after the websocket connection has opened.\n                   * The consuming client must wait for this message to arrive\n                   * before starting to send their own data.\n                   */\n                  case \"participantlist\":\n                    var participantsPayload = Exports_4.ParticipantsListPayloadResponse.fromJSON(message.textBody);\n                    var participantsResult = participantsPayload.participants.map(function (p) {\n                      var participant = {\n                        avatar: p.avatar,\n                        displayName: p.nickname,\n                        id: p.participantId,\n                        isHost: p.ishost,\n                        isMuted: p.ismuted,\n                        isUsingTts: p.usetts,\n                        preferredLanguage: p.locale\n                      };\n                      return participant;\n                    });\n\n                    if (!!_this.privConversationServiceConnector.participantsListReceived) {\n                      _this.privConversationServiceConnector.participantsListReceived(_this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantsListEventArgs(participantsPayload.roomid, participantsPayload.token, participantsPayload.translateTo, participantsPayload.profanityFilter, participantsPayload.roomProfanityFilter, participantsPayload.roomLocked, participantsPayload.muteAll, participantsResult, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'SetTranslateToLanguages' represents the list of languages being used in the Conversation by all users(?).\n                   * This is sent at the start of the Conversation\n                   */\n\n                  case \"settranslatetolanguages\":\n                    if (!!_this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                      _this.privConversationServiceConnector.participantUpdateCommandReceived(_this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorInterfaces_1.ConversationTranslatorCommandTypes.setTranslateToLanguages, commandPayload.value, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'SetProfanityFiltering' lets the client set the level of profanity filtering.\n                   * If sent by the participant the setting will effect only their own profanity level.\n                   * If sent by the host, the setting will effect all participants including the host.\n                   * Note: the profanity filters differ from Speech Service (?): 'marked', 'raw', 'removed', 'tagged'\n                   */\n\n                  case \"setprofanityfiltering\":\n                    if (!!_this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                      _this.privConversationServiceConnector.participantUpdateCommandReceived(_this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorInterfaces_1.ConversationTranslatorCommandTypes.setProfanityFiltering, commandPayload.value, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'SetMute' is sent if the participant has been muted by the host.\n                   * Check the 'participantId' to determine if the current user has been muted.\n                   */\n\n                  case \"setmute\":\n                    if (!!_this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                      _this.privConversationServiceConnector.participantUpdateCommandReceived(_this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorInterfaces_1.ConversationTranslatorCommandTypes.setMute, commandPayload.value, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'SetMuteAll' is sent if the Conversation has been muted by the host.\n                   */\n\n                  case \"setmuteall\":\n                    if (!!_this.privConversationServiceConnector.muteAllCommandReceived) {\n                      _this.privConversationServiceConnector.muteAllCommandReceived(_this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.MuteAllEventArgs(commandPayload.value, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'RoomExpirationWarning' is sent towards the end of the Conversation session to give a timeout warning.\n                   */\n\n                  case \"roomexpirationwarning\":\n                    if (!!_this.privConversationServiceConnector.conversationExpiration) {\n                      _this.privConversationServiceConnector.conversationExpiration(_this.privConversationServiceConnector, new Exports_2.ConversationExpirationEventArgs(commandPayload.value, _this.privConversationRequestSession.sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'SetUseTts' is sent as a confirmation if the user requests TTS to be turned on or off.\n                   */\n\n                  case \"setusetts\":\n                    if (!!_this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                      _this.privConversationServiceConnector.participantUpdateCommandReceived(_this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorInterfaces_1.ConversationTranslatorCommandTypes.setUseTTS, commandPayload.value, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'SetLockState' is set if the host has locked or unlocked the Conversation.\n                   */\n\n                  case \"setlockstate\":\n                    if (!!_this.privConversationServiceConnector.lockRoomCommandReceived) {\n                      _this.privConversationServiceConnector.lockRoomCommandReceived(_this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.LockRoomEventArgs(commandPayload.value, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'ChangeNickname' is received if a user changes their display name.\n                   * Any cached particpiants list should be updated to reflect the display name.\n                   */\n\n                  case \"changenickname\":\n                    if (!!_this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                      _this.privConversationServiceConnector.participantUpdateCommandReceived(_this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorInterfaces_1.ConversationTranslatorCommandTypes.changeNickname, commandPayload.nickname, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'JoinSession' is sent when a user joins the Conversation.\n                   */\n\n                  case \"joinsession\":\n                    var joinParticipantPayload = Exports_4.ParticipantPayloadResponse.fromJSON(message.textBody);\n                    var joiningParticipant = {\n                      avatar: joinParticipantPayload.avatar,\n                      displayName: joinParticipantPayload.nickname,\n                      id: joinParticipantPayload.participantId,\n                      isHost: joinParticipantPayload.ishost,\n                      isMuted: joinParticipantPayload.ismuted,\n                      isUsingTts: joinParticipantPayload.usetts,\n                      preferredLanguage: joinParticipantPayload.locale\n                    };\n\n                    if (!!_this.privConversationServiceConnector.participantJoinCommandReceived) {\n                      _this.privConversationServiceConnector.participantJoinCommandReceived(_this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantEventArgs(joiningParticipant, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'LeaveSession' is sent when a user leaves the Conversation'.\n                   */\n\n                  case \"leavesession\":\n                    var leavingParticipant = {\n                      id: commandPayload.participantId\n                    };\n\n                    if (!!_this.privConversationServiceConnector.participantLeaveCommandReceived) {\n                      _this.privConversationServiceConnector.participantLeaveCommandReceived(_this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantEventArgs(leavingParticipant, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'DisconnectSession' is sent when a user is disconnected from the session (e.g. network problem).\n                   * Check the 'ParticipantId' to check whether the message is for the current user.\n                   */\n\n                  case \"disconnectsession\":\n                    var disconnectParticipant = {\n                      id: commandPayload.participantId\n                    };\n                    break;\n\n                  /**\n                   * Message not recognized.\n                   */\n\n                  default:\n                    break;\n                }\n\n                break;\n\n              /**\n               * 'partial' (or 'hypothesis') represents a unfinalized speech message.\n               */\n\n              case \"partial\":\n              /**\n               * 'final' (or 'phrase') represents a finalized speech message.\n               */\n\n              case \"final\":\n                var speechPayload = Exports_4.SpeechResponsePayload.fromJSON(message.textBody);\n                var speechResult = new Exports_2.ConversationTranslationResult(speechPayload.participantId, _this.getTranslations(speechPayload.translations), speechPayload.language, undefined, undefined, speechPayload.recognition, undefined, undefined, message.textBody, undefined);\n\n                if (speechPayload.isFinal) {\n                  // check the length, sometimes empty finals are returned\n                  if (speechResult.text !== undefined && speechResult.text.length > 0) {\n                    sendFinal = true;\n                  } else if (speechPayload.id === _this.privLastPartialUtteranceId) {\n                    // send final as normal. We had a non-empty partial for this same utterance\n                    // so sending the empty final is important\n                    sendFinal = true;\n                  } else {// suppress unneeded final\n                  }\n\n                  if (sendFinal) {\n                    if (!!_this.privConversationServiceConnector.translationReceived) {\n                      _this.privConversationServiceConnector.translationReceived(_this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ConversationReceivedTranslationEventArgs(ConversationTranslatorInterfaces_1.ConversationTranslatorMessageTypes.final, speechResult, sessionId));\n                    }\n                  }\n                } else if (speechResult.text !== undefined) {\n                  _this.privLastPartialUtteranceId = speechPayload.id;\n\n                  if (!!_this.privConversationServiceConnector.translationReceived) {\n                    _this.privConversationServiceConnector.translationReceived(_this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ConversationReceivedTranslationEventArgs(ConversationTranslatorInterfaces_1.ConversationTranslatorMessageTypes.partial, speechResult, sessionId));\n                  }\n                }\n\n                break;\n\n              /**\n               * \"translated_message\" is a text message or instant message (IM).\n               */\n\n              case \"translated_message\":\n                var textPayload = Exports_4.TextResponsePayload.fromJSON(message.textBody);\n                var textResult = new Exports_2.ConversationTranslationResult(textPayload.participantId, _this.getTranslations(textPayload.translations), textPayload.language, undefined, undefined, textPayload.originalText, undefined, undefined, undefined, message.textBody, undefined);\n\n                if (!!_this.privConversationServiceConnector.translationReceived) {\n                  _this.privConversationServiceConnector.translationReceived(_this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ConversationReceivedTranslationEventArgs(ConversationTranslatorInterfaces_1.ConversationTranslatorMessageTypes.instantMessage, textResult, sessionId));\n                }\n\n                break;\n\n              default:\n                // ignore any unsupported message types\n                break;\n            }\n          } catch (e) {// continue\n          }\n\n          return _this.receiveConversationMessageOverride();\n        });\n      }, function (error) {\n        _this.terminateMessageLoop = true;\n      });\n\n      return communicationCustodian.promise();\n    };\n\n    _this.fetchConversationConnection = function () {\n      return _this.configConnection();\n    };\n\n    _this.privConversationServiceConnector = conversationServiceConnector;\n    _this.privConversationAuthentication = authentication;\n    _this.receiveMessageOverride = _this.receiveConversationMessageOverride;\n    _this.recognizeOverride = _this.noOp;\n    _this.connectImplOverride = _this.conversationConnectImpl;\n    _this.configConnectionOverride = _this.configConnection;\n    _this.fetchConnectionOverride = _this.fetchConversationConnection;\n    _this.disconnectOverride = _this.privDisconnect;\n    _this.privConversationRequestSession = new ConversationRequestSession_1.ConversationRequestSession(Exports_1.createNoDashGuid());\n    _this.privConversationConnectionFactory = connectionFactory;\n    _this.privConversationIsDisposed = false;\n    return _this;\n  }\n\n  ConversationServiceAdapter.prototype.isDisposed = function () {\n    return this.privConversationIsDisposed;\n  };\n\n  ConversationServiceAdapter.prototype.dispose = function (reason) {\n    this.privConversationIsDisposed = true;\n\n    if (this.privConnectionConfigPromise) {\n      this.privConnectionConfigPromise.onSuccessContinueWith(function (connection) {\n        connection.dispose(reason);\n      });\n    }\n  };\n\n  ConversationServiceAdapter.prototype.sendMessage = function (message) {\n    this.fetchConversationConnection().onSuccessContinueWith(function (connection) {\n      connection.send(new ConversationConnectionMessage_1.ConversationConnectionMessage(Exports_1.MessageType.Text, message));\n    });\n  };\n\n  ConversationServiceAdapter.prototype.privDisconnect = function () {\n    if (this.terminateMessageLoop) {\n      return;\n    }\n\n    this.cancelRecognition(this.privConversationRequestSession.sessionId, this.privConversationRequestSession.requestId, Exports_2.CancellationReason.Error, Exports_2.CancellationErrorCode.NoError, \"Disconnecting\");\n    this.terminateMessageLoop = true;\n\n    if (this.privConversationConnectionPromise.result().isCompleted) {\n      if (!this.privConversationConnectionPromise.result().isError) {\n        this.privConversationConnectionPromise.result().result.dispose();\n        this.privConversationConnectionPromise = null;\n      }\n    } else {\n      this.privConversationConnectionPromise.onSuccessContinueWith(function (connection) {\n        connection.dispose();\n      });\n    }\n  };\n\n  ConversationServiceAdapter.prototype.processTypeSpecificMessages = function (connectionMessage, successCallback, errorCallBack) {\n    return true;\n  }; // Cancels recognition.\n\n\n  ConversationServiceAdapter.prototype.cancelRecognition = function (sessionId, requestId, cancellationReason, errorCode, error) {\n    this.terminateMessageLoop = true;\n    var cancelEvent = new Exports_2.ConversationTranslationCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);\n\n    try {\n      if (!!this.privConversationServiceConnector.canceled) {\n        this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, cancelEvent);\n      }\n    } catch (_a) {// continue on error\n    }\n  };\n  /**\n   * Establishes a websocket connection to the end point.\n   * @param isUnAuthorized\n   */\n\n\n  ConversationServiceAdapter.prototype.conversationConnectImpl = function (isUnAuthorized) {\n    var _this = this;\n\n    if (isUnAuthorized === void 0) {\n      isUnAuthorized = false;\n    }\n\n    if (this.privConversationConnectionPromise) {\n      if (this.privConversationConnectionPromise.result().isCompleted && (this.privConversationConnectionPromise.result().isError || this.privConversationConnectionPromise.result().result.state() === Exports_1.ConnectionState.Disconnected)) {\n        this.privConnectionId = null;\n        this.privConversationConnectionPromise = null;\n        this.terminateMessageLoop = true;\n        return this.conversationConnectImpl();\n      } else {\n        return this.privConversationConnectionPromise;\n      }\n    }\n\n    this.privConversationAuthFetchEventId = Exports_1.createNoDashGuid(); // keep the connectionId for reconnect events\n\n    if (this.privConnectionId === undefined) {\n      this.privConnectionId = Exports_1.createNoDashGuid();\n    }\n\n    this.privConversationRequestSession.onPreConnectionStart(this.privConversationAuthFetchEventId, this.privConnectionId);\n    var authPromise = isUnAuthorized ? this.privConversationAuthentication.fetchOnExpiry(this.privConversationAuthFetchEventId) : this.privConversationAuthentication.fetch(this.privConversationAuthFetchEventId);\n    this.privConversationConnectionPromise = authPromise.continueWithPromise(function (result) {\n      if (result.isError) {\n        _this.privConversationRequestSession.onAuthCompleted(true, result.error);\n\n        throw new Error(result.error);\n      } else {\n        _this.privConversationRequestSession.onAuthCompleted(false);\n      }\n\n      var connection = _this.privConversationConnectionFactory.create(_this.privRecognizerConfig, result.result, _this.privConnectionId); // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\n      // it'll stop sending events.\n\n\n      connection.events.attach(function (event) {\n        _this.connectionEvents.onEvent(event);\n      });\n      return connection.open().onSuccessContinueWithPromise(function (response) {\n        if (response.statusCode === 200) {\n          _this.privConversationRequestSession.onPreConnectionStart(_this.privConversationAuthFetchEventId, _this.privConnectionId);\n\n          _this.privConversationRequestSession.onConnectionEstablishCompleted(response.statusCode);\n\n          var sessionStartEventArgs = new Exports_2.SessionEventArgs(_this.privConversationRequestSession.sessionId);\n\n          if (!!_this.privConversationServiceConnector.connectionOpened) {\n            _this.privConversationServiceConnector.connectionOpened(_this.privConversationServiceConnector, sessionStartEventArgs);\n          }\n\n          return Exports_1.PromiseHelper.fromResult(connection);\n        } else if (response.statusCode === 403 && !isUnAuthorized) {\n          return _this.conversationConnectImpl(true);\n        } else {\n          _this.privConversationRequestSession.onConnectionEstablishCompleted(response.statusCode, response.reason);\n\n          return Exports_1.PromiseHelper.fromError(\"Unable to contact server. StatusCode: \" + response.statusCode + \", \" + _this.privRecognizerConfig.parameters.getProperty(Exports_2.PropertyId.SpeechServiceConnection_Endpoint) + \" Reason: \" + response.reason);\n        }\n      });\n    });\n    this.privConnectionLoop = this.startMessageLoop();\n    return this.privConversationConnectionPromise;\n  };\n\n  ConversationServiceAdapter.prototype.startMessageLoop = function () {\n    var _this = this;\n\n    this.terminateMessageLoop = false;\n    var messageRetrievalPromise = this.receiveConversationMessageOverride();\n    return messageRetrievalPromise.on(function (r) {\n      return true;\n    }, function (error) {\n      _this.cancelRecognition(_this.privRequestSession ? _this.privRequestSession.sessionId : \"\", _this.privRequestSession ? _this.privRequestSession.requestId : \"\", Exports_2.CancellationReason.Error, Exports_2.CancellationErrorCode.RuntimeError, error);\n    });\n  }; // Takes an established websocket connection to the endpoint\n\n\n  ConversationServiceAdapter.prototype.configConnection = function () {\n    if (this.privConnectionConfigPromise) {\n      if (this.privConnectionConfigPromise.result().isCompleted && (this.privConnectionConfigPromise.result().isError || this.privConnectionConfigPromise.result().result.state() === Exports_1.ConnectionState.Disconnected)) {\n        this.privConnectionConfigPromise = null;\n        return this.configConnection();\n      } else {\n        return this.privConnectionConfigPromise;\n      }\n    }\n\n    if (this.terminateMessageLoop) {\n      return Exports_1.PromiseHelper.fromResult(undefined);\n    }\n\n    this.privConnectionConfigPromise = this.conversationConnectImpl().onSuccessContinueWith(function (connection) {\n      return connection;\n    });\n    return this.privConnectionConfigPromise;\n  };\n\n  ConversationServiceAdapter.prototype.getTranslations = function (serviceResultTranslations) {\n    var translations;\n\n    if (undefined !== serviceResultTranslations) {\n      translations = new Exports_2.Translations();\n\n      for (var _i = 0, serviceResultTranslations_1 = serviceResultTranslations; _i < serviceResultTranslations_1.length; _i++) {\n        var translation = serviceResultTranslations_1[_i];\n        translations.set(translation.lang, translation.translation);\n      }\n    }\n\n    return translations;\n  };\n\n  return ConversationServiceAdapter;\n}(Exports_3.ServiceRecognizerBase);\n\nexports.ConversationServiceAdapter = ConversationServiceAdapter;","map":{"version":3,"sources":["src/common.speech/Transcription/ConversationServiceAdapter.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ConnectionEvent,\r\n    ConnectionMessage,\r\n    ConnectionOpenResponse,\r\n    ConnectionState,\r\n    createNoDashGuid,\r\n    Deferred,\r\n    IAudioSource,\r\n    IConnection,\r\n    MessageType,\r\n    Promise,\r\n    PromiseHelper,\r\n    PromiseResult\r\n} from \"../../common/Exports\";\r\nimport { Sink } from \"../../common/Promise\";\r\nimport {\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    ConversationExpirationEventArgs,\r\n    ConversationTranslationCanceledEventArgs,\r\n    ConversationTranslationResult,\r\n    PropertyId,\r\n    SessionEventArgs,\r\n    SpeechRecognitionResult,\r\n    Translations\r\n} from \"../../sdk/Exports\";\r\nimport {\r\n    AuthInfo, IAuthentication, IConnectionFactory, RecognizerConfig, ServiceRecognizerBase\r\n} from \"../Exports\";\r\nimport { ConversationConnectionMessage } from \"./ConversationConnectionMessage\";\r\nimport { ConversationRequestSession } from \"./ConversationRequestSession\";\r\nimport {\r\n    ConversationReceivedTranslationEventArgs,\r\n    LockRoomEventArgs,\r\n    MuteAllEventArgs,\r\n    ParticipantAttributeEventArgs,\r\n    ParticipantEventArgs,\r\n    ParticipantsListEventArgs\r\n} from \"./ConversationTranslatorEventArgs\";\r\nimport { ConversationTranslatorCommandTypes, ConversationTranslatorMessageTypes, IInternalParticipant } from \"./ConversationTranslatorInterfaces\";\r\nimport { ConversationTranslatorRecognizer } from \"./ConversationTranslatorRecognizer\";\r\nimport {\r\n    CommandResponsePayload,\r\n    IParticipantPayloadResponse,\r\n    IParticipantsListPayloadResponse,\r\n    ITranslationResponsePayload,\r\n    ParticipantPayloadResponse,\r\n    ParticipantsListPayloadResponse,\r\n    SpeechResponsePayload,\r\n    TextResponsePayload\r\n} from \"./ServiceMessages/Exports\";\r\n\r\n/***\r\n * The service adapter handles sending and receiving messages to the Conversation Translator websocket.\r\n */\r\nexport class ConversationServiceAdapter extends ServiceRecognizerBase {\r\n    private privConversationServiceConnector: ConversationTranslatorRecognizer;\r\n    private privConversationConnectionFactory: IConnectionFactory;\r\n    private privConversationAuthFetchEventId: string;\r\n    private privConversationAuthentication: IAuthentication;\r\n    private privConversationRequestSession: ConversationRequestSession;\r\n    private privConnectionConfigPromise: Promise<IConnection>;\r\n    private privConversationConnectionPromise: Promise<IConnection>;\r\n    private privConnectionLoop: Promise<IConnection>;\r\n    private terminateMessageLoop: boolean;\r\n    private privLastPartialUtteranceId: string = \"\";\r\n    private privConversationIsDisposed: boolean;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: IConnectionFactory,\r\n        audioSource: IAudioSource,\r\n        recognizerConfig: RecognizerConfig,\r\n        conversationServiceConnector: ConversationTranslatorRecognizer) {\r\n\r\n        super(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector);\r\n\r\n        this.privConversationServiceConnector = conversationServiceConnector;\r\n        this.privConversationAuthentication = authentication;\r\n        this.receiveMessageOverride = this.receiveConversationMessageOverride;\r\n        this.recognizeOverride = this.noOp;\r\n        this.connectImplOverride = this.conversationConnectImpl;\r\n        this.configConnectionOverride = this.configConnection;\r\n        this.fetchConnectionOverride = this.fetchConversationConnection;\r\n        this.disconnectOverride = this.privDisconnect;\r\n        this.privConversationRequestSession = new ConversationRequestSession(createNoDashGuid());\r\n        this.privConversationConnectionFactory = connectionFactory;\r\n        this.privConversationIsDisposed = false;\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return this.privConversationIsDisposed;\r\n    }\r\n\r\n    public dispose(reason?: string): void {\r\n        this.privConversationIsDisposed = true;\r\n        if (this.privConnectionConfigPromise) {\r\n            this.privConnectionConfigPromise.onSuccessContinueWith((connection: IConnection) => {\r\n                connection.dispose(reason);\r\n            });\r\n        }\r\n    }\r\n\r\n    public sendMessage(message: string): void {\r\n        this.fetchConversationConnection().onSuccessContinueWith((connection: IConnection) => {\r\n            connection.send(new ConversationConnectionMessage(\r\n                MessageType.Text,\r\n                message));\r\n        });\r\n    }\r\n\r\n    public sendMessageAsync = (message: string): Promise<boolean> => {\r\n        const sink: Sink<boolean> = new Sink<boolean>();\r\n\r\n        this.fetchConversationConnection().continueWith((antecedent: PromiseResult<IConnection>): void => {\r\n            try {\r\n                if (antecedent.isError) {\r\n                    sink.reject(antecedent.error);\r\n                } else {\r\n                    antecedent.result.send(new ConversationConnectionMessage(MessageType.Text, message))\r\n                        .continueWith((innerAntecedent: PromiseResult<boolean>): void => {\r\n                            try {\r\n                                if (innerAntecedent.isError) {\r\n                                    sink.reject(innerAntecedent.error);\r\n                                } else {\r\n                                    sink.resolve(innerAntecedent.result);\r\n                                }\r\n                            } catch (e) {\r\n                                sink.reject(`Unhandled inner error: ${e}`);\r\n                            }\r\n                        });\r\n                }\r\n            } catch (e) {\r\n                sink.reject(`Unhandled error: ${e}`);\r\n            }\r\n        });\r\n\r\n        return new Promise<boolean>(sink);\r\n    }\r\n\r\n    protected privDisconnect(): void {\r\n        if (this.terminateMessageLoop) {\r\n            return;\r\n        }\r\n        this.cancelRecognition(this.privConversationRequestSession.sessionId,\r\n            this.privConversationRequestSession.requestId,\r\n            CancellationReason.Error,\r\n            CancellationErrorCode.NoError,\r\n            \"Disconnecting\");\r\n\r\n        this.terminateMessageLoop = true;\r\n        if (this.privConversationConnectionPromise.result().isCompleted) {\r\n            if (!this.privConversationConnectionPromise.result().isError) {\r\n                this.privConversationConnectionPromise.result().result.dispose();\r\n                this.privConversationConnectionPromise = null;\r\n            }\r\n        } else {\r\n            this.privConversationConnectionPromise.onSuccessContinueWith((connection: IConnection) => {\r\n                connection.dispose();\r\n            });\r\n        }\r\n    }\r\n\r\n    protected processTypeSpecificMessages(\r\n        connectionMessage: ConnectionMessage,\r\n        successCallback?: (e: any) => void,\r\n        errorCallBack?: (e: string) => void): boolean {\r\n        return true;\r\n    }\r\n\r\n    // Cancels recognition.\r\n    protected cancelRecognition(\r\n        sessionId: string,\r\n        requestId: string,\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void {\r\n\r\n        this.terminateMessageLoop = true;\r\n\r\n        const cancelEvent: ConversationTranslationCanceledEventArgs = new ConversationTranslationCanceledEventArgs(\r\n            cancellationReason,\r\n            error,\r\n            errorCode,\r\n            undefined,\r\n            sessionId);\r\n\r\n        try {\r\n            if (!!this.privConversationServiceConnector.canceled) {\r\n                this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, cancelEvent);\r\n            }\r\n        } catch {\r\n            // continue on error\r\n        }\r\n    }\r\n\r\n    protected noOp = (): any => {\r\n        // operation not supported\r\n    }\r\n\r\n    /**\r\n     * Establishes a websocket connection to the end point.\r\n     * @param isUnAuthorized\r\n     */\r\n    protected conversationConnectImpl(isUnAuthorized: boolean = false): Promise<IConnection> {\r\n\r\n        if (this.privConversationConnectionPromise) {\r\n            if (this.privConversationConnectionPromise.result().isCompleted &&\r\n                (this.privConversationConnectionPromise.result().isError\r\n                    || this.privConversationConnectionPromise.result().result.state() === ConnectionState.Disconnected)) {\r\n                this.privConnectionId = null;\r\n                this.privConversationConnectionPromise = null;\r\n                this.terminateMessageLoop = true;\r\n                return this.conversationConnectImpl();\r\n            } else {\r\n                return this.privConversationConnectionPromise;\r\n            }\r\n        }\r\n\r\n        this.privConversationAuthFetchEventId = createNoDashGuid();\r\n\r\n        // keep the connectionId for reconnect events\r\n        if (this.privConnectionId === undefined) {\r\n            this.privConnectionId = createNoDashGuid();\r\n        }\r\n\r\n        this.privConversationRequestSession.onPreConnectionStart(this.privConversationAuthFetchEventId, this.privConnectionId);\r\n\r\n        const authPromise = isUnAuthorized ? this.privConversationAuthentication.fetchOnExpiry(this.privConversationAuthFetchEventId) : this.privConversationAuthentication.fetch(this.privConversationAuthFetchEventId);\r\n\r\n        this.privConversationConnectionPromise = authPromise\r\n            .continueWithPromise((result: PromiseResult<AuthInfo>) => {\r\n                if (result.isError) {\r\n                    this.privConversationRequestSession.onAuthCompleted(true, result.error);\r\n                    throw new Error(result.error);\r\n                } else {\r\n                    this.privConversationRequestSession.onAuthCompleted(false);\r\n                }\r\n\r\n                const connection: IConnection = this.privConversationConnectionFactory.create(this.privRecognizerConfig, result.result, this.privConnectionId);\r\n\r\n                // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\r\n                // it'll stop sending events.\r\n                connection.events.attach((event: ConnectionEvent) => {\r\n                    this.connectionEvents.onEvent(event);\r\n                });\r\n\r\n                return connection.open().onSuccessContinueWithPromise((response: ConnectionOpenResponse): Promise<IConnection> => {\r\n                    if (response.statusCode === 200) {\r\n                        this.privConversationRequestSession.onPreConnectionStart(this.privConversationAuthFetchEventId, this.privConnectionId);\r\n                        this.privConversationRequestSession.onConnectionEstablishCompleted(response.statusCode);\r\n                        const sessionStartEventArgs: SessionEventArgs = new SessionEventArgs(this.privConversationRequestSession.sessionId);\r\n                        if (!!this.privConversationServiceConnector.connectionOpened) {\r\n                            this.privConversationServiceConnector.connectionOpened(this.privConversationServiceConnector, sessionStartEventArgs);\r\n                        }\r\n                        return PromiseHelper.fromResult<IConnection>(connection);\r\n                    } else if (response.statusCode === 403 && !isUnAuthorized) {\r\n                        return this.conversationConnectImpl(true);\r\n                    } else {\r\n                        this.privConversationRequestSession.onConnectionEstablishCompleted(response.statusCode, response.reason);\r\n                        return PromiseHelper.fromError<IConnection>(`Unable to contact server. StatusCode: ${response.statusCode}, ${this.privRecognizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${response.reason}`);\r\n                    }\r\n                });\r\n            });\r\n\r\n        this.privConnectionLoop = this.startMessageLoop();\r\n        return this.privConversationConnectionPromise;\r\n    }\r\n\r\n    /**\r\n     * Process incoming websocket messages\r\n     */\r\n    private receiveConversationMessageOverride = (\r\n        successCallback?: (e: any) => void,\r\n        errorCallBack?: (e: string) => void\r\n    ): Promise<IConnection> => {\r\n\r\n        // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\r\n        const communicationCustodian: Deferred<IConnection> = new Deferred<IConnection>();\r\n\r\n        this.fetchConversationConnection().on((connection: IConnection): Promise<IConnection> => {\r\n            return connection.read().onSuccessContinueWithPromise((message: ConversationConnectionMessage): Promise<IConnection> => {\r\n                const isDisposed: boolean = this.isDisposed();\r\n                const terminateMessageLoop = (!this.isDisposed() && this.terminateMessageLoop);\r\n                const sessionId: string = this.privConversationRequestSession.sessionId;\r\n                let sendFinal: boolean = false;\r\n                if (isDisposed || terminateMessageLoop) {\r\n                    // We're done.\r\n                    communicationCustodian.resolve(undefined);\r\n                    return PromiseHelper.fromResult<IConnection>(undefined);\r\n                }\r\n\r\n                if (!message) {\r\n                    return this.receiveConversationMessageOverride();\r\n                }\r\n\r\n                try {\r\n                    switch (message.conversationMessageType.toLowerCase()) {\r\n                        case \"info\":\r\n                        case \"participant_command\":\r\n                        case \"command\":\r\n                            const commandPayload: CommandResponsePayload = CommandResponsePayload.fromJSON(message.textBody);\r\n                            switch (commandPayload.command.toLowerCase()) {\r\n\r\n                                /**\r\n                                 * 'ParticpantList' is the first message sent to the user after the websocket connection has opened.\r\n                                 * The consuming client must wait for this message to arrive\r\n                                 * before starting to send their own data.\r\n                                 */\r\n                                case \"participantlist\":\r\n\r\n                                    const participantsPayload: IParticipantsListPayloadResponse = ParticipantsListPayloadResponse.fromJSON(message.textBody);\r\n\r\n                                    const participantsResult: IInternalParticipant[] = participantsPayload.participants.map((p: IParticipantPayloadResponse) => {\r\n                                        const participant: IInternalParticipant = {\r\n                                            avatar: p.avatar,\r\n                                            displayName: p.nickname,\r\n                                            id: p.participantId,\r\n                                            isHost: p.ishost,\r\n                                            isMuted: p.ismuted,\r\n                                            isUsingTts: p.usetts,\r\n                                            preferredLanguage: p.locale\r\n                                        };\r\n                                        return participant;\r\n                                    });\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantsListReceived) {\r\n                                        this.privConversationServiceConnector.participantsListReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantsListEventArgs(participantsPayload.roomid, participantsPayload.token,\r\n                                                participantsPayload.translateTo, participantsPayload.profanityFilter,\r\n                                                participantsPayload.roomProfanityFilter, participantsPayload.roomLocked,\r\n                                                participantsPayload.muteAll, participantsResult, sessionId));\r\n                                    }\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'SetTranslateToLanguages' represents the list of languages being used in the Conversation by all users(?).\r\n                                 * This is sent at the start of the Conversation\r\n                                 */\r\n                                case \"settranslatetolanguages\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                                ConversationTranslatorCommandTypes.setTranslateToLanguages,\r\n                                                commandPayload.value, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'SetProfanityFiltering' lets the client set the level of profanity filtering.\r\n                                 * If sent by the participant the setting will effect only their own profanity level.\r\n                                 * If sent by the host, the setting will effect all participants including the host.\r\n                                 * Note: the profanity filters differ from Speech Service (?): 'marked', 'raw', 'removed', 'tagged'\r\n                                 */\r\n                                case \"setprofanityfiltering\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                                ConversationTranslatorCommandTypes.setProfanityFiltering,\r\n                                                commandPayload.value, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'SetMute' is sent if the participant has been muted by the host.\r\n                                 * Check the 'participantId' to determine if the current user has been muted.\r\n                                 */\r\n                                case \"setmute\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                                ConversationTranslatorCommandTypes.setMute,\r\n                                                commandPayload.value, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'SetMuteAll' is sent if the Conversation has been muted by the host.\r\n                                 */\r\n                                case \"setmuteall\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.muteAllCommandReceived) {\r\n                                        this.privConversationServiceConnector.muteAllCommandReceived(this.privConversationServiceConnector,\r\n                                            new MuteAllEventArgs(commandPayload.value as boolean, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'RoomExpirationWarning' is sent towards the end of the Conversation session to give a timeout warning.\r\n                                 */\r\n                                case \"roomexpirationwarning\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.conversationExpiration) {\r\n                                        this.privConversationServiceConnector.conversationExpiration(this.privConversationServiceConnector,\r\n                                            new ConversationExpirationEventArgs(commandPayload.value as number, this.privConversationRequestSession.sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'SetUseTts' is sent as a confirmation if the user requests TTS to be turned on or off.\r\n                                 */\r\n                                case \"setusetts\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                                ConversationTranslatorCommandTypes.setUseTTS,\r\n                                                commandPayload.value, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'SetLockState' is set if the host has locked or unlocked the Conversation.\r\n                                 */\r\n                                case \"setlockstate\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.lockRoomCommandReceived) {\r\n                                        this.privConversationServiceConnector.lockRoomCommandReceived(this.privConversationServiceConnector,\r\n                                            new LockRoomEventArgs(commandPayload.value as boolean, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'ChangeNickname' is received if a user changes their display name.\r\n                                 * Any cached particpiants list should be updated to reflect the display name.\r\n                                 */\r\n                                case \"changenickname\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                                ConversationTranslatorCommandTypes.changeNickname,\r\n                                                commandPayload.nickname, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'JoinSession' is sent when a user joins the Conversation.\r\n                                 */\r\n                                case \"joinsession\":\r\n\r\n                                    const joinParticipantPayload: ParticipantPayloadResponse = ParticipantPayloadResponse.fromJSON(message.textBody);\r\n\r\n                                    const joiningParticipant: IInternalParticipant = {\r\n                                        avatar: joinParticipantPayload.avatar,\r\n                                        displayName: joinParticipantPayload.nickname,\r\n                                        id: joinParticipantPayload.participantId,\r\n                                        isHost: joinParticipantPayload.ishost,\r\n                                        isMuted: joinParticipantPayload.ismuted,\r\n                                        isUsingTts: joinParticipantPayload.usetts,\r\n                                        preferredLanguage: joinParticipantPayload.locale,\r\n                                    };\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantJoinCommandReceived) {\r\n                                        this.privConversationServiceConnector.participantJoinCommandReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantEventArgs(\r\n                                                joiningParticipant,\r\n                                                sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'LeaveSession' is sent when a user leaves the Conversation'.\r\n                                 */\r\n                                case \"leavesession\":\r\n\r\n                                    const leavingParticipant: IInternalParticipant = {\r\n                                        id: commandPayload.participantId\r\n                                    };\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantLeaveCommandReceived) {\r\n                                        this.privConversationServiceConnector.participantLeaveCommandReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantEventArgs(leavingParticipant, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'DisconnectSession' is sent when a user is disconnected from the session (e.g. network problem).\r\n                                 * Check the 'ParticipantId' to check whether the message is for the current user.\r\n                                 */\r\n                                case \"disconnectsession\":\r\n\r\n                                    const disconnectParticipant: IInternalParticipant = {\r\n                                        id: commandPayload.participantId\r\n                                    };\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * Message not recognized.\r\n                                 */\r\n                                default:\r\n                                    break;\r\n                            }\r\n                            break;\r\n\r\n                        /**\r\n                         * 'partial' (or 'hypothesis') represents a unfinalized speech message.\r\n                         */\r\n                        case \"partial\":\r\n\r\n                        /**\r\n                         * 'final' (or 'phrase') represents a finalized speech message.\r\n                         */\r\n                        case \"final\":\r\n\r\n                            const speechPayload: SpeechResponsePayload = SpeechResponsePayload.fromJSON(message.textBody);\r\n\r\n                            const speechResult: ConversationTranslationResult = new ConversationTranslationResult(speechPayload.participantId,\r\n                                this.getTranslations(speechPayload.translations),\r\n                                speechPayload.language,\r\n                                undefined,\r\n                                undefined,\r\n                                speechPayload.recognition,\r\n                                undefined,\r\n                                undefined,\r\n                                message.textBody,\r\n                                undefined);\r\n\r\n                            if (speechPayload.isFinal) {\r\n                                // check the length, sometimes empty finals are returned\r\n                                if (speechResult.text !== undefined && speechResult.text.length > 0) {\r\n                                    sendFinal = true;\r\n                                } else if (speechPayload.id === this.privLastPartialUtteranceId) {\r\n                                    // send final as normal. We had a non-empty partial for this same utterance\r\n                                    // so sending the empty final is important\r\n                                    sendFinal = true;\r\n                                } else {\r\n                                    // suppress unneeded final\r\n                                }\r\n\r\n                                if (sendFinal) {\r\n                                    if (!!this.privConversationServiceConnector.translationReceived) {\r\n                                        this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                            new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.final, speechResult, sessionId));\r\n                                    }\r\n                                }\r\n                            } else if (speechResult.text !== undefined) {\r\n                                this.privLastPartialUtteranceId = speechPayload.id;\r\n                                if (!!this.privConversationServiceConnector.translationReceived) {\r\n                                    this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                        new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.partial, speechResult, sessionId));\r\n                                }\r\n                            }\r\n\r\n                            break;\r\n\r\n                        /**\r\n                         * \"translated_message\" is a text message or instant message (IM).\r\n                         */\r\n                        case \"translated_message\":\r\n\r\n                            const textPayload: TextResponsePayload = TextResponsePayload.fromJSON(message.textBody);\r\n\r\n                            const textResult: ConversationTranslationResult = new ConversationTranslationResult(textPayload.participantId,\r\n                                this.getTranslations(textPayload.translations),\r\n                                textPayload.language,\r\n                                undefined,\r\n                                undefined,\r\n                                textPayload.originalText,\r\n                                undefined,\r\n                                undefined,\r\n                                undefined,\r\n                                message.textBody,\r\n                                undefined);\r\n\r\n                            if (!!this.privConversationServiceConnector.translationReceived) {\r\n                                this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                    new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.instantMessage, textResult, sessionId));\r\n                            }\r\n                            break;\r\n\r\n                        default:\r\n                            // ignore any unsupported message types\r\n                            break;\r\n                    }\r\n                } catch (e) {\r\n                    // continue\r\n                }\r\n                return this.receiveConversationMessageOverride();\r\n            });\r\n        }, (error: string) => {\r\n            this.terminateMessageLoop = true;\r\n        });\r\n\r\n        return communicationCustodian.promise();\r\n    }\r\n\r\n    private startMessageLoop(): Promise<IConnection> {\r\n\r\n        this.terminateMessageLoop = false;\r\n\r\n        const messageRetrievalPromise = this.receiveConversationMessageOverride();\r\n\r\n        return messageRetrievalPromise.on((r: IConnection) => {\r\n            return true;\r\n        }, (error: string) => {\r\n            this.cancelRecognition(\r\n                this.privRequestSession ? this.privRequestSession.sessionId : \"\",\r\n                this.privRequestSession ? this.privRequestSession.requestId : \"\",\r\n                CancellationReason.Error,\r\n                CancellationErrorCode.RuntimeError,\r\n                error);\r\n        });\r\n    }\r\n\r\n    // Takes an established websocket connection to the endpoint\r\n    private configConnection(): Promise<IConnection> {\r\n        if (this.privConnectionConfigPromise) {\r\n            if (this.privConnectionConfigPromise.result().isCompleted &&\r\n                (this.privConnectionConfigPromise.result().isError\r\n                    || this.privConnectionConfigPromise.result().result.state() === ConnectionState.Disconnected)) {\r\n\r\n                this.privConnectionConfigPromise = null;\r\n                return this.configConnection();\r\n            } else {\r\n                return this.privConnectionConfigPromise;\r\n            }\r\n        }\r\n\r\n        if (this.terminateMessageLoop) {\r\n            return PromiseHelper.fromResult<IConnection>(undefined);\r\n        }\r\n\r\n        this.privConnectionConfigPromise = this.conversationConnectImpl()\r\n            .onSuccessContinueWith((connection: IConnection): any => {\r\n                return connection;\r\n            });\r\n        return this.privConnectionConfigPromise;\r\n    }\r\n\r\n    private getTranslations(serviceResultTranslations: ITranslationResponsePayload[]): Translations {\r\n        let translations: Translations;\r\n\r\n        if (undefined !== serviceResultTranslations) {\r\n            translations = new Translations();\r\n            for (const translation of serviceResultTranslations) {\r\n                translations.set(translation.lang, translation.translation);\r\n            }\r\n        }\r\n\r\n        return translations;\r\n    }\r\n\r\n    private fetchConversationConnection = (): Promise<IConnection> => {\r\n        return this.configConnection();\r\n    }\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"script"}