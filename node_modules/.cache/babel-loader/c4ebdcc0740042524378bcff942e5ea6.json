{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { ConnectionMessage, Deferred, MessageType, RawWebsocketMessage } from \"../common/Exports\";\nvar CRLF = \"\\r\\n\";\nexport var WebsocketMessageFormatter = function WebsocketMessageFormatter() {\n  var _this = this;\n\n  _classCallCheck(this, WebsocketMessageFormatter);\n\n  this.toConnectionMessage = function (message) {\n    var deferral = new Deferred();\n\n    try {\n      if (message.messageType === MessageType.Text) {\n        var textMessage = message.textContent;\n        var headers = {};\n        var body = null;\n\n        if (textMessage) {\n          var headerBodySplit = textMessage.split(\"\\r\\n\\r\\n\");\n\n          if (headerBodySplit && headerBodySplit.length > 0) {\n            headers = _this.parseHeaders(headerBodySplit[0]);\n\n            if (headerBodySplit.length > 1) {\n              body = headerBodySplit[1];\n            }\n          }\n        }\n\n        deferral.resolve(new ConnectionMessage(message.messageType, body, headers, message.id));\n      } else if (message.messageType === MessageType.Binary) {\n        var binaryMessage = message.binaryContent;\n        var _headers = {};\n        var _body = null;\n\n        if (!binaryMessage || binaryMessage.byteLength < 2) {\n          throw new Error(\"Invalid binary message format. Header length missing.\");\n        }\n\n        var dataView = new DataView(binaryMessage);\n        var headerLength = dataView.getInt16(0);\n\n        if (binaryMessage.byteLength < headerLength + 2) {\n          throw new Error(\"Invalid binary message format. Header content missing.\");\n        }\n\n        var headersString = \"\";\n\n        for (var i = 0; i < headerLength; i++) {\n          headersString += String.fromCharCode(dataView.getInt8(i + 2));\n        }\n\n        _headers = _this.parseHeaders(headersString);\n\n        if (binaryMessage.byteLength > headerLength + 2) {\n          _body = binaryMessage.slice(2 + headerLength);\n        }\n\n        deferral.resolve(new ConnectionMessage(message.messageType, _body, _headers, message.id));\n      }\n    } catch (e) {\n      deferral.reject(\"Error formatting the message. Error: \".concat(e));\n    }\n\n    return deferral.promise();\n  };\n\n  this.fromConnectionMessage = function (message) {\n    var deferral = new Deferred();\n\n    try {\n      if (message.messageType === MessageType.Text) {\n        var payload = \"\".concat(_this.makeHeaders(message)).concat(CRLF).concat(message.textBody ? message.textBody : \"\");\n        deferral.resolve(new RawWebsocketMessage(MessageType.Text, payload, message.id));\n      } else if (message.messageType === MessageType.Binary) {\n        var headersString = _this.makeHeaders(message);\n\n        var content = message.binaryBody;\n        var headerInt8Array = new Int8Array(_this.stringToArrayBuffer(headersString));\n\n        var _payload = new ArrayBuffer(2 + headerInt8Array.byteLength + (content ? content.byteLength : 0));\n\n        var dataView = new DataView(_payload);\n        dataView.setInt16(0, headerInt8Array.length);\n\n        for (var i = 0; i < headerInt8Array.byteLength; i++) {\n          dataView.setInt8(2 + i, headerInt8Array[i]);\n        }\n\n        if (content) {\n          var bodyInt8Array = new Int8Array(content);\n\n          for (var _i = 0; _i < bodyInt8Array.byteLength; _i++) {\n            dataView.setInt8(2 + headerInt8Array.byteLength + _i, bodyInt8Array[_i]);\n          }\n        }\n\n        deferral.resolve(new RawWebsocketMessage(MessageType.Binary, _payload, message.id));\n      }\n    } catch (e) {\n      deferral.reject(\"Error formatting the message. \".concat(e));\n    }\n\n    return deferral.promise();\n  };\n\n  this.makeHeaders = function (message) {\n    var headersString = \"\";\n\n    if (message.headers) {\n      for (var header in message.headers) {\n        if (header) {\n          headersString += \"\".concat(header, \": \").concat(message.headers[header]).concat(CRLF);\n        }\n      }\n    }\n\n    return headersString;\n  };\n\n  this.parseHeaders = function (headersString) {\n    var headers = {};\n\n    if (headersString) {\n      var headerMatches = headersString.match(/[^\\r\\n]+/g);\n\n      if (headers) {\n        var _iterator = _createForOfIteratorHelper(headerMatches),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var header = _step.value;\n\n            if (header) {\n              var separatorIndex = header.indexOf(\":\");\n              var headerName = separatorIndex > 0 ? header.substr(0, separatorIndex).trim().toLowerCase() : header;\n              var headerValue = separatorIndex > 0 && header.length > separatorIndex + 1 ? header.substr(separatorIndex + 1).trim() : \"\";\n              headers[headerName] = headerValue;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    }\n\n    return headers;\n  };\n\n  this.stringToArrayBuffer = function (str) {\n    var buffer = new ArrayBuffer(str.length);\n    var view = new DataView(buffer);\n\n    for (var i = 0; i < str.length; i++) {\n      view.setUint8(i, str.charCodeAt(i));\n    }\n\n    return buffer;\n  };\n};","map":{"version":3,"sources":["src/common.speech/WebsocketMessageFormatter.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ConnectionMessage,\r\n    Deferred,\r\n    IStringDictionary,\r\n    IWebsocketMessageFormatter,\r\n    MessageType,\r\n    Promise,\r\n    RawWebsocketMessage,\r\n} from \"../common/Exports\";\r\n\r\nconst CRLF: string = \"\\r\\n\";\r\n\r\nexport class WebsocketMessageFormatter implements IWebsocketMessageFormatter {\r\n\r\n    public toConnectionMessage = (message: RawWebsocketMessage): Promise<ConnectionMessage> => {\r\n        const deferral = new Deferred<ConnectionMessage>();\r\n\r\n        try {\r\n            if (message.messageType === MessageType.Text) {\r\n                const textMessage: string = message.textContent;\r\n                let headers: IStringDictionary<string> = {};\r\n                let body: string = null;\r\n\r\n                if (textMessage) {\r\n                    const headerBodySplit = textMessage.split(\"\\r\\n\\r\\n\");\r\n                    if (headerBodySplit && headerBodySplit.length > 0) {\r\n                        headers = this.parseHeaders(headerBodySplit[0]);\r\n                        if (headerBodySplit.length > 1) {\r\n                            body = headerBodySplit[1];\r\n                        }\r\n                    }\r\n                }\r\n\r\n                deferral.resolve(new ConnectionMessage(message.messageType, body, headers, message.id));\r\n            } else if (message.messageType === MessageType.Binary) {\r\n                const binaryMessage: ArrayBuffer = message.binaryContent;\r\n                let headers: IStringDictionary<string> = {};\r\n                let body: ArrayBuffer = null;\r\n\r\n                if (!binaryMessage || binaryMessage.byteLength < 2) {\r\n                    throw new Error(\"Invalid binary message format. Header length missing.\");\r\n                }\r\n\r\n                const dataView = new DataView(binaryMessage);\r\n                const headerLength = dataView.getInt16(0);\r\n\r\n                if (binaryMessage.byteLength < headerLength + 2) {\r\n                    throw new Error(\"Invalid binary message format. Header content missing.\");\r\n                }\r\n\r\n                let headersString = \"\";\r\n                for (let i = 0; i < headerLength; i++) {\r\n                    headersString += String.fromCharCode((dataView).getInt8(i + 2));\r\n                }\r\n\r\n                headers = this.parseHeaders(headersString);\r\n\r\n                if (binaryMessage.byteLength > headerLength + 2) {\r\n                    body = binaryMessage.slice(2 + headerLength);\r\n                }\r\n\r\n                deferral.resolve(new ConnectionMessage(message.messageType, body, headers, message.id));\r\n            }\r\n        } catch (e) {\r\n            deferral.reject(`Error formatting the message. Error: ${e}`);\r\n        }\r\n\r\n        return deferral.promise();\r\n    }\r\n\r\n    public fromConnectionMessage = (message: ConnectionMessage): Promise<RawWebsocketMessage> => {\r\n        const deferral = new Deferred<RawWebsocketMessage>();\r\n\r\n        try {\r\n            if (message.messageType === MessageType.Text) {\r\n                const payload = `${this.makeHeaders(message)}${CRLF}${message.textBody ? message.textBody : \"\"}`;\r\n\r\n                deferral.resolve(new RawWebsocketMessage(MessageType.Text, payload, message.id));\r\n\r\n            } else if (message.messageType === MessageType.Binary) {\r\n                const headersString = this.makeHeaders(message);\r\n                const content = message.binaryBody;\r\n\r\n                const headerInt8Array = new Int8Array(this.stringToArrayBuffer(headersString));\r\n\r\n                const payload = new ArrayBuffer(2 + headerInt8Array.byteLength + (content ? content.byteLength : 0));\r\n                const dataView = new DataView(payload);\r\n\r\n                dataView.setInt16(0, headerInt8Array.length);\r\n\r\n                for (let i = 0; i < headerInt8Array.byteLength; i++) {\r\n                    dataView.setInt8(2 + i, headerInt8Array[i]);\r\n                }\r\n\r\n                if (content) {\r\n                    const bodyInt8Array = new Int8Array(content);\r\n                    for (let i = 0; i < bodyInt8Array.byteLength; i++) {\r\n                        dataView.setInt8(2 + headerInt8Array.byteLength + i, bodyInt8Array[i]);\r\n                    }\r\n                }\r\n\r\n                deferral.resolve(new RawWebsocketMessage(MessageType.Binary, payload, message.id));\r\n            }\r\n        } catch (e) {\r\n            deferral.reject(`Error formatting the message. ${e}`);\r\n        }\r\n\r\n        return deferral.promise();\r\n    }\r\n\r\n    private makeHeaders = (message: ConnectionMessage): string => {\r\n        let headersString: string = \"\";\r\n\r\n        if (message.headers) {\r\n            for (const header in message.headers) {\r\n                if (header) {\r\n                    headersString += `${header}: ${message.headers[header]}${CRLF}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        return headersString;\r\n    }\r\n\r\n    private parseHeaders = (headersString: string): IStringDictionary<string> => {\r\n        const headers: IStringDictionary<string> = {};\r\n\r\n        if (headersString) {\r\n            const headerMatches = headersString.match(/[^\\r\\n]+/g);\r\n            if (headers) {\r\n                for (const header of headerMatches) {\r\n                    if (header) {\r\n                        const separatorIndex = header.indexOf(\":\");\r\n                        const headerName = separatorIndex > 0 ? header.substr(0, separatorIndex).trim().toLowerCase() : header;\r\n                        const headerValue =\r\n                            separatorIndex > 0 && header.length > (separatorIndex + 1) ?\r\n                                header.substr(separatorIndex + 1).trim() :\r\n                                \"\";\r\n\r\n                        headers[headerName] = headerValue;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return headers;\r\n    }\r\n\r\n    private stringToArrayBuffer = (str: string): ArrayBuffer => {\r\n        const buffer = new ArrayBuffer(str.length);\r\n        const view = new DataView(buffer);\r\n        for (let i = 0; i < str.length; i++) {\r\n            view.setUint8(i, str.charCodeAt(i));\r\n        }\r\n        return buffer;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}