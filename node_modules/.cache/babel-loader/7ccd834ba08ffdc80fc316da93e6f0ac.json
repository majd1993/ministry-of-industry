{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) {\n    if (b.hasOwnProperty(p)) d[p] = b[p];\n  }\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar isArray_1 = require('../util/isArray');\n\nvar isArrayLike_1 = require('../util/isArrayLike');\n\nvar isPromise_1 = require('../util/isPromise');\n\nvar PromiseObservable_1 = require('./PromiseObservable');\n\nvar IteratorObservable_1 = require('./IteratorObservable');\n\nvar ArrayObservable_1 = require('./ArrayObservable');\n\nvar ArrayLikeObservable_1 = require('./ArrayLikeObservable');\n\nvar iterator_1 = require('../symbol/iterator');\n\nvar Observable_1 = require('../Observable');\n\nvar observeOn_1 = require('../operators/observeOn');\n\nvar observable_1 = require('../symbol/observable');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar FromObservable = function (_super) {\n  __extends(FromObservable, _super);\n\n  function FromObservable(ish, scheduler) {\n    _super.call(this, null);\n\n    this.ish = ish;\n    this.scheduler = scheduler;\n  }\n  /**\n   * Creates an Observable from an Array, an array-like object, a Promise, an\n   * iterable object, or an Observable-like object.\n   *\n   * <span class=\"informal\">Converts almost anything to an Observable.</span>\n   *\n   * <img src=\"./img/from.png\" width=\"100%\">\n   *\n   * Convert various other objects and data types into Observables. `from`\n   * converts a Promise or an array-like or an\n   * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)\n   * object into an Observable that emits the items in that promise or array or\n   * iterable. A String, in this context, is treated as an array of characters.\n   * Observable-like objects (contains a function named with the ES2015 Symbol\n   * for Observable) can also be converted through this operator.\n   *\n   * @example <caption>Converts an array to an Observable</caption>\n   * var array = [10, 20, 30];\n   * var result = Rx.Observable.from(array);\n   * result.subscribe(x => console.log(x));\n   *\n   * // Results in the following:\n   * // 10 20 30\n   *\n   * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>\n   * function* generateDoubles(seed) {\n   *   var i = seed;\n   *   while (true) {\n   *     yield i;\n   *     i = 2 * i; // double it\n   *   }\n   * }\n   *\n   * var iterator = generateDoubles(3);\n   * var result = Rx.Observable.from(iterator).take(10);\n   * result.subscribe(x => console.log(x));\n   *\n   * // Results in the following:\n   * // 3 6 12 24 48 96 192 384 768 1536\n   *\n   * @see {@link create}\n   * @see {@link fromEvent}\n   * @see {@link fromEventPattern}\n   * @see {@link fromPromise}\n   *\n   * @param {ObservableInput<T>} ish A subscribable object, a Promise, an\n   * Observable-like, an Array, an iterable or an array-like object to be\n   * converted.\n   * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n   * emissions of values.\n   * @return {Observable<T>} The Observable whose values are originally from the\n   * input object that was converted.\n   * @static true\n   * @name from\n   * @owner Observable\n   */\n\n\n  FromObservable.create = function (ish, scheduler) {\n    if (ish != null) {\n      if (typeof ish[observable_1.observable] === 'function') {\n        if (ish instanceof Observable_1.Observable && !scheduler) {\n          return ish;\n        }\n\n        return new FromObservable(ish, scheduler);\n      } else if (isArray_1.isArray(ish)) {\n        return new ArrayObservable_1.ArrayObservable(ish, scheduler);\n      } else if (isPromise_1.isPromise(ish)) {\n        return new PromiseObservable_1.PromiseObservable(ish, scheduler);\n      } else if (typeof ish[iterator_1.iterator] === 'function' || typeof ish === 'string') {\n        return new IteratorObservable_1.IteratorObservable(ish, scheduler);\n      } else if (isArrayLike_1.isArrayLike(ish)) {\n        return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);\n      }\n    }\n\n    throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');\n  };\n  /** @deprecated internal use only */\n\n\n  FromObservable.prototype._subscribe = function (subscriber) {\n    var ish = this.ish;\n    var scheduler = this.scheduler;\n\n    if (scheduler == null) {\n      return ish[observable_1.observable]().subscribe(subscriber);\n    } else {\n      return ish[observable_1.observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));\n    }\n  };\n\n  return FromObservable;\n}(Observable_1.Observable);\n\nexports.FromObservable = FromObservable;","map":{"version":3,"sources":["../../src/observable/FromObservable.ts"],"names":[],"mappings":"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","sourcesContent":["import { isArray } from '../util/isArray';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isPromise } from '../util/isPromise';\nimport { PromiseObservable } from './PromiseObservable';\nimport { IteratorObservable } from'./IteratorObservable';\nimport { ArrayObservable } from './ArrayObservable';\nimport { ArrayLikeObservable } from './ArrayLikeObservable';\n\nimport { IScheduler } from '../Scheduler';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { Observable, ObservableInput } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { ObserveOnSubscriber } from '../operators/observeOn';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class FromObservable<T> extends Observable<T> {\n  constructor(private ish: ObservableInput<T>, private scheduler?: IScheduler) {\n    super(null);\n  }\n\n  static create<T>(ish: ObservableInput<T>, scheduler?: IScheduler): Observable<T>;\n  static create<T, R>(ish: ArrayLike<T>, scheduler?: IScheduler): Observable<R>;\n\n  /**\n   * Creates an Observable from an Array, an array-like object, a Promise, an\n   * iterable object, or an Observable-like object.\n   *\n   * <span class=\"informal\">Converts almost anything to an Observable.</span>\n   *\n   * <img src=\"./img/from.png\" width=\"100%\">\n   *\n   * Convert various other objects and data types into Observables. `from`\n   * converts a Promise or an array-like or an\n   * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)\n   * object into an Observable that emits the items in that promise or array or\n   * iterable. A String, in this context, is treated as an array of characters.\n   * Observable-like objects (contains a function named with the ES2015 Symbol\n   * for Observable) can also be converted through this operator.\n   *\n   * @example <caption>Converts an array to an Observable</caption>\n   * var array = [10, 20, 30];\n   * var result = Rx.Observable.from(array);\n   * result.subscribe(x => console.log(x));\n   *\n   * // Results in the following:\n   * // 10 20 30\n   *\n   * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>\n   * function* generateDoubles(seed) {\n   *   var i = seed;\n   *   while (true) {\n   *     yield i;\n   *     i = 2 * i; // double it\n   *   }\n   * }\n   *\n   * var iterator = generateDoubles(3);\n   * var result = Rx.Observable.from(iterator).take(10);\n   * result.subscribe(x => console.log(x));\n   *\n   * // Results in the following:\n   * // 3 6 12 24 48 96 192 384 768 1536\n   *\n   * @see {@link create}\n   * @see {@link fromEvent}\n   * @see {@link fromEventPattern}\n   * @see {@link fromPromise}\n   *\n   * @param {ObservableInput<T>} ish A subscribable object, a Promise, an\n   * Observable-like, an Array, an iterable or an array-like object to be\n   * converted.\n   * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n   * emissions of values.\n   * @return {Observable<T>} The Observable whose values are originally from the\n   * input object that was converted.\n   * @static true\n   * @name from\n   * @owner Observable\n   */\n  static create<T>(ish: ObservableInput<T>, scheduler?: IScheduler): Observable<T> {\n    if (ish != null) {\n      if (typeof ish[Symbol_observable] === 'function') {\n        if (ish instanceof Observable && !scheduler) {\n          return ish;\n        }\n        return new FromObservable<T>(ish, scheduler);\n      } else if (isArray(ish)) {\n        return new ArrayObservable<T>(ish, scheduler);\n      } else if (isPromise<T>(ish)) {\n        return new PromiseObservable<T>(ish, scheduler);\n      } else if (typeof ish[Symbol_iterator] === 'function' || typeof ish === 'string') {\n        return new IteratorObservable<T>(ish, scheduler);\n      } else if (isArrayLike(ish)) {\n        return new ArrayLikeObservable(ish, scheduler);\n      }\n    }\n\n    throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<T>) {\n    const ish = this.ish;\n    const scheduler = this.scheduler;\n    if (scheduler == null) {\n      return ish[Symbol_observable]().subscribe(subscriber);\n    } else {\n      return ish[Symbol_observable]().subscribe(new ObserveOnSubscriber(subscriber, scheduler, 0));\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}