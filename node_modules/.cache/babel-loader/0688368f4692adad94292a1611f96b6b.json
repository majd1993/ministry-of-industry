{"ast":null,"code":"'use strict';\n\nmodule.exports = markdownTable;\nvar dotRe = /\\./;\nvar lastDotRe = /\\.[^.]*$/; // Characters.\n\nvar space = ' ';\nvar lineFeed = '\\n';\nvar dash = '-';\nvar dot = '.';\nvar colon = ':';\nvar lowercaseC = 'c';\nvar lowercaseL = 'l';\nvar lowercaseR = 'r';\nvar verticalBar = '|';\nvar minCellSize = 3; // Create a table from a matrix of strings.\n\nfunction markdownTable(table, options) {\n  var settings = options || {};\n  var delimiter = settings.delimiter;\n  var start = settings.start;\n  var end = settings.end;\n  var alignment = settings.align;\n  var calculateStringLength = settings.stringLength || lengthNoop;\n  var cellCount = 0;\n  var rowIndex = -1;\n  var rowLength = table.length;\n  var sizes = [];\n  var align;\n  var rule;\n  var rows;\n  var row;\n  var cells;\n  var index;\n  var position;\n  var size;\n  var value;\n  var spacing;\n  var before;\n  var after;\n  alignment = alignment ? alignment.concat() : [];\n\n  if (delimiter === null || delimiter === undefined) {\n    delimiter = space + verticalBar + space;\n  }\n\n  if (start === null || start === undefined) {\n    start = verticalBar + space;\n  }\n\n  if (end === null || end === undefined) {\n    end = space + verticalBar;\n  }\n\n  while (++rowIndex < rowLength) {\n    row = table[rowIndex];\n    index = -1;\n\n    if (row.length > cellCount) {\n      cellCount = row.length;\n    }\n\n    while (++index < cellCount) {\n      position = row[index] ? dotindex(row[index]) : null;\n\n      if (!sizes[index]) {\n        sizes[index] = minCellSize;\n      }\n\n      if (position > sizes[index]) {\n        sizes[index] = position;\n      }\n    }\n  }\n\n  if (typeof alignment === 'string') {\n    alignment = pad(cellCount, alignment).split('');\n  } // Make sure only valid alignments are used.\n\n\n  index = -1;\n\n  while (++index < cellCount) {\n    align = alignment[index];\n\n    if (typeof align === 'string') {\n      align = align.charAt(0).toLowerCase();\n    }\n\n    if (align !== lowercaseL && align !== lowercaseR && align !== lowercaseC && align !== dot) {\n      align = '';\n    }\n\n    alignment[index] = align;\n  }\n\n  rowIndex = -1;\n  rows = [];\n\n  while (++rowIndex < rowLength) {\n    row = table[rowIndex];\n    index = -1;\n    cells = [];\n\n    while (++index < cellCount) {\n      value = row[index];\n      value = stringify(value);\n\n      if (alignment[index] === dot) {\n        position = dotindex(value);\n        size = sizes[index] + (dotRe.test(value) ? 0 : 1) - (calculateStringLength(value) - position);\n        cells[index] = value + pad(size - 1);\n      } else {\n        cells[index] = value;\n      }\n    }\n\n    rows[rowIndex] = cells;\n  }\n\n  sizes = [];\n  rowIndex = -1;\n\n  while (++rowIndex < rowLength) {\n    cells = rows[rowIndex];\n    index = -1;\n\n    while (++index < cellCount) {\n      value = cells[index];\n\n      if (!sizes[index]) {\n        sizes[index] = minCellSize;\n      }\n\n      size = calculateStringLength(value);\n\n      if (size > sizes[index]) {\n        sizes[index] = size;\n      }\n    }\n  }\n\n  rowIndex = -1;\n\n  while (++rowIndex < rowLength) {\n    cells = rows[rowIndex];\n    index = -1;\n\n    if (settings.pad !== false) {\n      while (++index < cellCount) {\n        value = cells[index];\n        position = sizes[index] - (calculateStringLength(value) || 0);\n        spacing = pad(position);\n\n        if (alignment[index] === lowercaseR || alignment[index] === dot) {\n          value = spacing + value;\n        } else if (alignment[index] === lowercaseC) {\n          position /= 2;\n\n          if (position % 1 === 0) {\n            before = position;\n            after = position;\n          } else {\n            before = position + 0.5;\n            after = position - 0.5;\n          }\n\n          value = pad(before) + value + pad(after);\n        } else {\n          value += spacing;\n        }\n\n        cells[index] = value;\n      }\n    }\n\n    rows[rowIndex] = cells.join(delimiter);\n  }\n\n  if (settings.rule !== false) {\n    index = -1;\n    rule = [];\n\n    while (++index < cellCount) {\n      // When `pad` is false, make the rule the same size as the first row.\n      if (settings.pad === false) {\n        value = table[0][index];\n        spacing = calculateStringLength(stringify(value));\n        spacing = spacing > minCellSize ? spacing : minCellSize;\n      } else {\n        spacing = sizes[index];\n      }\n\n      align = alignment[index]; // When `align` is left, don't add colons.\n\n      value = align === lowercaseR || align === '' ? dash : colon;\n      value += pad(spacing - 2, dash);\n      value += align !== lowercaseL && align !== '' ? colon : dash;\n      rule[index] = value;\n    }\n\n    rows.splice(1, 0, rule.join(delimiter));\n  }\n\n  return start + rows.join(end + lineFeed + start) + end;\n}\n\nfunction stringify(value) {\n  return value === null || value === undefined ? '' : String(value);\n} // Get the length of `value`.\n\n\nfunction lengthNoop(value) {\n  return String(value).length;\n} // Get a string consisting of `length` `character`s.\n\n\nfunction pad(length, character) {\n  return new Array(length + 1).join(character || space);\n} // Get the position of the last dot in `value`.\n\n\nfunction dotindex(value) {\n  var match = lastDotRe.exec(value);\n  return match ? match.index + 1 : value.length;\n}","map":{"version":3,"sources":["/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/markdown-table/index.js"],"names":["module","exports","markdownTable","dotRe","lastDotRe","space","lineFeed","dash","dot","colon","lowercaseC","lowercaseL","lowercaseR","verticalBar","minCellSize","table","options","settings","delimiter","start","end","alignment","align","calculateStringLength","stringLength","lengthNoop","cellCount","rowIndex","rowLength","length","sizes","rule","rows","row","cells","index","position","size","value","spacing","before","after","concat","undefined","dotindex","pad","split","charAt","toLowerCase","stringify","test","join","splice","String","character","Array","match","exec"],"mappings":"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","sourcesContent":["'use strict'\n\nmodule.exports = markdownTable\n\nvar dotRe = /\\./\nvar lastDotRe = /\\.[^.]*$/\n\n// Characters.\nvar space = ' '\nvar lineFeed = '\\n'\nvar dash = '-'\nvar dot = '.'\nvar colon = ':'\nvar lowercaseC = 'c'\nvar lowercaseL = 'l'\nvar lowercaseR = 'r'\nvar verticalBar = '|'\n\nvar minCellSize = 3\n\n// Create a table from a matrix of strings.\nfunction markdownTable(table, options) {\n  var settings = options || {}\n  var delimiter = settings.delimiter\n  var start = settings.start\n  var end = settings.end\n  var alignment = settings.align\n  var calculateStringLength = settings.stringLength || lengthNoop\n  var cellCount = 0\n  var rowIndex = -1\n  var rowLength = table.length\n  var sizes = []\n  var align\n  var rule\n  var rows\n  var row\n  var cells\n  var index\n  var position\n  var size\n  var value\n  var spacing\n  var before\n  var after\n\n  alignment = alignment ? alignment.concat() : []\n\n  if (delimiter === null || delimiter === undefined) {\n    delimiter = space + verticalBar + space\n  }\n\n  if (start === null || start === undefined) {\n    start = verticalBar + space\n  }\n\n  if (end === null || end === undefined) {\n    end = space + verticalBar\n  }\n\n  while (++rowIndex < rowLength) {\n    row = table[rowIndex]\n\n    index = -1\n\n    if (row.length > cellCount) {\n      cellCount = row.length\n    }\n\n    while (++index < cellCount) {\n      position = row[index] ? dotindex(row[index]) : null\n\n      if (!sizes[index]) {\n        sizes[index] = minCellSize\n      }\n\n      if (position > sizes[index]) {\n        sizes[index] = position\n      }\n    }\n  }\n\n  if (typeof alignment === 'string') {\n    alignment = pad(cellCount, alignment).split('')\n  }\n\n  // Make sure only valid alignments are used.\n  index = -1\n\n  while (++index < cellCount) {\n    align = alignment[index]\n\n    if (typeof align === 'string') {\n      align = align.charAt(0).toLowerCase()\n    }\n\n    if (\n      align !== lowercaseL &&\n      align !== lowercaseR &&\n      align !== lowercaseC &&\n      align !== dot\n    ) {\n      align = ''\n    }\n\n    alignment[index] = align\n  }\n\n  rowIndex = -1\n  rows = []\n\n  while (++rowIndex < rowLength) {\n    row = table[rowIndex]\n\n    index = -1\n    cells = []\n\n    while (++index < cellCount) {\n      value = row[index]\n\n      value = stringify(value)\n\n      if (alignment[index] === dot) {\n        position = dotindex(value)\n\n        size =\n          sizes[index] +\n          (dotRe.test(value) ? 0 : 1) -\n          (calculateStringLength(value) - position)\n\n        cells[index] = value + pad(size - 1)\n      } else {\n        cells[index] = value\n      }\n    }\n\n    rows[rowIndex] = cells\n  }\n\n  sizes = []\n  rowIndex = -1\n\n  while (++rowIndex < rowLength) {\n    cells = rows[rowIndex]\n\n    index = -1\n\n    while (++index < cellCount) {\n      value = cells[index]\n\n      if (!sizes[index]) {\n        sizes[index] = minCellSize\n      }\n\n      size = calculateStringLength(value)\n\n      if (size > sizes[index]) {\n        sizes[index] = size\n      }\n    }\n  }\n\n  rowIndex = -1\n\n  while (++rowIndex < rowLength) {\n    cells = rows[rowIndex]\n\n    index = -1\n\n    if (settings.pad !== false) {\n      while (++index < cellCount) {\n        value = cells[index]\n\n        position = sizes[index] - (calculateStringLength(value) || 0)\n        spacing = pad(position)\n\n        if (alignment[index] === lowercaseR || alignment[index] === dot) {\n          value = spacing + value\n        } else if (alignment[index] === lowercaseC) {\n          position /= 2\n\n          if (position % 1 === 0) {\n            before = position\n            after = position\n          } else {\n            before = position + 0.5\n            after = position - 0.5\n          }\n\n          value = pad(before) + value + pad(after)\n        } else {\n          value += spacing\n        }\n\n        cells[index] = value\n      }\n    }\n\n    rows[rowIndex] = cells.join(delimiter)\n  }\n\n  if (settings.rule !== false) {\n    index = -1\n    rule = []\n\n    while (++index < cellCount) {\n      // When `pad` is false, make the rule the same size as the first row.\n      if (settings.pad === false) {\n        value = table[0][index]\n        spacing = calculateStringLength(stringify(value))\n        spacing = spacing > minCellSize ? spacing : minCellSize\n      } else {\n        spacing = sizes[index]\n      }\n\n      align = alignment[index]\n\n      // When `align` is left, don't add colons.\n      value = align === lowercaseR || align === '' ? dash : colon\n      value += pad(spacing - 2, dash)\n      value += align !== lowercaseL && align !== '' ? colon : dash\n\n      rule[index] = value\n    }\n\n    rows.splice(1, 0, rule.join(delimiter))\n  }\n\n  return start + rows.join(end + lineFeed + start) + end\n}\n\nfunction stringify(value) {\n  return value === null || value === undefined ? '' : String(value)\n}\n\n// Get the length of `value`.\nfunction lengthNoop(value) {\n  return String(value).length\n}\n\n// Get a string consisting of `length` `character`s.\nfunction pad(length, character) {\n  return new Array(length + 1).join(character || space)\n}\n\n// Get the position of the last dot in `value`.\nfunction dotindex(value) {\n  var match = lastDotRe.exec(value)\n\n  return match ? match.index + 1 : value.length\n}\n"]},"metadata":{},"sourceType":"script"}