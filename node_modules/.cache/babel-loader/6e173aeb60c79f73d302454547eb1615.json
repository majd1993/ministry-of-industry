{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId]) {\n      /******/\n      return installedModules[moduleId].exports;\n      /******/\n    }\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n\n    var module = installedModules[moduleId] = {\n      /******/\n      i: moduleId,\n\n      /******/\n      l: false,\n\n      /******/\n      exports: {}\n      /******/\n\n    };\n    /******/\n\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.l = true;\n    /******/\n\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n\n  /******/\n\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n\n  /******/\n  // define getter function for harmony exports\n\n  /******/\n\n  __webpack_require__.d = function (exports, name, getter) {\n    /******/\n    if (!__webpack_require__.o(exports, name)) {\n      /******/\n      Object.defineProperty(exports, name, {\n        enumerable: true,\n        get: getter\n      });\n      /******/\n    }\n    /******/\n\n  };\n  /******/\n\n  /******/\n  // define __esModule on exports\n\n  /******/\n\n\n  __webpack_require__.r = function (exports) {\n    /******/\n    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n      /******/\n      Object.defineProperty(exports, Symbol.toStringTag, {\n        value: 'Module'\n      });\n      /******/\n    }\n    /******/\n\n\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n    /******/\n  };\n  /******/\n\n  /******/\n  // create a fake namespace object\n\n  /******/\n  // mode & 1: value is a module id, require it\n\n  /******/\n  // mode & 2: merge all properties of value into the ns\n\n  /******/\n  // mode & 4: return value when already ns object\n\n  /******/\n  // mode & 8|1: behave like require\n\n  /******/\n\n\n  __webpack_require__.t = function (value, mode) {\n    /******/\n    if (mode & 1) value = __webpack_require__(value);\n    /******/\n\n    if (mode & 8) return value;\n    /******/\n\n    if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;\n    /******/\n\n    var ns = Object.create(null);\n    /******/\n\n    __webpack_require__.r(ns);\n    /******/\n\n\n    Object.defineProperty(ns, 'default', {\n      enumerable: true,\n      value: value\n    });\n    /******/\n\n    if (mode & 2 && typeof value != 'string') for (var key in value) {\n      __webpack_require__.d(ns, key, function (key) {\n        return value[key];\n      }.bind(null, key));\n    }\n    /******/\n\n    return ns;\n    /******/\n  };\n  /******/\n\n  /******/\n  // getDefaultExport function for compatibility with non-harmony modules\n\n  /******/\n\n\n  __webpack_require__.n = function (module) {\n    /******/\n    var getter = module && module.__esModule ?\n    /******/\n    function getDefault() {\n      return module['default'];\n    } :\n    /******/\n    function getModuleExports() {\n      return module;\n    };\n    /******/\n\n    __webpack_require__.d(getter, 'a', getter);\n    /******/\n\n\n    return getter;\n    /******/\n  };\n  /******/\n\n  /******/\n  // Object.prototype.hasOwnProperty.call\n\n  /******/\n\n\n  __webpack_require__.o = function (object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n  };\n  /******/\n\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n\n  __webpack_require__.p = \"\";\n  /******/\n\n  /******/\n\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(__webpack_require__.s = 0);\n  /******/\n}(\n/************************************************************************/\n\n/******/\n[\n/* 0 */\n\n/***/\nfunction (module, __webpack_exports__, __webpack_require__) {\n  \"use strict\"; // ESM COMPAT FLAG\n\n  __webpack_require__.r(__webpack_exports__); // EXPORTS\n\n\n  __webpack_require__.d(__webpack_exports__, \"defineEventAttribute\", function () {\n    return (\n      /* reexport */\n      defineEventAttribute\n    );\n  });\n\n  __webpack_require__.d(__webpack_exports__, \"EventTarget\", function () {\n    return (\n      /* reexport */\n      event_target_shim\n    );\n  }); // CONCATENATED MODULE: ../event-target-shim/dist/event-target-shim.mjs\n\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function _typeof(obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function _typeof(obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n  /**\n   * @author Toru Nagashima <https://github.com/mysticatea>\n   * @copyright 2015 Toru Nagashima. All rights reserved.\n   * See LICENSE file in root directory for full license.\n   */\n\n  /**\n   * @typedef {object} PrivateData\n   * @property {EventTarget} eventTarget The event target.\n   * @property {{type:string}} event The original event object.\n   * @property {number} eventPhase The current event phase.\n   * @property {EventTarget|null} currentTarget The current event target.\n   * @property {boolean} canceled The flag to prevent default.\n   * @property {boolean} stopped The flag to stop propagation.\n   * @property {boolean} immediateStopped The flag to stop propagation immediately.\n   * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n   * @property {number} timeStamp The unix time.\n   * @private\n   */\n\n  /**\n   * Private data for event wrappers.\n   * @type {WeakMap<Event, PrivateData>}\n   * @private\n   */\n\n\n  var privateData = new WeakMap();\n  /**\n   * Cache for wrapper classes.\n   * @type {WeakMap<Object, Function>}\n   * @private\n   */\n\n  var wrappers = new WeakMap();\n  /**\n   * Get private data.\n   * @param {Event} event The event object to get private data.\n   * @returns {PrivateData} The private data of the event.\n   * @private\n   */\n\n  function pd(event) {\n    var retv = privateData.get(event);\n    console.assert(retv != null, \"'this' is expected an Event object, but got\", event);\n    return retv;\n  }\n  /**\n   * https://dom.spec.whatwg.org/#set-the-canceled-flag\n   * @param data {PrivateData} private data.\n   */\n\n\n  function setCancelFlag(data) {\n    if (data.passiveListener != null) {\n      if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(\"Unable to preventDefault inside passive event listener invocation.\", data.passiveListener);\n      }\n\n      return;\n    }\n\n    if (!data.event.cancelable) {\n      return;\n    }\n\n    data.canceled = true;\n\n    if (typeof data.event.preventDefault === \"function\") {\n      data.event.preventDefault();\n    }\n  }\n  /**\n   * @see https://dom.spec.whatwg.org/#interface-event\n   * @private\n   */\n\n  /**\n   * The event wrapper.\n   * @constructor\n   * @param {EventTarget} eventTarget The event target of this dispatching.\n   * @param {Event|{type:string}} event The original event to wrap.\n   */\n\n\n  function Event(eventTarget, event) {\n    privateData.set(this, {\n      eventTarget: eventTarget,\n      event: event,\n      eventPhase: 2,\n      currentTarget: eventTarget,\n      canceled: false,\n      stopped: false,\n      immediateStopped: false,\n      passiveListener: null,\n      timeStamp: event.timeStamp || Date.now()\n    }); // https://heycam.github.io/webidl/#Unforgeable\n\n    Object.defineProperty(this, \"isTrusted\", {\n      value: false,\n      enumerable: true\n    }); // Define accessors\n\n    var keys = Object.keys(event);\n\n    for (var i = 0; i < keys.length; ++i) {\n      var key = keys[i];\n\n      if (!(key in this)) {\n        Object.defineProperty(this, key, defineRedirectDescriptor(key));\n      }\n    }\n  } // Should be enumerable, but class methods are not enumerable.\n\n\n  Event.prototype = {\n    /**\n     * The type of this event.\n     * @type {string}\n     */\n    get type() {\n      return pd(this).event.type;\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get target() {\n      return pd(this).eventTarget;\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get currentTarget() {\n      return pd(this).currentTarget;\n    },\n\n    /**\n     * @returns {EventTarget[]} The composed path of this event.\n     */\n    composedPath: function composedPath() {\n      var currentTarget = pd(this).currentTarget;\n\n      if (currentTarget == null) {\n        return [];\n      }\n\n      return [currentTarget];\n    },\n\n    /**\n     * Constant of NONE.\n     * @type {number}\n     */\n    get NONE() {\n      return 0;\n    },\n\n    /**\n     * Constant of CAPTURING_PHASE.\n     * @type {number}\n     */\n    get CAPTURING_PHASE() {\n      return 1;\n    },\n\n    /**\n     * Constant of AT_TARGET.\n     * @type {number}\n     */\n    get AT_TARGET() {\n      return 2;\n    },\n\n    /**\n     * Constant of BUBBLING_PHASE.\n     * @type {number}\n     */\n    get BUBBLING_PHASE() {\n      return 3;\n    },\n\n    /**\n     * The target of this event.\n     * @type {number}\n     */\n    get eventPhase() {\n      return pd(this).eventPhase;\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopPropagation: function stopPropagation() {\n      var data = pd(this);\n      data.stopped = true;\n\n      if (typeof data.event.stopPropagation === \"function\") {\n        data.event.stopPropagation();\n      }\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopImmediatePropagation: function stopImmediatePropagation() {\n      var data = pd(this);\n      data.stopped = true;\n      data.immediateStopped = true;\n\n      if (typeof data.event.stopImmediatePropagation === \"function\") {\n        data.event.stopImmediatePropagation();\n      }\n    },\n\n    /**\n     * The flag to be bubbling.\n     * @type {boolean}\n     */\n    get bubbles() {\n      return Boolean(pd(this).event.bubbles);\n    },\n\n    /**\n     * The flag to be cancelable.\n     * @type {boolean}\n     */\n    get cancelable() {\n      return Boolean(pd(this).event.cancelable);\n    },\n\n    /**\n     * Cancel this event.\n     * @returns {void}\n     */\n    preventDefault: function preventDefault() {\n      setCancelFlag(pd(this));\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     */\n    get defaultPrevented() {\n      return pd(this).canceled;\n    },\n\n    /**\n     * The flag to be composed.\n     * @type {boolean}\n     */\n    get composed() {\n      return Boolean(pd(this).event.composed);\n    },\n\n    /**\n     * The unix time of this event.\n     * @type {number}\n     */\n    get timeStamp() {\n      return pd(this).timeStamp;\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     * @deprecated\n     */\n    get srcElement() {\n      return pd(this).eventTarget;\n    },\n\n    /**\n     * The flag to stop event bubbling.\n     * @type {boolean}\n     * @deprecated\n     */\n    get cancelBubble() {\n      return pd(this).stopped;\n    },\n\n    set cancelBubble(value) {\n      if (!value) {\n        return;\n      }\n\n      var data = pd(this);\n      data.stopped = true;\n\n      if (typeof data.event.cancelBubble === \"boolean\") {\n        data.event.cancelBubble = true;\n      }\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     * @deprecated\n     */\n    get returnValue() {\n      return !pd(this).canceled;\n    },\n\n    set returnValue(value) {\n      if (!value) {\n        setCancelFlag(pd(this));\n      }\n    },\n\n    /**\n     * Initialize this event object. But do nothing under event dispatching.\n     * @param {string} type The event type.\n     * @param {boolean} [bubbles=false] The flag to be possible to bubble up.\n     * @param {boolean} [cancelable=false] The flag to be possible to cancel.\n     * @deprecated\n     */\n    initEvent: function initEvent() {// Do nothing.\n    }\n  }; // `constructor` is not enumerable.\n\n  Object.defineProperty(Event.prototype, \"constructor\", {\n    value: Event,\n    configurable: true,\n    writable: true\n  }); // Ensure `event instanceof window.Event` is `true`.\n\n  if (typeof window !== \"undefined\" && typeof window.Event !== \"undefined\") {\n    Object.setPrototypeOf(Event.prototype, window.Event.prototype); // Make association for wrappers.\n\n    wrappers.set(window.Event.prototype, Event);\n  }\n  /**\n   * Get the property descriptor to redirect a given property.\n   * @param {string} key Property name to define property descriptor.\n   * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n   * @private\n   */\n\n\n  function defineRedirectDescriptor(key) {\n    return {\n      get: function get() {\n        return pd(this).event[key];\n      },\n      set: function set(value) {\n        pd(this).event[key] = value;\n      },\n      configurable: true,\n      enumerable: true\n    };\n  }\n  /**\n   * Get the property descriptor to call a given method property.\n   * @param {string} key Property name to define property descriptor.\n   * @returns {PropertyDescriptor} The property descriptor to call the method property.\n   * @private\n   */\n\n\n  function defineCallDescriptor(key) {\n    return {\n      value: function value() {\n        var event = pd(this).event;\n        return event[key].apply(event, arguments);\n      },\n      configurable: true,\n      enumerable: true\n    };\n  }\n  /**\n   * Define new wrapper class.\n   * @param {Function} BaseEvent The base wrapper class.\n   * @param {Object} proto The prototype of the original event.\n   * @returns {Function} The defined wrapper class.\n   * @private\n   */\n\n\n  function defineWrapper(BaseEvent, proto) {\n    var keys = Object.keys(proto);\n\n    if (keys.length === 0) {\n      return BaseEvent;\n    }\n    /** CustomEvent */\n\n\n    function CustomEvent(eventTarget, event) {\n      BaseEvent.call(this, eventTarget, event);\n    }\n\n    CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n      constructor: {\n        value: CustomEvent,\n        configurable: true,\n        writable: true\n      }\n    }); // Define accessors.\n\n    for (var i = 0; i < keys.length; ++i) {\n      var key = keys[i];\n\n      if (!(key in BaseEvent.prototype)) {\n        var descriptor = Object.getOwnPropertyDescriptor(proto, key);\n        var isFunc = typeof descriptor.value === \"function\";\n        Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));\n      }\n    }\n\n    return CustomEvent;\n  }\n  /**\n   * Get the wrapper class of a given prototype.\n   * @param {Object} proto The prototype of the original event to get its wrapper.\n   * @returns {Function} The wrapper class.\n   * @private\n   */\n\n\n  function getWrapper(proto) {\n    if (proto == null || proto === Object.prototype) {\n      return Event;\n    }\n\n    var wrapper = wrappers.get(proto);\n\n    if (wrapper == null) {\n      wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);\n      wrappers.set(proto, wrapper);\n    }\n\n    return wrapper;\n  }\n  /**\n   * Wrap a given event to management a dispatching.\n   * @param {EventTarget} eventTarget The event target of this dispatching.\n   * @param {Object} event The event to wrap.\n   * @returns {Event} The wrapper instance.\n   * @private\n   */\n\n\n  function wrapEvent(eventTarget, event) {\n    var Wrapper = getWrapper(Object.getPrototypeOf(event));\n    return new Wrapper(eventTarget, event);\n  }\n  /**\n   * Get the immediateStopped flag of a given event.\n   * @param {Event} event The event to get.\n   * @returns {boolean} The flag to stop propagation immediately.\n   * @private\n   */\n\n\n  function isStopped(event) {\n    return pd(event).immediateStopped;\n  }\n  /**\n   * Set the current event phase of a given event.\n   * @param {Event} event The event to set current target.\n   * @param {number} eventPhase New event phase.\n   * @returns {void}\n   * @private\n   */\n\n\n  function setEventPhase(event, eventPhase) {\n    pd(event).eventPhase = eventPhase;\n  }\n  /**\n   * Set the current target of a given event.\n   * @param {Event} event The event to set current target.\n   * @param {EventTarget|null} currentTarget New current target.\n   * @returns {void}\n   * @private\n   */\n\n\n  function setCurrentTarget(event, currentTarget) {\n    pd(event).currentTarget = currentTarget;\n  }\n  /**\n   * Set a passive listener of a given event.\n   * @param {Event} event The event to set current target.\n   * @param {Function|null} passiveListener New passive listener.\n   * @returns {void}\n   * @private\n   */\n\n\n  function setPassiveListener(event, passiveListener) {\n    pd(event).passiveListener = passiveListener;\n  }\n  /**\n   * @typedef {object} ListenerNode\n   * @property {Function} listener\n   * @property {1|2|3} listenerType\n   * @property {boolean} passive\n   * @property {boolean} once\n   * @property {ListenerNode|null} next\n   * @private\n   */\n\n  /**\n   * @type {WeakMap<object, Map<string, ListenerNode>>}\n   * @private\n   */\n\n\n  var listenersMap = new WeakMap(); // Listener types\n\n  var CAPTURE = 1;\n  var BUBBLE = 2;\n  var ATTRIBUTE = 3;\n  /**\n   * Check whether a given value is an object or not.\n   * @param {any} x The value to check.\n   * @returns {boolean} `true` if the value is an object.\n   */\n\n  function isObject(x) {\n    return x !== null && _typeof(x) === \"object\"; //eslint-disable-line no-restricted-syntax\n  }\n  /**\n   * Get listeners.\n   * @param {EventTarget} eventTarget The event target to get.\n   * @returns {Map<string, ListenerNode>} The listeners.\n   * @private\n   */\n\n\n  function getListeners(eventTarget) {\n    var listeners = listenersMap.get(eventTarget);\n\n    if (listeners == null) {\n      throw new TypeError(\"'this' is expected an EventTarget object, but got another value.\");\n    }\n\n    return listeners;\n  }\n  /**\n   * Get the property descriptor for the event attribute of a given event.\n   * @param {string} eventName The event name to get property descriptor.\n   * @returns {PropertyDescriptor} The property descriptor.\n   * @private\n   */\n\n\n  function defineEventAttributeDescriptor(eventName) {\n    return {\n      get: function get() {\n        var listeners = getListeners(this);\n        var node = listeners.get(eventName);\n\n        while (node != null) {\n          if (node.listenerType === ATTRIBUTE) {\n            return node.listener;\n          }\n\n          node = node.next;\n        }\n\n        return null;\n      },\n      set: function set(listener) {\n        if (typeof listener !== \"function\" && !isObject(listener)) {\n          listener = null; // eslint-disable-line no-param-reassign\n        }\n\n        var listeners = getListeners(this); // Traverse to the tail while removing old value.\n\n        var prev = null;\n        var node = listeners.get(eventName);\n\n        while (node != null) {\n          if (node.listenerType === ATTRIBUTE) {\n            // Remove old value.\n            if (prev !== null) {\n              prev.next = node.next;\n            } else if (node.next !== null) {\n              listeners.set(eventName, node.next);\n            } else {\n              listeners[\"delete\"](eventName);\n            }\n          } else {\n            prev = node;\n          }\n\n          node = node.next;\n        } // Add new value.\n\n\n        if (listener !== null) {\n          var newNode = {\n            listener: listener,\n            listenerType: ATTRIBUTE,\n            passive: false,\n            once: false,\n            next: null\n          };\n\n          if (prev === null) {\n            listeners.set(eventName, newNode);\n          } else {\n            prev.next = newNode;\n          }\n        }\n      },\n      configurable: true,\n      enumerable: true\n    };\n  }\n  /**\n   * Define an event attribute (e.g. `eventTarget.onclick`).\n   * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n   * @param {string} eventName The event name to define.\n   * @returns {void}\n   */\n\n\n  function defineEventAttribute(eventTargetPrototype, eventName) {\n    Object.defineProperty(eventTargetPrototype, \"on\".concat(eventName), defineEventAttributeDescriptor(eventName));\n  }\n  /**\n   * Define a custom EventTarget with event attributes.\n   * @param {string[]} eventNames Event names for event attributes.\n   * @returns {EventTarget} The custom EventTarget.\n   * @private\n   */\n\n\n  function defineCustomEventTarget(eventNames) {\n    /** CustomEventTarget */\n    function CustomEventTarget() {\n      EventTarget.call(this);\n    }\n\n    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n      constructor: {\n        value: CustomEventTarget,\n        configurable: true,\n        writable: true\n      }\n    });\n\n    for (var i = 0; i < eventNames.length; ++i) {\n      defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);\n    }\n\n    return CustomEventTarget;\n  }\n  /**\n   * EventTarget.\n   *\n   * - This is constructor if no arguments.\n   * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n   *\n   * For example:\n   *\n   *     class A extends EventTarget {}\n   *     class B extends EventTarget(\"message\") {}\n   *     class C extends EventTarget(\"message\", \"error\") {}\n   *     class D extends EventTarget([\"message\", \"error\"]) {}\n   */\n\n\n  function EventTarget() {\n    /*eslint-disable consistent-return */\n    if (this instanceof EventTarget) {\n      listenersMap.set(this, new Map());\n      return;\n    }\n\n    if (arguments.length === 1 && Array.isArray(arguments[0])) {\n      return defineCustomEventTarget(arguments[0]);\n    }\n\n    if (arguments.length > 0) {\n      var types = new Array(arguments.length);\n\n      for (var i = 0; i < arguments.length; ++i) {\n        types[i] = arguments[i];\n      }\n\n      return defineCustomEventTarget(types);\n    }\n\n    throw new TypeError(\"Cannot call a class as a function\");\n    /*eslint-enable consistent-return */\n  } // Should be enumerable, but class methods are not enumerable.\n\n\n  EventTarget.prototype = {\n    /**\n     * Add a given listener to this event target.\n     * @param {string} eventName The event name to add.\n     * @param {Function} listener The listener to add.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    addEventListener: function addEventListener(eventName, listener, options) {\n      if (listener == null) {\n        return;\n      }\n\n      if (typeof listener !== \"function\" && !isObject(listener)) {\n        throw new TypeError(\"'listener' should be a function or an object.\");\n      }\n\n      var listeners = getListeners(this);\n      var optionsIsObj = isObject(options);\n      var capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);\n      var listenerType = capture ? CAPTURE : BUBBLE;\n      var newNode = {\n        listener: listener,\n        listenerType: listenerType,\n        passive: optionsIsObj && Boolean(options.passive),\n        once: optionsIsObj && Boolean(options.once),\n        next: null\n      }; // Set it as the first node if the first node is null.\n\n      var node = listeners.get(eventName);\n\n      if (node === undefined) {\n        listeners.set(eventName, newNode);\n        return;\n      } // Traverse to the tail while checking duplication..\n\n\n      var prev = null;\n\n      while (node != null) {\n        if (node.listener === listener && node.listenerType === listenerType) {\n          // Should ignore duplication.\n          return;\n        }\n\n        prev = node;\n        node = node.next;\n      } // Add it.\n\n\n      prev.next = newNode;\n    },\n\n    /**\n     * Remove a given listener from this event target.\n     * @param {string} eventName The event name to remove.\n     * @param {Function} listener The listener to remove.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    removeEventListener: function removeEventListener(eventName, listener, options) {\n      if (listener == null) {\n        return;\n      }\n\n      var listeners = getListeners(this);\n      var capture = isObject(options) ? Boolean(options.capture) : Boolean(options);\n      var listenerType = capture ? CAPTURE : BUBBLE;\n      var prev = null;\n      var node = listeners.get(eventName);\n\n      while (node != null) {\n        if (node.listener === listener && node.listenerType === listenerType) {\n          if (prev !== null) {\n            prev.next = node.next;\n          } else if (node.next !== null) {\n            listeners.set(eventName, node.next);\n          } else {\n            listeners[\"delete\"](eventName);\n          }\n\n          return;\n        }\n\n        prev = node;\n        node = node.next;\n      }\n    },\n\n    /**\n     * Dispatch a given event.\n     * @param {Event|{type:string}} event The event to dispatch.\n     * @returns {boolean} `false` if canceled.\n     */\n    dispatchEvent: function dispatchEvent(event) {\n      if (event == null || typeof event.type !== \"string\") {\n        throw new TypeError('\"event.type\" should be a string.');\n      } // If listeners aren't registered, terminate.\n\n\n      var listeners = getListeners(this);\n      var eventName = event.type;\n      var node = listeners.get(eventName);\n\n      if (node == null) {\n        return true;\n      } // Since we cannot rewrite several properties, so wrap object.\n\n\n      var wrappedEvent = wrapEvent(this, event); // This doesn't process capturing phase and bubbling phase.\n      // This isn't participating in a tree.\n\n      var prev = null;\n\n      while (node != null) {\n        // Remove this listener if it's once\n        if (node.once) {\n          if (prev !== null) {\n            prev.next = node.next;\n          } else if (node.next !== null) {\n            listeners.set(eventName, node.next);\n          } else {\n            listeners[\"delete\"](eventName);\n          }\n        } else {\n          prev = node;\n        } // Call this listener\n\n\n        setPassiveListener(wrappedEvent, node.passive ? node.listener : null);\n\n        if (typeof node.listener === \"function\") {\n          try {\n            node.listener.call(this, wrappedEvent);\n          } catch (err) {\n            if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n              console.error(err);\n            }\n          }\n        } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === \"function\") {\n          node.listener.handleEvent(wrappedEvent);\n        } // Break if `event.stopImmediatePropagation` was called.\n\n\n        if (isStopped(wrappedEvent)) {\n          break;\n        }\n\n        node = node.next;\n      }\n\n      setPassiveListener(wrappedEvent, null);\n      setEventPhase(wrappedEvent, 0);\n      setCurrentTarget(wrappedEvent, null);\n      return !wrappedEvent.defaultPrevented;\n    }\n  }; // `constructor` is not enumerable.\n\n  Object.defineProperty(EventTarget.prototype, \"constructor\", {\n    value: EventTarget,\n    configurable: true,\n    writable: true\n  }); // Ensure `eventTarget instanceof window.EventTarget` is `true`.\n\n  if (typeof window !== \"undefined\" && typeof window.EventTarget !== \"undefined\") {\n    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);\n  }\n  /* harmony default export */\n\n\n  var event_target_shim = EventTarget; // CONCATENATED MODULE: ./src/index.js\n\n  /* harmony default export */\n\n  var src = __webpack_exports__[\"default\"] = event_target_shim;\n  /***/\n}\n/******/\n]);","map":{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///src/event.mjs","webpack:///src/event-target.mjs","webpack:///src/index.js"],"names":["EventTarget"],"mappings":"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","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n * @typedef {object} PrivateData\n * @property {EventTarget} eventTarget The event target.\n * @property {{type:string}} event The original event object.\n * @property {number} eventPhase The current event phase.\n * @property {EventTarget|null} currentTarget The current event target.\n * @property {boolean} canceled The flag to prevent default.\n * @property {boolean} stopped The flag to stop propagation.\n * @property {boolean} immediateStopped The flag to stop propagation immediately.\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n * @property {number} timeStamp The unix time.\n * @private\n */\n\n/**\n * Private data for event wrappers.\n * @type {WeakMap<Event, PrivateData>}\n * @private\n */\nconst privateData = new WeakMap()\n\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\nconst wrappers = new WeakMap()\n\n/**\n * Get private data.\n * @param {Event} event The event object to get private data.\n * @returns {PrivateData} The private data of the event.\n * @private\n */\nfunction pd(event) {\n    const retv = privateData.get(event)\n    console.assert(\n        retv != null,\n        \"'this' is expected an Event object, but got\",\n        event\n    )\n    return retv\n}\n\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data {PrivateData} private data.\n */\nfunction setCancelFlag(data) {\n    if (data.passiveListener != null) {\n        if (\n            typeof console !== \"undefined\" &&\n            typeof console.error === \"function\"\n        ) {\n            console.error(\n                \"Unable to preventDefault inside passive event listener invocation.\",\n                data.passiveListener\n            )\n        }\n        return\n    }\n    if (!data.event.cancelable) {\n        return\n    }\n\n    data.canceled = true\n    if (typeof data.event.preventDefault === \"function\") {\n        data.event.preventDefault()\n    }\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#interface-event\n * @private\n */\n/**\n * The event wrapper.\n * @constructor\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Event|{type:string}} event The original event to wrap.\n */\nfunction Event(eventTarget, event) {\n    privateData.set(this, {\n        eventTarget,\n        event,\n        eventPhase: 2,\n        currentTarget: eventTarget,\n        canceled: false,\n        stopped: false,\n        immediateStopped: false,\n        passiveListener: null,\n        timeStamp: event.timeStamp || Date.now(),\n    })\n\n    // https://heycam.github.io/webidl/#Unforgeable\n    Object.defineProperty(this, \"isTrusted\", { value: false, enumerable: true })\n\n    // Define accessors\n    const keys = Object.keys(event)\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i]\n        if (!(key in this)) {\n            Object.defineProperty(this, key, defineRedirectDescriptor(key))\n        }\n    }\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEvent.prototype = {\n    /**\n     * The type of this event.\n     * @type {string}\n     */\n    get type() {\n        return pd(this).event.type\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get target() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get currentTarget() {\n        return pd(this).currentTarget\n    },\n\n    /**\n     * @returns {EventTarget[]} The composed path of this event.\n     */\n    composedPath() {\n        const currentTarget = pd(this).currentTarget\n        if (currentTarget == null) {\n            return []\n        }\n        return [currentTarget]\n    },\n\n    /**\n     * Constant of NONE.\n     * @type {number}\n     */\n    get NONE() {\n        return 0\n    },\n\n    /**\n     * Constant of CAPTURING_PHASE.\n     * @type {number}\n     */\n    get CAPTURING_PHASE() {\n        return 1\n    },\n\n    /**\n     * Constant of AT_TARGET.\n     * @type {number}\n     */\n    get AT_TARGET() {\n        return 2\n    },\n\n    /**\n     * Constant of BUBBLING_PHASE.\n     * @type {number}\n     */\n    get BUBBLING_PHASE() {\n        return 3\n    },\n\n    /**\n     * The target of this event.\n     * @type {number}\n     */\n    get eventPhase() {\n        return pd(this).eventPhase\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopPropagation() {\n        const data = pd(this)\n\n        data.stopped = true\n        if (typeof data.event.stopPropagation === \"function\") {\n            data.event.stopPropagation()\n        }\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopImmediatePropagation() {\n        const data = pd(this)\n\n        data.stopped = true\n        data.immediateStopped = true\n        if (typeof data.event.stopImmediatePropagation === \"function\") {\n            data.event.stopImmediatePropagation()\n        }\n    },\n\n    /**\n     * The flag to be bubbling.\n     * @type {boolean}\n     */\n    get bubbles() {\n        return Boolean(pd(this).event.bubbles)\n    },\n\n    /**\n     * The flag to be cancelable.\n     * @type {boolean}\n     */\n    get cancelable() {\n        return Boolean(pd(this).event.cancelable)\n    },\n\n    /**\n     * Cancel this event.\n     * @returns {void}\n     */\n    preventDefault() {\n        setCancelFlag(pd(this))\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     */\n    get defaultPrevented() {\n        return pd(this).canceled\n    },\n\n    /**\n     * The flag to be composed.\n     * @type {boolean}\n     */\n    get composed() {\n        return Boolean(pd(this).event.composed)\n    },\n\n    /**\n     * The unix time of this event.\n     * @type {number}\n     */\n    get timeStamp() {\n        return pd(this).timeStamp\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     * @deprecated\n     */\n    get srcElement() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The flag to stop event bubbling.\n     * @type {boolean}\n     * @deprecated\n     */\n    get cancelBubble() {\n        return pd(this).stopped\n    },\n    set cancelBubble(value) {\n        if (!value) {\n            return\n        }\n        const data = pd(this)\n\n        data.stopped = true\n        if (typeof data.event.cancelBubble === \"boolean\") {\n            data.event.cancelBubble = true\n        }\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     * @deprecated\n     */\n    get returnValue() {\n        return !pd(this).canceled\n    },\n    set returnValue(value) {\n        if (!value) {\n            setCancelFlag(pd(this))\n        }\n    },\n\n    /**\n     * Initialize this event object. But do nothing under event dispatching.\n     * @param {string} type The event type.\n     * @param {boolean} [bubbles=false] The flag to be possible to bubble up.\n     * @param {boolean} [cancelable=false] The flag to be possible to cancel.\n     * @deprecated\n     */\n    initEvent() {\n        // Do nothing.\n    },\n}\n\n// `constructor` is not enumerable.\nObject.defineProperty(Event.prototype, \"constructor\", {\n    value: Event,\n    configurable: true,\n    writable: true,\n})\n\n// Ensure `event instanceof window.Event` is `true`.\nif (typeof window !== \"undefined\" && typeof window.Event !== \"undefined\") {\n    Object.setPrototypeOf(Event.prototype, window.Event.prototype)\n\n    // Make association for wrappers.\n    wrappers.set(window.Event.prototype, Event)\n}\n\n/**\n * Get the property descriptor to redirect a given property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n * @private\n */\nfunction defineRedirectDescriptor(key) {\n    return {\n        get() {\n            return pd(this).event[key]\n        },\n        set(value) {\n            pd(this).event[key] = value\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Get the property descriptor to call a given method property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\n * @private\n */\nfunction defineCallDescriptor(key) {\n    return {\n        value() {\n            const event = pd(this).event\n            return event[key].apply(event, arguments)\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define new wrapper class.\n * @param {Function} BaseEvent The base wrapper class.\n * @param {Object} proto The prototype of the original event.\n * @returns {Function} The defined wrapper class.\n * @private\n */\nfunction defineWrapper(BaseEvent, proto) {\n    const keys = Object.keys(proto)\n    if (keys.length === 0) {\n        return BaseEvent\n    }\n\n    /** CustomEvent */\n    function CustomEvent(eventTarget, event) {\n        BaseEvent.call(this, eventTarget, event)\n    }\n\n    CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n        constructor: { value: CustomEvent, configurable: true, writable: true },\n    })\n\n    // Define accessors.\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i]\n        if (!(key in BaseEvent.prototype)) {\n            const descriptor = Object.getOwnPropertyDescriptor(proto, key)\n            const isFunc = typeof descriptor.value === \"function\"\n            Object.defineProperty(\n                CustomEvent.prototype,\n                key,\n                isFunc\n                    ? defineCallDescriptor(key)\n                    : defineRedirectDescriptor(key)\n            )\n        }\n    }\n\n    return CustomEvent\n}\n\n/**\n * Get the wrapper class of a given prototype.\n * @param {Object} proto The prototype of the original event to get its wrapper.\n * @returns {Function} The wrapper class.\n * @private\n */\nfunction getWrapper(proto) {\n    if (proto == null || proto === Object.prototype) {\n        return Event\n    }\n\n    let wrapper = wrappers.get(proto)\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto)\n        wrappers.set(proto, wrapper)\n    }\n    return wrapper\n}\n\n/**\n * Wrap a given event to management a dispatching.\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Object} event The event to wrap.\n * @returns {Event} The wrapper instance.\n * @private\n */\nexport function wrapEvent(eventTarget, event) {\n    const Wrapper = getWrapper(Object.getPrototypeOf(event))\n    return new Wrapper(eventTarget, event)\n}\n\n/**\n * Get the immediateStopped flag of a given event.\n * @param {Event} event The event to get.\n * @returns {boolean} The flag to stop propagation immediately.\n * @private\n */\nexport function isStopped(event) {\n    return pd(event).immediateStopped\n}\n\n/**\n * Set the current event phase of a given event.\n * @param {Event} event The event to set current target.\n * @param {number} eventPhase New event phase.\n * @returns {void}\n * @private\n */\nexport function setEventPhase(event, eventPhase) {\n    pd(event).eventPhase = eventPhase\n}\n\n/**\n * Set the current target of a given event.\n * @param {Event} event The event to set current target.\n * @param {EventTarget|null} currentTarget New current target.\n * @returns {void}\n * @private\n */\nexport function setCurrentTarget(event, currentTarget) {\n    pd(event).currentTarget = currentTarget\n}\n\n/**\n * Set a passive listener of a given event.\n * @param {Event} event The event to set current target.\n * @param {Function|null} passiveListener New passive listener.\n * @returns {void}\n * @private\n */\nexport function setPassiveListener(event, passiveListener) {\n    pd(event).passiveListener = passiveListener\n}\n","import {\n    isStopped,\n    setCurrentTarget,\n    setEventPhase,\n    setPassiveListener,\n    wrapEvent,\n} from \"./event.mjs\"\n\n/**\n * @typedef {object} ListenerNode\n * @property {Function} listener\n * @property {1|2|3} listenerType\n * @property {boolean} passive\n * @property {boolean} once\n * @property {ListenerNode|null} next\n * @private\n */\n\n/**\n * @type {WeakMap<object, Map<string, ListenerNode>>}\n * @private\n */\nconst listenersMap = new WeakMap()\n\n// Listener types\nconst CAPTURE = 1\nconst BUBBLE = 2\nconst ATTRIBUTE = 3\n\n/**\n * Check whether a given value is an object or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an object.\n */\nfunction isObject(x) {\n    return x !== null && typeof x === \"object\" //eslint-disable-line no-restricted-syntax\n}\n\n/**\n * Get listeners.\n * @param {EventTarget} eventTarget The event target to get.\n * @returns {Map<string, ListenerNode>} The listeners.\n * @private\n */\nfunction getListeners(eventTarget) {\n    const listeners = listenersMap.get(eventTarget)\n    if (listeners == null) {\n        throw new TypeError(\n            \"'this' is expected an EventTarget object, but got another value.\"\n        )\n    }\n    return listeners\n}\n\n/**\n * Get the property descriptor for the event attribute of a given event.\n * @param {string} eventName The event name to get property descriptor.\n * @returns {PropertyDescriptor} The property descriptor.\n * @private\n */\nfunction defineEventAttributeDescriptor(eventName) {\n    return {\n        get() {\n            const listeners = getListeners(this)\n            let node = listeners.get(eventName)\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    return node.listener\n                }\n                node = node.next\n            }\n            return null\n        },\n\n        set(listener) {\n            if (typeof listener !== \"function\" && !isObject(listener)) {\n                listener = null // eslint-disable-line no-param-reassign\n            }\n            const listeners = getListeners(this)\n\n            // Traverse to the tail while removing old value.\n            let prev = null\n            let node = listeners.get(eventName)\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    // Remove old value.\n                    if (prev !== null) {\n                        prev.next = node.next\n                    } else if (node.next !== null) {\n                        listeners.set(eventName, node.next)\n                    } else {\n                        listeners.delete(eventName)\n                    }\n                } else {\n                    prev = node\n                }\n\n                node = node.next\n            }\n\n            // Add new value.\n            if (listener !== null) {\n                const newNode = {\n                    listener,\n                    listenerType: ATTRIBUTE,\n                    passive: false,\n                    once: false,\n                    next: null,\n                }\n                if (prev === null) {\n                    listeners.set(eventName, newNode)\n                } else {\n                    prev.next = newNode\n                }\n            }\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define an event attribute (e.g. `eventTarget.onclick`).\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n * @param {string} eventName The event name to define.\n * @returns {void}\n */\nfunction defineEventAttribute(eventTargetPrototype, eventName) {\n    Object.defineProperty(\n        eventTargetPrototype,\n        `on${eventName}`,\n        defineEventAttributeDescriptor(eventName)\n    )\n}\n\n/**\n * Define a custom EventTarget with event attributes.\n * @param {string[]} eventNames Event names for event attributes.\n * @returns {EventTarget} The custom EventTarget.\n * @private\n */\nfunction defineCustomEventTarget(eventNames) {\n    /** CustomEventTarget */\n    function CustomEventTarget() {\n        EventTarget.call(this)\n    }\n\n    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n        constructor: {\n            value: CustomEventTarget,\n            configurable: true,\n            writable: true,\n        },\n    })\n\n    for (let i = 0; i < eventNames.length; ++i) {\n        defineEventAttribute(CustomEventTarget.prototype, eventNames[i])\n    }\n\n    return CustomEventTarget\n}\n\n/**\n * EventTarget.\n *\n * - This is constructor if no arguments.\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n *\n * For example:\n *\n *     class A extends EventTarget {}\n *     class B extends EventTarget(\"message\") {}\n *     class C extends EventTarget(\"message\", \"error\") {}\n *     class D extends EventTarget([\"message\", \"error\"]) {}\n */\nfunction EventTarget() {\n    /*eslint-disable consistent-return */\n    if (this instanceof EventTarget) {\n        listenersMap.set(this, new Map())\n        return\n    }\n    if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        return defineCustomEventTarget(arguments[0])\n    }\n    if (arguments.length > 0) {\n        const types = new Array(arguments.length)\n        for (let i = 0; i < arguments.length; ++i) {\n            types[i] = arguments[i]\n        }\n        return defineCustomEventTarget(types)\n    }\n    throw new TypeError(\"Cannot call a class as a function\")\n    /*eslint-enable consistent-return */\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEventTarget.prototype = {\n    /**\n     * Add a given listener to this event target.\n     * @param {string} eventName The event name to add.\n     * @param {Function} listener The listener to add.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    addEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n        if (typeof listener !== \"function\" && !isObject(listener)) {\n            throw new TypeError(\"'listener' should be a function or an object.\")\n        }\n\n        const listeners = getListeners(this)\n        const optionsIsObj = isObject(options)\n        const capture = optionsIsObj\n            ? Boolean(options.capture)\n            : Boolean(options)\n        const listenerType = capture ? CAPTURE : BUBBLE\n        const newNode = {\n            listener,\n            listenerType,\n            passive: optionsIsObj && Boolean(options.passive),\n            once: optionsIsObj && Boolean(options.once),\n            next: null,\n        }\n\n        // Set it as the first node if the first node is null.\n        let node = listeners.get(eventName)\n        if (node === undefined) {\n            listeners.set(eventName, newNode)\n            return\n        }\n\n        // Traverse to the tail while checking duplication..\n        let prev = null\n        while (node != null) {\n            if (\n                node.listener === listener &&\n                node.listenerType === listenerType\n            ) {\n                // Should ignore duplication.\n                return\n            }\n            prev = node\n            node = node.next\n        }\n\n        // Add it.\n        prev.next = newNode\n    },\n\n    /**\n     * Remove a given listener from this event target.\n     * @param {string} eventName The event name to remove.\n     * @param {Function} listener The listener to remove.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    removeEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n\n        const listeners = getListeners(this)\n        const capture = isObject(options)\n            ? Boolean(options.capture)\n            : Boolean(options)\n        const listenerType = capture ? CAPTURE : BUBBLE\n\n        let prev = null\n        let node = listeners.get(eventName)\n        while (node != null) {\n            if (\n                node.listener === listener &&\n                node.listenerType === listenerType\n            ) {\n                if (prev !== null) {\n                    prev.next = node.next\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next)\n                } else {\n                    listeners.delete(eventName)\n                }\n                return\n            }\n\n            prev = node\n            node = node.next\n        }\n    },\n\n    /**\n     * Dispatch a given event.\n     * @param {Event|{type:string}} event The event to dispatch.\n     * @returns {boolean} `false` if canceled.\n     */\n    dispatchEvent(event) {\n        if (event == null || typeof event.type !== \"string\") {\n            throw new TypeError('\"event.type\" should be a string.')\n        }\n\n        // If listeners aren't registered, terminate.\n        const listeners = getListeners(this)\n        const eventName = event.type\n        let node = listeners.get(eventName)\n        if (node == null) {\n            return true\n        }\n\n        // Since we cannot rewrite several properties, so wrap object.\n        const wrappedEvent = wrapEvent(this, event)\n\n        // This doesn't process capturing phase and bubbling phase.\n        // This isn't participating in a tree.\n        let prev = null\n        while (node != null) {\n            // Remove this listener if it's once\n            if (node.once) {\n                if (prev !== null) {\n                    prev.next = node.next\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next)\n                } else {\n                    listeners.delete(eventName)\n                }\n            } else {\n                prev = node\n            }\n\n            // Call this listener\n            setPassiveListener(\n                wrappedEvent,\n                node.passive ? node.listener : null\n            )\n            if (typeof node.listener === \"function\") {\n                try {\n                    node.listener.call(this, wrappedEvent)\n                } catch (err) {\n                    if (\n                        typeof console !== \"undefined\" &&\n                        typeof console.error === \"function\"\n                    ) {\n                        console.error(err)\n                    }\n                }\n            } else if (\n                node.listenerType !== ATTRIBUTE &&\n                typeof node.listener.handleEvent === \"function\"\n            ) {\n                node.listener.handleEvent(wrappedEvent)\n            }\n\n            // Break if `event.stopImmediatePropagation` was called.\n            if (isStopped(wrappedEvent)) {\n                break\n            }\n\n            node = node.next\n        }\n        setPassiveListener(wrappedEvent, null)\n        setEventPhase(wrappedEvent, 0)\n        setCurrentTarget(wrappedEvent, null)\n\n        return !wrappedEvent.defaultPrevented\n    },\n}\n\n// `constructor` is not enumerable.\nObject.defineProperty(EventTarget.prototype, \"constructor\", {\n    value: EventTarget,\n    configurable: true,\n    writable: true,\n})\n\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (\n    typeof window !== \"undefined\" &&\n    typeof window.EventTarget !== \"undefined\"\n) {\n    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype)\n}\n\nexport { defineEventAttribute, EventTarget }\nexport default EventTarget\n","import EventTarget, { defineEventAttribute } from 'event-target-shim';\n\nexport default EventTarget;\nexport { defineEventAttribute, EventTarget };\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}