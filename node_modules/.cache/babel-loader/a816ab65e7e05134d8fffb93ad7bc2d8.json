{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) {\n    if (b.hasOwnProperty(p)) d[p] = b[p];\n  }\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar root_1 = require('../util/root');\n\nvar Observable_1 = require('../Observable');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar PromiseObservable = function (_super) {\n  __extends(PromiseObservable, _super);\n\n  function PromiseObservable(promise, scheduler) {\n    _super.call(this);\n\n    this.promise = promise;\n    this.scheduler = scheduler;\n  }\n  /**\n   * Converts a Promise to an Observable.\n   *\n   * <span class=\"informal\">Returns an Observable that just emits the Promise's\n   * resolved value, then completes.</span>\n   *\n   * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an\n   * Observable. If the Promise resolves with a value, the output Observable\n   * emits that resolved value as a `next`, and then completes. If the Promise\n   * is rejected, then the output Observable emits the corresponding Error.\n   *\n   * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>\n   * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));\n   * result.subscribe(x => console.log(x), e => console.error(e));\n   *\n   * @see {@link bindCallback}\n   * @see {@link from}\n   *\n   * @param {PromiseLike<T>} promise The promise to be converted.\n   * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling\n   * the delivery of the resolved value (or the rejection).\n   * @return {Observable<T>} An Observable which wraps the Promise.\n   * @static true\n   * @name fromPromise\n   * @owner Observable\n   */\n\n\n  PromiseObservable.create = function (promise, scheduler) {\n    return new PromiseObservable(promise, scheduler);\n  };\n  /** @deprecated internal use only */\n\n\n  PromiseObservable.prototype._subscribe = function (subscriber) {\n    var _this = this;\n\n    var promise = this.promise;\n    var scheduler = this.scheduler;\n\n    if (scheduler == null) {\n      if (this._isScalar) {\n        if (!subscriber.closed) {\n          subscriber.next(this.value);\n          subscriber.complete();\n        }\n      } else {\n        promise.then(function (value) {\n          _this.value = value;\n          _this._isScalar = true;\n\n          if (!subscriber.closed) {\n            subscriber.next(value);\n            subscriber.complete();\n          }\n        }, function (err) {\n          if (!subscriber.closed) {\n            subscriber.error(err);\n          }\n        }).then(null, function (err) {\n          // escape the promise trap, throw unhandled errors\n          root_1.root.setTimeout(function () {\n            throw err;\n          });\n        });\n      }\n    } else {\n      if (this._isScalar) {\n        if (!subscriber.closed) {\n          return scheduler.schedule(dispatchNext, 0, {\n            value: this.value,\n            subscriber: subscriber\n          });\n        }\n      } else {\n        promise.then(function (value) {\n          _this.value = value;\n          _this._isScalar = true;\n\n          if (!subscriber.closed) {\n            subscriber.add(scheduler.schedule(dispatchNext, 0, {\n              value: value,\n              subscriber: subscriber\n            }));\n          }\n        }, function (err) {\n          if (!subscriber.closed) {\n            subscriber.add(scheduler.schedule(dispatchError, 0, {\n              err: err,\n              subscriber: subscriber\n            }));\n          }\n        }).then(null, function (err) {\n          // escape the promise trap, throw unhandled errors\n          root_1.root.setTimeout(function () {\n            throw err;\n          });\n        });\n      }\n    }\n  };\n\n  return PromiseObservable;\n}(Observable_1.Observable);\n\nexports.PromiseObservable = PromiseObservable;\n\nfunction dispatchNext(arg) {\n  var value = arg.value,\n      subscriber = arg.subscriber;\n\n  if (!subscriber.closed) {\n    subscriber.next(value);\n    subscriber.complete();\n  }\n}\n\nfunction dispatchError(arg) {\n  var err = arg.err,\n      subscriber = arg.subscriber;\n\n  if (!subscriber.closed) {\n    subscriber.error(err);\n  }\n}","map":{"version":3,"sources":["../../src/observable/PromiseObservable.ts"],"names":[],"mappings":"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","sourcesContent":["import { root } from '../util/root';\nimport { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { TeardownLogic } from '../Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class PromiseObservable<T> extends Observable<T> {\n\n  public value: T;\n\n  /**\n   * Converts a Promise to an Observable.\n   *\n   * <span class=\"informal\">Returns an Observable that just emits the Promise's\n   * resolved value, then completes.</span>\n   *\n   * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an\n   * Observable. If the Promise resolves with a value, the output Observable\n   * emits that resolved value as a `next`, and then completes. If the Promise\n   * is rejected, then the output Observable emits the corresponding Error.\n   *\n   * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>\n   * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));\n   * result.subscribe(x => console.log(x), e => console.error(e));\n   *\n   * @see {@link bindCallback}\n   * @see {@link from}\n   *\n   * @param {PromiseLike<T>} promise The promise to be converted.\n   * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling\n   * the delivery of the resolved value (or the rejection).\n   * @return {Observable<T>} An Observable which wraps the Promise.\n   * @static true\n   * @name fromPromise\n   * @owner Observable\n   */\n  static create<T>(promise: PromiseLike<T>, scheduler?: IScheduler): Observable<T> {\n    return new PromiseObservable(promise, scheduler);\n  }\n\n  constructor(private promise: PromiseLike<T>, private scheduler?: IScheduler) {\n    super();\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n    const promise = this.promise;\n    const scheduler = this.scheduler;\n\n    if (scheduler == null) {\n      if (this._isScalar) {\n        if (!subscriber.closed) {\n          subscriber.next(this.value);\n          subscriber.complete();\n        }\n      } else {\n        promise.then(\n          (value) => {\n            this.value = value;\n            this._isScalar = true;\n            if (!subscriber.closed) {\n              subscriber.next(value);\n              subscriber.complete();\n            }\n          },\n          (err) => {\n            if (!subscriber.closed) {\n              subscriber.error(err);\n            }\n          }\n        )\n        .then(null, err => {\n          // escape the promise trap, throw unhandled errors\n          root.setTimeout(() => { throw err; });\n        });\n      }\n    } else {\n      if (this._isScalar) {\n        if (!subscriber.closed) {\n          return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber });\n        }\n      } else {\n        promise.then(\n          (value) => {\n            this.value = value;\n            this._isScalar = true;\n            if (!subscriber.closed) {\n              subscriber.add(scheduler.schedule(dispatchNext, 0, { value, subscriber }));\n            }\n          },\n          (err) => {\n            if (!subscriber.closed) {\n              subscriber.add(scheduler.schedule(dispatchError, 0, { err, subscriber }));\n            }\n          })\n          .then(null, (err) => {\n            // escape the promise trap, throw unhandled errors\n            root.setTimeout(() => { throw err; });\n          });\n      }\n    }\n  }\n}\n\ninterface DispatchNextArg<T> {\n  subscriber: Subscriber<T>;\n  value: T;\n}\nfunction dispatchNext<T>(arg: DispatchNextArg<T>) {\n  const { value, subscriber } = arg;\n  if (!subscriber.closed) {\n    subscriber.next(value);\n    subscriber.complete();\n  }\n}\n\ninterface DispatchErrorArg<T> {\n  subscriber: Subscriber<T>;\n  err: any;\n}\nfunction dispatchError<T>(arg: DispatchErrorArg<T>) {\n  const { err, subscriber } = arg;\n  if (!subscriber.closed) {\n    subscriber.error(err);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}