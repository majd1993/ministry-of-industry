{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { ConnectionState, createNoDashGuid, Deferred, MessageType, Promise, PromiseHelper } from \"../../common/Exports\";\nimport { Sink } from \"../../common/Promise\";\nimport { CancellationErrorCode, CancellationReason, ConversationExpirationEventArgs, ConversationTranslationCanceledEventArgs, ConversationTranslationResult, PropertyId, SessionEventArgs, Translations } from \"../../sdk/Exports\";\nimport { ServiceRecognizerBase } from \"../Exports\";\nimport { ConversationConnectionMessage } from \"./ConversationConnectionMessage\";\nimport { ConversationRequestSession } from \"./ConversationRequestSession\";\nimport { ConversationReceivedTranslationEventArgs, LockRoomEventArgs, MuteAllEventArgs, ParticipantAttributeEventArgs, ParticipantEventArgs, ParticipantsListEventArgs } from \"./ConversationTranslatorEventArgs\";\nimport { ConversationTranslatorCommandTypes, ConversationTranslatorMessageTypes } from \"./ConversationTranslatorInterfaces\";\nimport { CommandResponsePayload, ParticipantPayloadResponse, ParticipantsListPayloadResponse, SpeechResponsePayload, TextResponsePayload } from \"./ServiceMessages/Exports\";\n/***\n * The service adapter handles sending and receiving messages to the Conversation Translator websocket.\n */\n\nexport var ConversationServiceAdapter = /*#__PURE__*/function (_ServiceRecognizerBas) {\n  _inherits(ConversationServiceAdapter, _ServiceRecognizerBas);\n\n  var _super = _createSuper(ConversationServiceAdapter);\n\n  function ConversationServiceAdapter(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector) {\n    var _this;\n\n    _classCallCheck(this, ConversationServiceAdapter);\n\n    _this = _super.call(this, authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector);\n    _this.privLastPartialUtteranceId = \"\";\n\n    _this.sendMessageAsync = function (message) {\n      var sink = new Sink();\n\n      _this.fetchConversationConnection().continueWith(function (antecedent) {\n        try {\n          if (antecedent.isError) {\n            sink.reject(antecedent.error);\n          } else {\n            antecedent.result.send(new ConversationConnectionMessage(MessageType.Text, message)).continueWith(function (innerAntecedent) {\n              try {\n                if (innerAntecedent.isError) {\n                  sink.reject(innerAntecedent.error);\n                } else {\n                  sink.resolve(innerAntecedent.result);\n                }\n              } catch (e) {\n                sink.reject(\"Unhandled inner error: \".concat(e));\n              }\n            });\n          }\n        } catch (e) {\n          sink.reject(\"Unhandled error: \".concat(e));\n        }\n      });\n\n      return new Promise(sink);\n    };\n\n    _this.noOp = function () {// operation not supported\n    };\n    /**\n     * Process incoming websocket messages\n     */\n\n\n    _this.receiveConversationMessageOverride = function (successCallback, errorCallBack) {\n      // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\n      var communicationCustodian = new Deferred();\n\n      _this.fetchConversationConnection().on(function (connection) {\n        return connection.read().onSuccessContinueWithPromise(function (message) {\n          var isDisposed = _this.isDisposed();\n\n          var terminateMessageLoop = !_this.isDisposed() && _this.terminateMessageLoop;\n          var sessionId = _this.privConversationRequestSession.sessionId;\n          var sendFinal = false;\n\n          if (isDisposed || terminateMessageLoop) {\n            // We're done.\n            communicationCustodian.resolve(undefined);\n            return PromiseHelper.fromResult(undefined);\n          }\n\n          if (!message) {\n            return _this.receiveConversationMessageOverride();\n          }\n\n          try {\n            switch (message.conversationMessageType.toLowerCase()) {\n              case \"info\":\n              case \"participant_command\":\n              case \"command\":\n                var commandPayload = CommandResponsePayload.fromJSON(message.textBody);\n\n                switch (commandPayload.command.toLowerCase()) {\n                  /**\n                   * 'ParticpantList' is the first message sent to the user after the websocket connection has opened.\n                   * The consuming client must wait for this message to arrive\n                   * before starting to send their own data.\n                   */\n                  case \"participantlist\":\n                    var participantsPayload = ParticipantsListPayloadResponse.fromJSON(message.textBody);\n                    var participantsResult = participantsPayload.participants.map(function (p) {\n                      var participant = {\n                        avatar: p.avatar,\n                        displayName: p.nickname,\n                        id: p.participantId,\n                        isHost: p.ishost,\n                        isMuted: p.ismuted,\n                        isUsingTts: p.usetts,\n                        preferredLanguage: p.locale\n                      };\n                      return participant;\n                    });\n\n                    if (!!_this.privConversationServiceConnector.participantsListReceived) {\n                      _this.privConversationServiceConnector.participantsListReceived(_this.privConversationServiceConnector, new ParticipantsListEventArgs(participantsPayload.roomid, participantsPayload.token, participantsPayload.translateTo, participantsPayload.profanityFilter, participantsPayload.roomProfanityFilter, participantsPayload.roomLocked, participantsPayload.muteAll, participantsResult, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'SetTranslateToLanguages' represents the list of languages being used in the Conversation by all users(?).\n                   * This is sent at the start of the Conversation\n                   */\n\n                  case \"settranslatetolanguages\":\n                    if (!!_this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                      _this.privConversationServiceConnector.participantUpdateCommandReceived(_this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.setTranslateToLanguages, commandPayload.value, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'SetProfanityFiltering' lets the client set the level of profanity filtering.\n                   * If sent by the participant the setting will effect only their own profanity level.\n                   * If sent by the host, the setting will effect all participants including the host.\n                   * Note: the profanity filters differ from Speech Service (?): 'marked', 'raw', 'removed', 'tagged'\n                   */\n\n                  case \"setprofanityfiltering\":\n                    if (!!_this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                      _this.privConversationServiceConnector.participantUpdateCommandReceived(_this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.setProfanityFiltering, commandPayload.value, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'SetMute' is sent if the participant has been muted by the host.\n                   * Check the 'participantId' to determine if the current user has been muted.\n                   */\n\n                  case \"setmute\":\n                    if (!!_this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                      _this.privConversationServiceConnector.participantUpdateCommandReceived(_this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.setMute, commandPayload.value, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'SetMuteAll' is sent if the Conversation has been muted by the host.\n                   */\n\n                  case \"setmuteall\":\n                    if (!!_this.privConversationServiceConnector.muteAllCommandReceived) {\n                      _this.privConversationServiceConnector.muteAllCommandReceived(_this.privConversationServiceConnector, new MuteAllEventArgs(commandPayload.value, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'RoomExpirationWarning' is sent towards the end of the Conversation session to give a timeout warning.\n                   */\n\n                  case \"roomexpirationwarning\":\n                    if (!!_this.privConversationServiceConnector.conversationExpiration) {\n                      _this.privConversationServiceConnector.conversationExpiration(_this.privConversationServiceConnector, new ConversationExpirationEventArgs(commandPayload.value, _this.privConversationRequestSession.sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'SetUseTts' is sent as a confirmation if the user requests TTS to be turned on or off.\n                   */\n\n                  case \"setusetts\":\n                    if (!!_this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                      _this.privConversationServiceConnector.participantUpdateCommandReceived(_this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.setUseTTS, commandPayload.value, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'SetLockState' is set if the host has locked or unlocked the Conversation.\n                   */\n\n                  case \"setlockstate\":\n                    if (!!_this.privConversationServiceConnector.lockRoomCommandReceived) {\n                      _this.privConversationServiceConnector.lockRoomCommandReceived(_this.privConversationServiceConnector, new LockRoomEventArgs(commandPayload.value, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'ChangeNickname' is received if a user changes their display name.\n                   * Any cached particpiants list should be updated to reflect the display name.\n                   */\n\n                  case \"changenickname\":\n                    if (!!_this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                      _this.privConversationServiceConnector.participantUpdateCommandReceived(_this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.changeNickname, commandPayload.nickname, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'JoinSession' is sent when a user joins the Conversation.\n                   */\n\n                  case \"joinsession\":\n                    var joinParticipantPayload = ParticipantPayloadResponse.fromJSON(message.textBody);\n                    var joiningParticipant = {\n                      avatar: joinParticipantPayload.avatar,\n                      displayName: joinParticipantPayload.nickname,\n                      id: joinParticipantPayload.participantId,\n                      isHost: joinParticipantPayload.ishost,\n                      isMuted: joinParticipantPayload.ismuted,\n                      isUsingTts: joinParticipantPayload.usetts,\n                      preferredLanguage: joinParticipantPayload.locale\n                    };\n\n                    if (!!_this.privConversationServiceConnector.participantJoinCommandReceived) {\n                      _this.privConversationServiceConnector.participantJoinCommandReceived(_this.privConversationServiceConnector, new ParticipantEventArgs(joiningParticipant, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'LeaveSession' is sent when a user leaves the Conversation'.\n                   */\n\n                  case \"leavesession\":\n                    var leavingParticipant = {\n                      id: commandPayload.participantId\n                    };\n\n                    if (!!_this.privConversationServiceConnector.participantLeaveCommandReceived) {\n                      _this.privConversationServiceConnector.participantLeaveCommandReceived(_this.privConversationServiceConnector, new ParticipantEventArgs(leavingParticipant, sessionId));\n                    }\n\n                    break;\n\n                  /**\n                   * 'DisconnectSession' is sent when a user is disconnected from the session (e.g. network problem).\n                   * Check the 'ParticipantId' to check whether the message is for the current user.\n                   */\n\n                  case \"disconnectsession\":\n                    var disconnectParticipant = {\n                      id: commandPayload.participantId\n                    };\n                    break;\n\n                  /**\n                   * Message not recognized.\n                   */\n\n                  default:\n                    break;\n                }\n\n                break;\n\n              /**\n               * 'partial' (or 'hypothesis') represents a unfinalized speech message.\n               */\n\n              case \"partial\":\n              /**\n               * 'final' (or 'phrase') represents a finalized speech message.\n               */\n\n              case \"final\":\n                var speechPayload = SpeechResponsePayload.fromJSON(message.textBody);\n                var speechResult = new ConversationTranslationResult(speechPayload.participantId, _this.getTranslations(speechPayload.translations), speechPayload.language, undefined, undefined, speechPayload.recognition, undefined, undefined, message.textBody, undefined);\n\n                if (speechPayload.isFinal) {\n                  // check the length, sometimes empty finals are returned\n                  if (speechResult.text !== undefined && speechResult.text.length > 0) {\n                    sendFinal = true;\n                  } else if (speechPayload.id === _this.privLastPartialUtteranceId) {\n                    // send final as normal. We had a non-empty partial for this same utterance\n                    // so sending the empty final is important\n                    sendFinal = true;\n                  } else {// suppress unneeded final\n                  }\n\n                  if (sendFinal) {\n                    if (!!_this.privConversationServiceConnector.translationReceived) {\n                      _this.privConversationServiceConnector.translationReceived(_this.privConversationServiceConnector, new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.final, speechResult, sessionId));\n                    }\n                  }\n                } else if (speechResult.text !== undefined) {\n                  _this.privLastPartialUtteranceId = speechPayload.id;\n\n                  if (!!_this.privConversationServiceConnector.translationReceived) {\n                    _this.privConversationServiceConnector.translationReceived(_this.privConversationServiceConnector, new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.partial, speechResult, sessionId));\n                  }\n                }\n\n                break;\n\n              /**\n               * \"translated_message\" is a text message or instant message (IM).\n               */\n\n              case \"translated_message\":\n                var textPayload = TextResponsePayload.fromJSON(message.textBody);\n                var textResult = new ConversationTranslationResult(textPayload.participantId, _this.getTranslations(textPayload.translations), textPayload.language, undefined, undefined, textPayload.originalText, undefined, undefined, undefined, message.textBody, undefined);\n\n                if (!!_this.privConversationServiceConnector.translationReceived) {\n                  _this.privConversationServiceConnector.translationReceived(_this.privConversationServiceConnector, new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.instantMessage, textResult, sessionId));\n                }\n\n                break;\n\n              default:\n                // ignore any unsupported message types\n                break;\n            }\n          } catch (e) {// continue\n          }\n\n          return _this.receiveConversationMessageOverride();\n        });\n      }, function (error) {\n        _this.terminateMessageLoop = true;\n      });\n\n      return communicationCustodian.promise();\n    };\n\n    _this.fetchConversationConnection = function () {\n      return _this.configConnection();\n    };\n\n    _this.privConversationServiceConnector = conversationServiceConnector;\n    _this.privConversationAuthentication = authentication;\n    _this.receiveMessageOverride = _this.receiveConversationMessageOverride;\n    _this.recognizeOverride = _this.noOp;\n    _this.connectImplOverride = _this.conversationConnectImpl;\n    _this.configConnectionOverride = _this.configConnection;\n    _this.fetchConnectionOverride = _this.fetchConversationConnection;\n    _this.disconnectOverride = _this.privDisconnect;\n    _this.privConversationRequestSession = new ConversationRequestSession(createNoDashGuid());\n    _this.privConversationConnectionFactory = connectionFactory;\n    _this.privConversationIsDisposed = false;\n    return _this;\n  }\n\n  _createClass(ConversationServiceAdapter, [{\n    key: \"isDisposed\",\n    value: function isDisposed() {\n      return this.privConversationIsDisposed;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose(reason) {\n      this.privConversationIsDisposed = true;\n\n      if (this.privConnectionConfigPromise) {\n        this.privConnectionConfigPromise.onSuccessContinueWith(function (connection) {\n          connection.dispose(reason);\n        });\n      }\n    }\n  }, {\n    key: \"sendMessage\",\n    value: function sendMessage(message) {\n      this.fetchConversationConnection().onSuccessContinueWith(function (connection) {\n        connection.send(new ConversationConnectionMessage(MessageType.Text, message));\n      });\n    }\n  }, {\n    key: \"privDisconnect\",\n    value: function privDisconnect() {\n      if (this.terminateMessageLoop) {\n        return;\n      }\n\n      this.cancelRecognition(this.privConversationRequestSession.sessionId, this.privConversationRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.NoError, \"Disconnecting\");\n      this.terminateMessageLoop = true;\n\n      if (this.privConversationConnectionPromise.result().isCompleted) {\n        if (!this.privConversationConnectionPromise.result().isError) {\n          this.privConversationConnectionPromise.result().result.dispose();\n          this.privConversationConnectionPromise = null;\n        }\n      } else {\n        this.privConversationConnectionPromise.onSuccessContinueWith(function (connection) {\n          connection.dispose();\n        });\n      }\n    }\n  }, {\n    key: \"processTypeSpecificMessages\",\n    value: function processTypeSpecificMessages(connectionMessage, successCallback, errorCallBack) {\n      return true;\n    } // Cancels recognition.\n\n  }, {\n    key: \"cancelRecognition\",\n    value: function cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n      this.terminateMessageLoop = true;\n      var cancelEvent = new ConversationTranslationCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);\n\n      try {\n        if (!!this.privConversationServiceConnector.canceled) {\n          this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, cancelEvent);\n        }\n      } catch (_a) {// continue on error\n      }\n    }\n    /**\n     * Establishes a websocket connection to the end point.\n     * @param isUnAuthorized\n     */\n\n  }, {\n    key: \"conversationConnectImpl\",\n    value: function conversationConnectImpl() {\n      var _this2 = this;\n\n      var isUnAuthorized = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.privConversationConnectionPromise) {\n        if (this.privConversationConnectionPromise.result().isCompleted && (this.privConversationConnectionPromise.result().isError || this.privConversationConnectionPromise.result().result.state() === ConnectionState.Disconnected)) {\n          this.privConnectionId = null;\n          this.privConversationConnectionPromise = null;\n          this.terminateMessageLoop = true;\n          return this.conversationConnectImpl();\n        } else {\n          return this.privConversationConnectionPromise;\n        }\n      }\n\n      this.privConversationAuthFetchEventId = createNoDashGuid(); // keep the connectionId for reconnect events\n\n      if (this.privConnectionId === undefined) {\n        this.privConnectionId = createNoDashGuid();\n      }\n\n      this.privConversationRequestSession.onPreConnectionStart(this.privConversationAuthFetchEventId, this.privConnectionId);\n      var authPromise = isUnAuthorized ? this.privConversationAuthentication.fetchOnExpiry(this.privConversationAuthFetchEventId) : this.privConversationAuthentication.fetch(this.privConversationAuthFetchEventId);\n      this.privConversationConnectionPromise = authPromise.continueWithPromise(function (result) {\n        if (result.isError) {\n          _this2.privConversationRequestSession.onAuthCompleted(true, result.error);\n\n          throw new Error(result.error);\n        } else {\n          _this2.privConversationRequestSession.onAuthCompleted(false);\n        }\n\n        var connection = _this2.privConversationConnectionFactory.create(_this2.privRecognizerConfig, result.result, _this2.privConnectionId); // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\n        // it'll stop sending events.\n\n\n        connection.events.attach(function (event) {\n          _this2.connectionEvents.onEvent(event);\n        });\n        return connection.open().onSuccessContinueWithPromise(function (response) {\n          if (response.statusCode === 200) {\n            _this2.privConversationRequestSession.onPreConnectionStart(_this2.privConversationAuthFetchEventId, _this2.privConnectionId);\n\n            _this2.privConversationRequestSession.onConnectionEstablishCompleted(response.statusCode);\n\n            var sessionStartEventArgs = new SessionEventArgs(_this2.privConversationRequestSession.sessionId);\n\n            if (!!_this2.privConversationServiceConnector.connectionOpened) {\n              _this2.privConversationServiceConnector.connectionOpened(_this2.privConversationServiceConnector, sessionStartEventArgs);\n            }\n\n            return PromiseHelper.fromResult(connection);\n          } else if (response.statusCode === 403 && !isUnAuthorized) {\n            return _this2.conversationConnectImpl(true);\n          } else {\n            _this2.privConversationRequestSession.onConnectionEstablishCompleted(response.statusCode, response.reason);\n\n            return PromiseHelper.fromError(\"Unable to contact server. StatusCode: \".concat(response.statusCode, \", \").concat(_this2.privRecognizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint), \" Reason: \").concat(response.reason));\n          }\n        });\n      });\n      this.privConnectionLoop = this.startMessageLoop();\n      return this.privConversationConnectionPromise;\n    }\n  }, {\n    key: \"startMessageLoop\",\n    value: function startMessageLoop() {\n      var _this3 = this;\n\n      this.terminateMessageLoop = false;\n      var messageRetrievalPromise = this.receiveConversationMessageOverride();\n      return messageRetrievalPromise.on(function (r) {\n        return true;\n      }, function (error) {\n        _this3.cancelRecognition(_this3.privRequestSession ? _this3.privRequestSession.sessionId : \"\", _this3.privRequestSession ? _this3.privRequestSession.requestId : \"\", CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\n      });\n    } // Takes an established websocket connection to the endpoint\n\n  }, {\n    key: \"configConnection\",\n    value: function configConnection() {\n      if (this.privConnectionConfigPromise) {\n        if (this.privConnectionConfigPromise.result().isCompleted && (this.privConnectionConfigPromise.result().isError || this.privConnectionConfigPromise.result().result.state() === ConnectionState.Disconnected)) {\n          this.privConnectionConfigPromise = null;\n          return this.configConnection();\n        } else {\n          return this.privConnectionConfigPromise;\n        }\n      }\n\n      if (this.terminateMessageLoop) {\n        return PromiseHelper.fromResult(undefined);\n      }\n\n      this.privConnectionConfigPromise = this.conversationConnectImpl().onSuccessContinueWith(function (connection) {\n        return connection;\n      });\n      return this.privConnectionConfigPromise;\n    }\n  }, {\n    key: \"getTranslations\",\n    value: function getTranslations(serviceResultTranslations) {\n      var translations;\n\n      if (undefined !== serviceResultTranslations) {\n        translations = new Translations();\n\n        var _iterator = _createForOfIteratorHelper(serviceResultTranslations),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var translation = _step.value;\n            translations.set(translation.lang, translation.translation);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      return translations;\n    }\n  }]);\n\n  return ConversationServiceAdapter;\n}(ServiceRecognizerBase);","map":{"version":3,"sources":["src/common.speech/Transcription/ConversationServiceAdapter.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ConnectionEvent,\r\n    ConnectionMessage,\r\n    ConnectionOpenResponse,\r\n    ConnectionState,\r\n    createNoDashGuid,\r\n    Deferred,\r\n    IAudioSource,\r\n    IConnection,\r\n    MessageType,\r\n    Promise,\r\n    PromiseHelper,\r\n    PromiseResult\r\n} from \"../../common/Exports\";\r\nimport { Sink } from \"../../common/Promise\";\r\nimport {\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    ConversationExpirationEventArgs,\r\n    ConversationTranslationCanceledEventArgs,\r\n    ConversationTranslationResult,\r\n    PropertyId,\r\n    SessionEventArgs,\r\n    SpeechRecognitionResult,\r\n    Translations\r\n} from \"../../sdk/Exports\";\r\nimport {\r\n    AuthInfo, IAuthentication, IConnectionFactory, RecognizerConfig, ServiceRecognizerBase\r\n} from \"../Exports\";\r\nimport { ConversationConnectionMessage } from \"./ConversationConnectionMessage\";\r\nimport { ConversationRequestSession } from \"./ConversationRequestSession\";\r\nimport {\r\n    ConversationReceivedTranslationEventArgs,\r\n    LockRoomEventArgs,\r\n    MuteAllEventArgs,\r\n    ParticipantAttributeEventArgs,\r\n    ParticipantEventArgs,\r\n    ParticipantsListEventArgs\r\n} from \"./ConversationTranslatorEventArgs\";\r\nimport { ConversationTranslatorCommandTypes, ConversationTranslatorMessageTypes, IInternalParticipant } from \"./ConversationTranslatorInterfaces\";\r\nimport { ConversationTranslatorRecognizer } from \"./ConversationTranslatorRecognizer\";\r\nimport {\r\n    CommandResponsePayload,\r\n    IParticipantPayloadResponse,\r\n    IParticipantsListPayloadResponse,\r\n    ITranslationResponsePayload,\r\n    ParticipantPayloadResponse,\r\n    ParticipantsListPayloadResponse,\r\n    SpeechResponsePayload,\r\n    TextResponsePayload\r\n} from \"./ServiceMessages/Exports\";\r\n\r\n/***\r\n * The service adapter handles sending and receiving messages to the Conversation Translator websocket.\r\n */\r\nexport class ConversationServiceAdapter extends ServiceRecognizerBase {\r\n    private privConversationServiceConnector: ConversationTranslatorRecognizer;\r\n    private privConversationConnectionFactory: IConnectionFactory;\r\n    private privConversationAuthFetchEventId: string;\r\n    private privConversationAuthentication: IAuthentication;\r\n    private privConversationRequestSession: ConversationRequestSession;\r\n    private privConnectionConfigPromise: Promise<IConnection>;\r\n    private privConversationConnectionPromise: Promise<IConnection>;\r\n    private privConnectionLoop: Promise<IConnection>;\r\n    private terminateMessageLoop: boolean;\r\n    private privLastPartialUtteranceId: string = \"\";\r\n    private privConversationIsDisposed: boolean;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: IConnectionFactory,\r\n        audioSource: IAudioSource,\r\n        recognizerConfig: RecognizerConfig,\r\n        conversationServiceConnector: ConversationTranslatorRecognizer) {\r\n\r\n        super(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector);\r\n\r\n        this.privConversationServiceConnector = conversationServiceConnector;\r\n        this.privConversationAuthentication = authentication;\r\n        this.receiveMessageOverride = this.receiveConversationMessageOverride;\r\n        this.recognizeOverride = this.noOp;\r\n        this.connectImplOverride = this.conversationConnectImpl;\r\n        this.configConnectionOverride = this.configConnection;\r\n        this.fetchConnectionOverride = this.fetchConversationConnection;\r\n        this.disconnectOverride = this.privDisconnect;\r\n        this.privConversationRequestSession = new ConversationRequestSession(createNoDashGuid());\r\n        this.privConversationConnectionFactory = connectionFactory;\r\n        this.privConversationIsDisposed = false;\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return this.privConversationIsDisposed;\r\n    }\r\n\r\n    public dispose(reason?: string): void {\r\n        this.privConversationIsDisposed = true;\r\n        if (this.privConnectionConfigPromise) {\r\n            this.privConnectionConfigPromise.onSuccessContinueWith((connection: IConnection) => {\r\n                connection.dispose(reason);\r\n            });\r\n        }\r\n    }\r\n\r\n    public sendMessage(message: string): void {\r\n        this.fetchConversationConnection().onSuccessContinueWith((connection: IConnection) => {\r\n            connection.send(new ConversationConnectionMessage(\r\n                MessageType.Text,\r\n                message));\r\n        });\r\n    }\r\n\r\n    public sendMessageAsync = (message: string): Promise<boolean> => {\r\n        const sink: Sink<boolean> = new Sink<boolean>();\r\n\r\n        this.fetchConversationConnection().continueWith((antecedent: PromiseResult<IConnection>): void => {\r\n            try {\r\n                if (antecedent.isError) {\r\n                    sink.reject(antecedent.error);\r\n                } else {\r\n                    antecedent.result.send(new ConversationConnectionMessage(MessageType.Text, message))\r\n                        .continueWith((innerAntecedent: PromiseResult<boolean>): void => {\r\n                            try {\r\n                                if (innerAntecedent.isError) {\r\n                                    sink.reject(innerAntecedent.error);\r\n                                } else {\r\n                                    sink.resolve(innerAntecedent.result);\r\n                                }\r\n                            } catch (e) {\r\n                                sink.reject(`Unhandled inner error: ${e}`);\r\n                            }\r\n                        });\r\n                }\r\n            } catch (e) {\r\n                sink.reject(`Unhandled error: ${e}`);\r\n            }\r\n        });\r\n\r\n        return new Promise<boolean>(sink);\r\n    }\r\n\r\n    protected privDisconnect(): void {\r\n        if (this.terminateMessageLoop) {\r\n            return;\r\n        }\r\n        this.cancelRecognition(this.privConversationRequestSession.sessionId,\r\n            this.privConversationRequestSession.requestId,\r\n            CancellationReason.Error,\r\n            CancellationErrorCode.NoError,\r\n            \"Disconnecting\");\r\n\r\n        this.terminateMessageLoop = true;\r\n        if (this.privConversationConnectionPromise.result().isCompleted) {\r\n            if (!this.privConversationConnectionPromise.result().isError) {\r\n                this.privConversationConnectionPromise.result().result.dispose();\r\n                this.privConversationConnectionPromise = null;\r\n            }\r\n        } else {\r\n            this.privConversationConnectionPromise.onSuccessContinueWith((connection: IConnection) => {\r\n                connection.dispose();\r\n            });\r\n        }\r\n    }\r\n\r\n    protected processTypeSpecificMessages(\r\n        connectionMessage: ConnectionMessage,\r\n        successCallback?: (e: any) => void,\r\n        errorCallBack?: (e: string) => void): boolean {\r\n        return true;\r\n    }\r\n\r\n    // Cancels recognition.\r\n    protected cancelRecognition(\r\n        sessionId: string,\r\n        requestId: string,\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void {\r\n\r\n        this.terminateMessageLoop = true;\r\n\r\n        const cancelEvent: ConversationTranslationCanceledEventArgs = new ConversationTranslationCanceledEventArgs(\r\n            cancellationReason,\r\n            error,\r\n            errorCode,\r\n            undefined,\r\n            sessionId);\r\n\r\n        try {\r\n            if (!!this.privConversationServiceConnector.canceled) {\r\n                this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, cancelEvent);\r\n            }\r\n        } catch {\r\n            // continue on error\r\n        }\r\n    }\r\n\r\n    protected noOp = (): any => {\r\n        // operation not supported\r\n    }\r\n\r\n    /**\r\n     * Establishes a websocket connection to the end point.\r\n     * @param isUnAuthorized\r\n     */\r\n    protected conversationConnectImpl(isUnAuthorized: boolean = false): Promise<IConnection> {\r\n\r\n        if (this.privConversationConnectionPromise) {\r\n            if (this.privConversationConnectionPromise.result().isCompleted &&\r\n                (this.privConversationConnectionPromise.result().isError\r\n                    || this.privConversationConnectionPromise.result().result.state() === ConnectionState.Disconnected)) {\r\n                this.privConnectionId = null;\r\n                this.privConversationConnectionPromise = null;\r\n                this.terminateMessageLoop = true;\r\n                return this.conversationConnectImpl();\r\n            } else {\r\n                return this.privConversationConnectionPromise;\r\n            }\r\n        }\r\n\r\n        this.privConversationAuthFetchEventId = createNoDashGuid();\r\n\r\n        // keep the connectionId for reconnect events\r\n        if (this.privConnectionId === undefined) {\r\n            this.privConnectionId = createNoDashGuid();\r\n        }\r\n\r\n        this.privConversationRequestSession.onPreConnectionStart(this.privConversationAuthFetchEventId, this.privConnectionId);\r\n\r\n        const authPromise = isUnAuthorized ? this.privConversationAuthentication.fetchOnExpiry(this.privConversationAuthFetchEventId) : this.privConversationAuthentication.fetch(this.privConversationAuthFetchEventId);\r\n\r\n        this.privConversationConnectionPromise = authPromise\r\n            .continueWithPromise((result: PromiseResult<AuthInfo>) => {\r\n                if (result.isError) {\r\n                    this.privConversationRequestSession.onAuthCompleted(true, result.error);\r\n                    throw new Error(result.error);\r\n                } else {\r\n                    this.privConversationRequestSession.onAuthCompleted(false);\r\n                }\r\n\r\n                const connection: IConnection = this.privConversationConnectionFactory.create(this.privRecognizerConfig, result.result, this.privConnectionId);\r\n\r\n                // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\r\n                // it'll stop sending events.\r\n                connection.events.attach((event: ConnectionEvent) => {\r\n                    this.connectionEvents.onEvent(event);\r\n                });\r\n\r\n                return connection.open().onSuccessContinueWithPromise((response: ConnectionOpenResponse): Promise<IConnection> => {\r\n                    if (response.statusCode === 200) {\r\n                        this.privConversationRequestSession.onPreConnectionStart(this.privConversationAuthFetchEventId, this.privConnectionId);\r\n                        this.privConversationRequestSession.onConnectionEstablishCompleted(response.statusCode);\r\n                        const sessionStartEventArgs: SessionEventArgs = new SessionEventArgs(this.privConversationRequestSession.sessionId);\r\n                        if (!!this.privConversationServiceConnector.connectionOpened) {\r\n                            this.privConversationServiceConnector.connectionOpened(this.privConversationServiceConnector, sessionStartEventArgs);\r\n                        }\r\n                        return PromiseHelper.fromResult<IConnection>(connection);\r\n                    } else if (response.statusCode === 403 && !isUnAuthorized) {\r\n                        return this.conversationConnectImpl(true);\r\n                    } else {\r\n                        this.privConversationRequestSession.onConnectionEstablishCompleted(response.statusCode, response.reason);\r\n                        return PromiseHelper.fromError<IConnection>(`Unable to contact server. StatusCode: ${response.statusCode}, ${this.privRecognizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${response.reason}`);\r\n                    }\r\n                });\r\n            });\r\n\r\n        this.privConnectionLoop = this.startMessageLoop();\r\n        return this.privConversationConnectionPromise;\r\n    }\r\n\r\n    /**\r\n     * Process incoming websocket messages\r\n     */\r\n    private receiveConversationMessageOverride = (\r\n        successCallback?: (e: any) => void,\r\n        errorCallBack?: (e: string) => void\r\n    ): Promise<IConnection> => {\r\n\r\n        // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\r\n        const communicationCustodian: Deferred<IConnection> = new Deferred<IConnection>();\r\n\r\n        this.fetchConversationConnection().on((connection: IConnection): Promise<IConnection> => {\r\n            return connection.read().onSuccessContinueWithPromise((message: ConversationConnectionMessage): Promise<IConnection> => {\r\n                const isDisposed: boolean = this.isDisposed();\r\n                const terminateMessageLoop = (!this.isDisposed() && this.terminateMessageLoop);\r\n                const sessionId: string = this.privConversationRequestSession.sessionId;\r\n                let sendFinal: boolean = false;\r\n                if (isDisposed || terminateMessageLoop) {\r\n                    // We're done.\r\n                    communicationCustodian.resolve(undefined);\r\n                    return PromiseHelper.fromResult<IConnection>(undefined);\r\n                }\r\n\r\n                if (!message) {\r\n                    return this.receiveConversationMessageOverride();\r\n                }\r\n\r\n                try {\r\n                    switch (message.conversationMessageType.toLowerCase()) {\r\n                        case \"info\":\r\n                        case \"participant_command\":\r\n                        case \"command\":\r\n                            const commandPayload: CommandResponsePayload = CommandResponsePayload.fromJSON(message.textBody);\r\n                            switch (commandPayload.command.toLowerCase()) {\r\n\r\n                                /**\r\n                                 * 'ParticpantList' is the first message sent to the user after the websocket connection has opened.\r\n                                 * The consuming client must wait for this message to arrive\r\n                                 * before starting to send their own data.\r\n                                 */\r\n                                case \"participantlist\":\r\n\r\n                                    const participantsPayload: IParticipantsListPayloadResponse = ParticipantsListPayloadResponse.fromJSON(message.textBody);\r\n\r\n                                    const participantsResult: IInternalParticipant[] = participantsPayload.participants.map((p: IParticipantPayloadResponse) => {\r\n                                        const participant: IInternalParticipant = {\r\n                                            avatar: p.avatar,\r\n                                            displayName: p.nickname,\r\n                                            id: p.participantId,\r\n                                            isHost: p.ishost,\r\n                                            isMuted: p.ismuted,\r\n                                            isUsingTts: p.usetts,\r\n                                            preferredLanguage: p.locale\r\n                                        };\r\n                                        return participant;\r\n                                    });\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantsListReceived) {\r\n                                        this.privConversationServiceConnector.participantsListReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantsListEventArgs(participantsPayload.roomid, participantsPayload.token,\r\n                                                participantsPayload.translateTo, participantsPayload.profanityFilter,\r\n                                                participantsPayload.roomProfanityFilter, participantsPayload.roomLocked,\r\n                                                participantsPayload.muteAll, participantsResult, sessionId));\r\n                                    }\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'SetTranslateToLanguages' represents the list of languages being used in the Conversation by all users(?).\r\n                                 * This is sent at the start of the Conversation\r\n                                 */\r\n                                case \"settranslatetolanguages\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                                ConversationTranslatorCommandTypes.setTranslateToLanguages,\r\n                                                commandPayload.value, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'SetProfanityFiltering' lets the client set the level of profanity filtering.\r\n                                 * If sent by the participant the setting will effect only their own profanity level.\r\n                                 * If sent by the host, the setting will effect all participants including the host.\r\n                                 * Note: the profanity filters differ from Speech Service (?): 'marked', 'raw', 'removed', 'tagged'\r\n                                 */\r\n                                case \"setprofanityfiltering\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                                ConversationTranslatorCommandTypes.setProfanityFiltering,\r\n                                                commandPayload.value, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'SetMute' is sent if the participant has been muted by the host.\r\n                                 * Check the 'participantId' to determine if the current user has been muted.\r\n                                 */\r\n                                case \"setmute\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                                ConversationTranslatorCommandTypes.setMute,\r\n                                                commandPayload.value, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'SetMuteAll' is sent if the Conversation has been muted by the host.\r\n                                 */\r\n                                case \"setmuteall\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.muteAllCommandReceived) {\r\n                                        this.privConversationServiceConnector.muteAllCommandReceived(this.privConversationServiceConnector,\r\n                                            new MuteAllEventArgs(commandPayload.value as boolean, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'RoomExpirationWarning' is sent towards the end of the Conversation session to give a timeout warning.\r\n                                 */\r\n                                case \"roomexpirationwarning\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.conversationExpiration) {\r\n                                        this.privConversationServiceConnector.conversationExpiration(this.privConversationServiceConnector,\r\n                                            new ConversationExpirationEventArgs(commandPayload.value as number, this.privConversationRequestSession.sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'SetUseTts' is sent as a confirmation if the user requests TTS to be turned on or off.\r\n                                 */\r\n                                case \"setusetts\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                                ConversationTranslatorCommandTypes.setUseTTS,\r\n                                                commandPayload.value, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'SetLockState' is set if the host has locked or unlocked the Conversation.\r\n                                 */\r\n                                case \"setlockstate\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.lockRoomCommandReceived) {\r\n                                        this.privConversationServiceConnector.lockRoomCommandReceived(this.privConversationServiceConnector,\r\n                                            new LockRoomEventArgs(commandPayload.value as boolean, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'ChangeNickname' is received if a user changes their display name.\r\n                                 * Any cached particpiants list should be updated to reflect the display name.\r\n                                 */\r\n                                case \"changenickname\":\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                                ConversationTranslatorCommandTypes.changeNickname,\r\n                                                commandPayload.nickname, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'JoinSession' is sent when a user joins the Conversation.\r\n                                 */\r\n                                case \"joinsession\":\r\n\r\n                                    const joinParticipantPayload: ParticipantPayloadResponse = ParticipantPayloadResponse.fromJSON(message.textBody);\r\n\r\n                                    const joiningParticipant: IInternalParticipant = {\r\n                                        avatar: joinParticipantPayload.avatar,\r\n                                        displayName: joinParticipantPayload.nickname,\r\n                                        id: joinParticipantPayload.participantId,\r\n                                        isHost: joinParticipantPayload.ishost,\r\n                                        isMuted: joinParticipantPayload.ismuted,\r\n                                        isUsingTts: joinParticipantPayload.usetts,\r\n                                        preferredLanguage: joinParticipantPayload.locale,\r\n                                    };\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantJoinCommandReceived) {\r\n                                        this.privConversationServiceConnector.participantJoinCommandReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantEventArgs(\r\n                                                joiningParticipant,\r\n                                                sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'LeaveSession' is sent when a user leaves the Conversation'.\r\n                                 */\r\n                                case \"leavesession\":\r\n\r\n                                    const leavingParticipant: IInternalParticipant = {\r\n                                        id: commandPayload.participantId\r\n                                    };\r\n\r\n                                    if (!!this.privConversationServiceConnector.participantLeaveCommandReceived) {\r\n                                        this.privConversationServiceConnector.participantLeaveCommandReceived(this.privConversationServiceConnector,\r\n                                            new ParticipantEventArgs(leavingParticipant, sessionId));\r\n                                    }\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * 'DisconnectSession' is sent when a user is disconnected from the session (e.g. network problem).\r\n                                 * Check the 'ParticipantId' to check whether the message is for the current user.\r\n                                 */\r\n                                case \"disconnectsession\":\r\n\r\n                                    const disconnectParticipant: IInternalParticipant = {\r\n                                        id: commandPayload.participantId\r\n                                    };\r\n\r\n                                    break;\r\n\r\n                                /**\r\n                                 * Message not recognized.\r\n                                 */\r\n                                default:\r\n                                    break;\r\n                            }\r\n                            break;\r\n\r\n                        /**\r\n                         * 'partial' (or 'hypothesis') represents a unfinalized speech message.\r\n                         */\r\n                        case \"partial\":\r\n\r\n                        /**\r\n                         * 'final' (or 'phrase') represents a finalized speech message.\r\n                         */\r\n                        case \"final\":\r\n\r\n                            const speechPayload: SpeechResponsePayload = SpeechResponsePayload.fromJSON(message.textBody);\r\n\r\n                            const speechResult: ConversationTranslationResult = new ConversationTranslationResult(speechPayload.participantId,\r\n                                this.getTranslations(speechPayload.translations),\r\n                                speechPayload.language,\r\n                                undefined,\r\n                                undefined,\r\n                                speechPayload.recognition,\r\n                                undefined,\r\n                                undefined,\r\n                                message.textBody,\r\n                                undefined);\r\n\r\n                            if (speechPayload.isFinal) {\r\n                                // check the length, sometimes empty finals are returned\r\n                                if (speechResult.text !== undefined && speechResult.text.length > 0) {\r\n                                    sendFinal = true;\r\n                                } else if (speechPayload.id === this.privLastPartialUtteranceId) {\r\n                                    // send final as normal. We had a non-empty partial for this same utterance\r\n                                    // so sending the empty final is important\r\n                                    sendFinal = true;\r\n                                } else {\r\n                                    // suppress unneeded final\r\n                                }\r\n\r\n                                if (sendFinal) {\r\n                                    if (!!this.privConversationServiceConnector.translationReceived) {\r\n                                        this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                            new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.final, speechResult, sessionId));\r\n                                    }\r\n                                }\r\n                            } else if (speechResult.text !== undefined) {\r\n                                this.privLastPartialUtteranceId = speechPayload.id;\r\n                                if (!!this.privConversationServiceConnector.translationReceived) {\r\n                                    this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                        new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.partial, speechResult, sessionId));\r\n                                }\r\n                            }\r\n\r\n                            break;\r\n\r\n                        /**\r\n                         * \"translated_message\" is a text message or instant message (IM).\r\n                         */\r\n                        case \"translated_message\":\r\n\r\n                            const textPayload: TextResponsePayload = TextResponsePayload.fromJSON(message.textBody);\r\n\r\n                            const textResult: ConversationTranslationResult = new ConversationTranslationResult(textPayload.participantId,\r\n                                this.getTranslations(textPayload.translations),\r\n                                textPayload.language,\r\n                                undefined,\r\n                                undefined,\r\n                                textPayload.originalText,\r\n                                undefined,\r\n                                undefined,\r\n                                undefined,\r\n                                message.textBody,\r\n                                undefined);\r\n\r\n                            if (!!this.privConversationServiceConnector.translationReceived) {\r\n                                this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                    new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.instantMessage, textResult, sessionId));\r\n                            }\r\n                            break;\r\n\r\n                        default:\r\n                            // ignore any unsupported message types\r\n                            break;\r\n                    }\r\n                } catch (e) {\r\n                    // continue\r\n                }\r\n                return this.receiveConversationMessageOverride();\r\n            });\r\n        }, (error: string) => {\r\n            this.terminateMessageLoop = true;\r\n        });\r\n\r\n        return communicationCustodian.promise();\r\n    }\r\n\r\n    private startMessageLoop(): Promise<IConnection> {\r\n\r\n        this.terminateMessageLoop = false;\r\n\r\n        const messageRetrievalPromise = this.receiveConversationMessageOverride();\r\n\r\n        return messageRetrievalPromise.on((r: IConnection) => {\r\n            return true;\r\n        }, (error: string) => {\r\n            this.cancelRecognition(\r\n                this.privRequestSession ? this.privRequestSession.sessionId : \"\",\r\n                this.privRequestSession ? this.privRequestSession.requestId : \"\",\r\n                CancellationReason.Error,\r\n                CancellationErrorCode.RuntimeError,\r\n                error);\r\n        });\r\n    }\r\n\r\n    // Takes an established websocket connection to the endpoint\r\n    private configConnection(): Promise<IConnection> {\r\n        if (this.privConnectionConfigPromise) {\r\n            if (this.privConnectionConfigPromise.result().isCompleted &&\r\n                (this.privConnectionConfigPromise.result().isError\r\n                    || this.privConnectionConfigPromise.result().result.state() === ConnectionState.Disconnected)) {\r\n\r\n                this.privConnectionConfigPromise = null;\r\n                return this.configConnection();\r\n            } else {\r\n                return this.privConnectionConfigPromise;\r\n            }\r\n        }\r\n\r\n        if (this.terminateMessageLoop) {\r\n            return PromiseHelper.fromResult<IConnection>(undefined);\r\n        }\r\n\r\n        this.privConnectionConfigPromise = this.conversationConnectImpl()\r\n            .onSuccessContinueWith((connection: IConnection): any => {\r\n                return connection;\r\n            });\r\n        return this.privConnectionConfigPromise;\r\n    }\r\n\r\n    private getTranslations(serviceResultTranslations: ITranslationResponsePayload[]): Translations {\r\n        let translations: Translations;\r\n\r\n        if (undefined !== serviceResultTranslations) {\r\n            translations = new Translations();\r\n            for (const translation of serviceResultTranslations) {\r\n                translations.set(translation.lang, translation.translation);\r\n            }\r\n        }\r\n\r\n        return translations;\r\n    }\r\n\r\n    private fetchConversationConnection = (): Promise<IConnection> => {\r\n        return this.configConnection();\r\n    }\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}