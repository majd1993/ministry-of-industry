{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = useScrollTo;\n\nvar _react = require(\"react\");\n\nvar _reactScrollToBottom = require(\"react-scroll-to-bottom\");\n\nvar _useGetTranscriptScrollableElement = _interopRequireDefault(require(\"./internal/useGetTranscriptScrollableElement\"));\n\nvar _useGetTranscriptActivityElementByID = _interopRequireDefault(require(\"./internal/useGetTranscriptActivityElementByID\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction useScrollTo() {\n  var getActivityElementByID = (0, _useGetTranscriptActivityElementByID.default)();\n  var getScrollableElement = (0, _useGetTranscriptScrollableElement.default)();\n  var scrollTo = (0, _reactScrollToBottom.useScrollTo)();\n  return (0, _react.useCallback)(function (position) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$behavior = _ref.behavior,\n        behavior = _ref$behavior === void 0 ? 'auto' : _ref$behavior;\n\n    if (!position) {\n      throw new Error('botframework-webchat: First argument passed to \"useScrollTo\" must be a ScrollPosition object.');\n    }\n\n    var activityID = position.activityID,\n        scrollTop = position.scrollTop;\n\n    if (typeof scrollTop !== 'undefined') {\n      scrollTo(scrollTop, {\n        behavior: behavior\n      });\n    } else if (typeof activityID !== 'undefined') {\n      var activityElement = getActivityElementByID(activityID);\n\n      if (activityElement) {\n        var scrollableElement = getScrollableElement();\n\n        var _activityElement$getC = activityElement.getClientRects(),\n            _activityElement$getC2 = _slicedToArray(_activityElement$getC, 1),\n            _activityElement$getC3 = _activityElement$getC2[0],\n            activityElementHeight = _activityElement$getC3.height,\n            activityElementY = _activityElement$getC3.y;\n\n        var _scrollableElement$ge = scrollableElement.getClientRects(),\n            _scrollableElement$ge2 = _slicedToArray(_scrollableElement$ge, 1),\n            scrollableHeight = _scrollableElement$ge2[0].height;\n\n        var activityElementOffsetTop = activityElementY + scrollableElement.scrollTop;\n\n        var _scrollTop = Math.min(activityElementOffsetTop, activityElementOffsetTop - scrollableHeight + activityElementHeight);\n\n        scrollTo(_scrollTop, {\n          behavior: behavior\n        });\n      }\n    }\n  }, [getActivityElementByID, getScrollableElement, scrollTo]);\n}","map":{"version":3,"sources":["../../src/hooks/useScrollTo.js"],"names":["getActivityElementByID","getScrollableElement","scrollTo","behavior","activityID","scrollTop","position","activityElement","scrollableElement","activityElementHeight","activityElementY","scrollableHeight","activityElementOffsetTop","Math"],"mappings":";;;;;;;AAAA,IAAA,MAAA,GAAA,OAAA,CAAA,OAAA,CAAA;;AACA,IAAA,oBAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;;AAEA,IAAA,kCAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,8CAAA,CAAA,CAAA;;AACA,IAAA,oCAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,gDAAA,CAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEe,SAAA,WAAA,GAAuB;AACpC,MAAMA,sBAAsB,GAAG,CAAA,GAAA,oCAAA,CAA/B,OAA+B,GAA/B;AACA,MAAMC,oBAAoB,GAAG,CAAA,GAAA,kCAAA,CAA7B,OAA6B,GAA7B;AACA,MAAMC,QAAQ,GAAG,CAAA,GAAA,oBAAA,CAAjB,WAAiB,GAAjB;AAEA,SAAO,CAAA,GAAA,MAAA,CAAA,WAAA,EACL,UAAA,QAAA,EAA0C;AAAA,QAAA,IAAA,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAP,EAAO;AAAA,QAAA,aAAA,GAAA,IAAA,CAA7BC,QAA6B;AAAA,QAA7BA,QAA6B,GAAA,aAAA,KAAA,KAAA,CAAA,GAAlB,MAAkB,GAAA,aAAA;;AACxC,QAAI,CAAJ,QAAA,EAAe;AACb,YAAM,IAAA,KAAA,CAAN,+FAAM,CAAN;AAGD;;AALuC,QAOhCC,UAPgC,GAONE,QAPM,CAAA,UAAA;AAAA,QAOpBD,SAPoB,GAONC,QAPM,CAAA,SAAA;;AASxC,QAAI,OAAA,SAAA,KAAJ,WAAA,EAAsC;AACpCJ,MAAAA,QAAQ,CAAA,SAAA,EAAY;AAAEC,QAAAA,QAAQ,EAARA;AAAF,OAAZ,CAARD;AADF,KAAA,MAEO,IAAI,OAAA,UAAA,KAAJ,WAAA,EAAuC;AAC5C,UAAMK,eAAe,GAAGP,sBAAsB,CAA9C,UAA8C,CAA9C;;AAEA,UAAA,eAAA,EAAqB;AACnB,YAAMQ,iBAAiB,GAAGP,oBAA1B,EAAA;;AADmB,YAAA,qBAAA,GAE8CM,eAAe,CAF7D,cAE8CA,EAF9C;AAAA,YAAA,sBAAA,GAAA,cAAA,CAAA,qBAAA,EAAA,CAAA,CAAA;AAAA,YAAA,sBAAA,GAAA,sBAAA,CAAA,CAAA,CAAA;AAAA,YAEFE,qBAFE,GAAA,sBAAA,CAAA,MAAA;AAAA,YAEwBC,gBAFxB,GAAA,sBAAA,CAAA,CAAA;;AAAA,YAAA,qBAAA,GAGoBF,iBAAiB,CAHrC,cAGoBA,EAHpB;AAAA,YAAA,sBAAA,GAAA,cAAA,CAAA,qBAAA,EAAA,CAAA,CAAA;AAAA,YAGFG,gBAHE,GAAA,sBAAA,CAAA,CAAA,CAAA,CAAA,MAAA;;AAKnB,YAAMC,wBAAwB,GAAGF,gBAAgB,GAAGF,iBAAiB,CAArE,SAAA;;AAEA,YAAMH,UAAS,GAAGQ,IAAI,CAAJA,GAAAA,CAAAA,wBAAAA,EAEhBD,wBAAwB,GAAxBA,gBAAAA,GAFF,qBAAkBC,CAAlB;;AAKAX,QAAAA,QAAQ,CAAA,UAAA,EAAY;AAAEC,UAAAA,QAAQ,EAARA;AAAF,SAAZ,CAARD;AACD;AACF;AA7BE,GAAA,EA+BL,CAAA,sBAAA,EAAA,oBAAA,EA/BF,QA+BE,CA/BK,CAAP;AAiCD","sourcesContent":["import { useCallback } from 'react';\nimport { useScrollTo as useScrollToBottomScrollTo } from 'react-scroll-to-bottom';\n\nimport useGetTranscriptScrollableElement from './internal/useGetTranscriptScrollableElement';\nimport useGetTranscriptActivityElementByID from './internal/useGetTranscriptActivityElementByID';\n\nexport default function useScrollTo() {\n  const getActivityElementByID = useGetTranscriptActivityElementByID();\n  const getScrollableElement = useGetTranscriptScrollableElement();\n  const scrollTo = useScrollToBottomScrollTo();\n\n  return useCallback(\n    (position, { behavior = 'auto' } = {}) => {\n      if (!position) {\n        throw new Error(\n          'botframework-webchat: First argument passed to \"useScrollTo\" must be a ScrollPosition object.'\n        );\n      }\n\n      const { activityID, scrollTop } = position;\n\n      if (typeof scrollTop !== 'undefined') {\n        scrollTo(scrollTop, { behavior });\n      } else if (typeof activityID !== 'undefined') {\n        const activityElement = getActivityElementByID(activityID);\n\n        if (activityElement) {\n          const scrollableElement = getScrollableElement();\n          const [{ height: activityElementHeight, y: activityElementY }] = activityElement.getClientRects();\n          const [{ height: scrollableHeight }] = scrollableElement.getClientRects();\n\n          const activityElementOffsetTop = activityElementY + scrollableElement.scrollTop;\n\n          const scrollTop = Math.min(\n            activityElementOffsetTop,\n            activityElementOffsetTop - scrollableHeight + activityElementHeight\n          );\n\n          scrollTo(scrollTop, { behavior });\n        }\n      }\n    },\n    [getActivityElementByID, getScrollableElement, scrollTo]\n  );\n}\n"],"sourceRoot":"component:///"},"metadata":{},"sourceType":"script"}