{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = useMemoize;\n\nvar _react = require(\"react\");\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction useMemoize(fn, callback, deps) {\n  if (typeof fn !== 'function') {\n    throw new Error('The first argument must be a function.');\n  } else if (typeof callback !== 'function') {\n    throw new Error('The second argument must be a function.');\n  } else if (!Array.isArray(deps)) {\n    throw new Error('The third argument must be an array.');\n  }\n\n  var memoizedFn = (0, _react.useMemo)(function () {\n    var cache = [];\n    return function (run) {\n      var nextCache = [];\n      var result = run(function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        var _ref = [].concat(_toConsumableArray(cache), nextCache).find(function (_ref2) {\n          var cachedArgs = _ref2.args;\n          return args.length === cachedArgs.length && args.every(function (arg, index) {\n            return Object.is(arg, cachedArgs[index]);\n          });\n        }) || {\n          result: fn.apply(void 0, args)\n        },\n            result = _ref.result;\n\n        nextCache.push({\n          args: args,\n          result: result\n        });\n        return result;\n      });\n      cache = nextCache;\n      return result;\n    }; // We are manually creating the deps here. The \"callback\" arg is also designed not to be impact deps, similar to useEffect(fn), where \"fn\" is not in deps.\n\n    /* eslint-disable-next-line react-hooks/exhaustive-deps */\n  }, [fn].concat(_toConsumableArray(deps)));\n  return memoizedFn(callback);\n}","map":{"version":3,"sources":["../../../src/hooks/internal/useMemoize.js"],"names":["Array","memoizedFn","cache","nextCache","result","run","args","cachedArgs","Object","fn"],"mappings":";;;;;;;AAAA,IAAA,MAAA,GAAA,OAAA,CAAA,OAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEe,SAAA,UAAA,CAAA,EAAA,EAAA,QAAA,EAAA,IAAA,EAAwC;AACrD,MAAI,OAAA,EAAA,KAAJ,UAAA,EAA8B;AAC5B,UAAM,IAAA,KAAA,CAAN,wCAAM,CAAN;AADF,GAAA,MAEO,IAAI,OAAA,QAAA,KAAJ,UAAA,EAAoC;AACzC,UAAM,IAAA,KAAA,CAAN,yCAAM,CAAN;AADK,GAAA,MAEA,IAAI,CAACA,KAAK,CAALA,OAAAA,CAAL,IAAKA,CAAL,EAA0B;AAC/B,UAAM,IAAA,KAAA,CAAN,sCAAM,CAAN;AACD;;AAED,MAAMC,UAAU,GAAG,CAAA,GAAA,MAAA,CAAA,OAAA,EAAQ,YAAM;AAC/B,QAAIC,KAAK,GAAT,EAAA;AAEA,WAAO,UAAA,GAAA,EAAO;AACZ,UAAMC,SAAS,GAAf,EAAA;AACA,UAAMC,MAAM,GAAGC,GAAG,CAAC,YAAa;AAAA,aAAA,IAAA,IAAA,GAAA,SAAA,CAAA,MAAA,EAATC,IAAS,GAAA,IAAA,KAAA,CAAA,IAAA,CAAA,EAAA,IAAA,GAAA,CAAA,EAAA,IAAA,GAAA,IAAA,EAAA,IAAA,EAAA,EAAA;AAATA,UAAAA,IAAS,CAAA,IAAA,CAATA,GAAS,SAAA,CAAA,IAAA,CAATA;AAAS;;AAAA,YAAA,IAAA,GACX,GAAA,MAAA,CAAA,kBAAA,CAAA,KAAA,CAAA,EAAA,SAAA,EAAA,IAAA,CACjB,UAAA,KAAA,EAAA;AAAA,cAASC,UAAT,GAAA,KAAA,CAAA,IAAA;AAAA,iBACED,IAAI,CAAJA,MAAAA,KAAgBC,UAAU,CAA1BD,MAAAA,IAAqC,IAAI,CAAJ,KAAA,CAAW,UAAA,GAAA,EAAA,KAAA,EAAA;AAAA,mBAAgBE,MAAM,CAANA,EAAAA,CAAAA,GAAAA,EAAeD,UAAU,CAAzC,KAAyC,CAAzBC,CAAhB;AADlD,WACuC,CADvC;AADiB,SAAA,KAGd;AAAEJ,UAAAA,MAAM,EAAEK,EAAE,CAAFA,KAAAA,CAAAA,KAAAA,CAAAA,EAAAA,IAAAA;AAAV,SAJyB;AAAA,YACtBL,MADsB,GAAA,IAAA,CAAA,MAAA;;AAM9BD,QAAAA,SAAS,CAATA,IAAAA,CAAe;AAAEG,UAAAA,IAAI,EAAN,IAAA;AAAQF,UAAAA,MAAM,EAANA;AAAR,SAAfD;AAEA,eAAA,MAAA;AARF,OAAkB,CAAlB;AAWAD,MAAAA,KAAK,GAALA,SAAAA;AAEA,aAAA,MAAA;AAlB6B,KAG/B,CAH+B,CAoB/B;;AACA;AArBiB,GAAA,EAAA,CAAA,EAAA,EAAA,MAAA,CAAA,kBAAA,CAAnB,IAAmB,CAAA,CAAA,CAAnB;AAwBA,SAAOD,UAAU,CAAjB,QAAiB,CAAjB;AACD","sourcesContent":["import { useMemo } from 'react';\n\nexport default function useMemoize(fn, callback, deps) {\n  if (typeof fn !== 'function') {\n    throw new Error('The first argument must be a function.');\n  } else if (typeof callback !== 'function') {\n    throw new Error('The second argument must be a function.');\n  } else if (!Array.isArray(deps)) {\n    throw new Error('The third argument must be an array.');\n  }\n\n  const memoizedFn = useMemo(() => {\n    let cache = [];\n\n    return run => {\n      const nextCache = [];\n      const result = run((...args) => {\n        const { result } = [...cache, ...nextCache].find(\n          ({ args: cachedArgs }) =>\n            args.length === cachedArgs.length && args.every((arg, index) => Object.is(arg, cachedArgs[index]))\n        ) || { result: fn(...args) };\n\n        nextCache.push({ args, result });\n\n        return result;\n      });\n\n      cache = nextCache;\n\n      return result;\n    };\n    // We are manually creating the deps here. The \"callback\" arg is also designed not to be impact deps, similar to useEffect(fn), where \"fn\" is not in deps.\n    /* eslint-disable-next-line react-hooks/exhaustive-deps */\n  }, [fn, ...deps]);\n\n  return memoizedFn(callback);\n}\n"],"sourceRoot":"component:///"},"metadata":{},"sourceType":"script"}