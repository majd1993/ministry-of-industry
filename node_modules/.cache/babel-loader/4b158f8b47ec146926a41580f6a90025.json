{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useTextBoxSubmit = useTextBoxSubmit;\nexports.useTextBoxValue = useTextBoxValue;\nexports.connectSendTextBox = exports.default = void 0;\n\nvar _botframeworkWebchatApi = require(\"botframework-webchat-api\");\n\nvar _classnames = _interopRequireDefault(require(\"classnames\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _TypeFocusSink = require(\"../Utils/TypeFocusSink\");\n\nvar _AccessibleInputText = _interopRequireDefault(require(\"../Utils/AccessibleInputText\"));\n\nvar _AccessibleTextArea = _interopRequireDefault(require(\"../Utils/AccessibleTextArea\"));\n\nvar _connectToWebChat = _interopRequireDefault(require(\"../connectToWebChat\"));\n\nvar _useFocus = _interopRequireDefault(require(\"../hooks/useFocus\"));\n\nvar _useReplaceEmoticon = _interopRequireDefault(require(\"../hooks/internal/useReplaceEmoticon\"));\n\nvar _useScrollToEnd = _interopRequireDefault(require(\"../hooks/useScrollToEnd\"));\n\nvar _useStyleSet3 = _interopRequireDefault(require(\"../hooks/useStyleSet\"));\n\nvar _useStyleToEmotionObject = _interopRequireDefault(require(\"../hooks/internal/useStyleToEmotionObject\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nvar useDisabled = _botframeworkWebchatApi.hooks.useDisabled,\n    useLocalizer = _botframeworkWebchatApi.hooks.useLocalizer,\n    useSendBoxValue = _botframeworkWebchatApi.hooks.useSendBoxValue,\n    useStopDictate = _botframeworkWebchatApi.hooks.useStopDictate,\n    useStyleOptions = _botframeworkWebchatApi.hooks.useStyleOptions,\n    useSubmitSendBox = _botframeworkWebchatApi.hooks.useSubmitSendBox;\nvar ROOT_STYLE = {\n  '&.webchat__send-box-text-box': {\n    display: 'flex',\n    '& .webchat__send-box-text-box__input, & .webchat__send-box-text-box__text-area-box': {\n      flex: 1\n    }\n  }\n};\n\nvar connectSendTextBox = function connectSendTextBox() {\n  for (var _len = arguments.length, selectors = new Array(_len), _key = 0; _key < _len; _key++) {\n    selectors[_key] = arguments[_key];\n  }\n\n  return _connectToWebChat.default.apply(void 0, [function (_ref) {\n    var disabled = _ref.disabled,\n        focusSendBox = _ref.focusSendBox,\n        language = _ref.language,\n        scrollToEnd = _ref.scrollToEnd,\n        sendBoxValue = _ref.sendBoxValue,\n        setSendBox = _ref.setSendBox,\n        stopDictate = _ref.stopDictate,\n        submitSendBox = _ref.submitSendBox;\n    return {\n      disabled: disabled,\n      language: language,\n      onChange: function onChange(_ref2) {\n        var value = _ref2.target.value;\n        setSendBox(value);\n        stopDictate();\n      },\n      onKeyPress: function onKeyPress(event) {\n        var key = event.key,\n            shiftKey = event.shiftKey;\n\n        if (key === 'Enter' && !shiftKey) {\n          event.preventDefault();\n\n          if (sendBoxValue) {\n            scrollToEnd();\n            submitSendBox();\n            focusSendBox();\n          }\n        }\n      },\n      onSubmit: function onSubmit(event) {\n        event.preventDefault(); // Consider clearing the send box only after we received POST_ACTIVITY_PENDING\n        // E.g. if the connection is bad, sending the message essentially do nothing but just clearing the send box\n\n        if (sendBoxValue) {\n          scrollToEnd();\n          submitSendBox();\n        }\n      },\n      value: sendBoxValue\n    };\n  }].concat(selectors));\n};\n\nexports.connectSendTextBox = connectSendTextBox;\n\nfunction useTextBoxSubmit() {\n  var _useSendBoxValue = useSendBoxValue(),\n      _useSendBoxValue2 = _slicedToArray(_useSendBoxValue, 1),\n      sendBoxValue = _useSendBoxValue2[0];\n\n  var focus = (0, _useFocus.default)();\n  var scrollToEnd = (0, _useScrollToEnd.default)();\n  var submitSendBox = useSubmitSendBox();\n  return (0, _react.useCallback)(function (setFocus) {\n    if (sendBoxValue) {\n      scrollToEnd();\n      submitSendBox();\n\n      if (setFocus) {\n        if (setFocus === true) {\n          console.warn(\"\\\"botframework-webchat: Passing \\\"true\\\" to \\\"useTextBoxSubmit\\\" is deprecated and will be removed on or after 2022-04-23. Please pass \\\"sendBox\\\" instead.\\\"\");\n          focus('sendBox');\n        } else {\n          focus(setFocus);\n        }\n      }\n    }\n\n    return !!sendBoxValue;\n  }, [focus, scrollToEnd, sendBoxValue, submitSendBox]);\n}\n\nfunction useTextBoxValue() {\n  var _useSendBoxValue3 = useSendBoxValue(),\n      _useSendBoxValue4 = _slicedToArray(_useSendBoxValue3, 2),\n      value = _useSendBoxValue4[0],\n      setValue = _useSendBoxValue4[1];\n\n  var replaceEmoticon = (0, _useReplaceEmoticon.default)();\n  var stopDictate = useStopDictate();\n  var setter = (0, _react.useCallback)(function (nextValue) {\n    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        selectionEnd = _ref3.selectionEnd,\n        selectionStart = _ref3.selectionStart;\n\n    if (typeof nextValue !== 'string') {\n      throw new Error('botframework-webchat: First argument passed to useTextBoxValue() must be a string.');\n    } // Currently, we cannot detect whether the change is due to clipboard paste or pressing a key on the keyboard.\n    // We should not change to emoji when the user is pasting text.\n    // We would assume, for a single character addition, the user must be pressing a key.\n\n\n    if (nextValue.length === value.length + 1) {\n      var _replaceEmoticon = replaceEmoticon({\n        selectionEnd: selectionEnd,\n        selectionStart: selectionStart,\n        value: nextValue\n      }),\n          nextSelectionEnd = _replaceEmoticon.selectionEnd,\n          nextSelectionStart = _replaceEmoticon.selectionStart,\n          nextValueWithEmoji = _replaceEmoticon.value;\n\n      selectionEnd = nextSelectionEnd;\n      selectionStart = nextSelectionStart;\n      nextValue = nextValueWithEmoji;\n    }\n\n    setValue(nextValue);\n    stopDictate();\n    return {\n      selectionEnd: selectionEnd,\n      selectionStart: selectionStart,\n      value: nextValue\n    };\n  }, [replaceEmoticon, setValue, stopDictate, value]);\n  return [value, setter];\n}\n\nvar PREVENT_DEFAULT_HANDLER = function PREVENT_DEFAULT_HANDLER(event) {\n  return event.preventDefault();\n};\n\nvar TextBoxCore = /*#__PURE__*/(0, _react.forwardRef)(function (_ref4, forwardedRef) {\n  var className = _ref4.className;\n\n  var _useSendBoxValue5 = useSendBoxValue(),\n      _useSendBoxValue6 = _slicedToArray(_useSendBoxValue5, 2),\n      setSendBox = _useSendBoxValue6[1];\n\n  var _useStyleSet = (0, _useStyleSet3.default)(),\n      _useStyleSet2 = _slicedToArray(_useStyleSet, 1),\n      _useStyleSet2$ = _useStyleSet2[0],\n      sendBoxTextAreaStyleSet = _useStyleSet2$.sendBoxTextArea,\n      sendBoxTextBoxStyleSet = _useStyleSet2$.sendBoxTextBox;\n\n  var _useStyleOptions = useStyleOptions(),\n      _useStyleOptions2 = _slicedToArray(_useStyleOptions, 1),\n      sendBoxTextWrap = _useStyleOptions2[0].sendBoxTextWrap;\n\n  var _useDisabled = useDisabled(),\n      _useDisabled2 = _slicedToArray(_useDisabled, 1),\n      disabled = _useDisabled2[0];\n\n  var _useTextBoxValue = useTextBoxValue(),\n      _useTextBoxValue2 = _slicedToArray(_useTextBoxValue, 2),\n      textBoxValue = _useTextBoxValue2[0],\n      setTextBoxValue = _useTextBoxValue2[1];\n\n  var inputElementRef = (0, _react.useRef)();\n  var localize = useLocalizer();\n  var placeCheckpointOnChangeRef = (0, _react.useRef)(false);\n  var prevInputStateRef = (0, _react.useRef)();\n  var rootClassName = (0, _useStyleToEmotionObject.default)()(ROOT_STYLE) + '';\n  var submitTextBox = useTextBoxSubmit();\n  var undoStackRef = (0, _react.useRef)([]);\n  var inputRefCallback = (0, _react.useCallback)(function (element) {\n    if (typeof forwardedRef === 'function') {\n      forwardedRef(element);\n    } else if (forwardedRef) {\n      forwardedRef.current = element;\n    }\n\n    inputElementRef.current = element;\n  }, [forwardedRef, inputElementRef]);\n  var sendBoxString = localize('TEXT_INPUT_ALT');\n  var typeYourMessageString = localize('TEXT_INPUT_PLACEHOLDER');\n  var rememberInputState = (0, _react.useCallback)(function () {\n    var _inputElementRef$curr = inputElementRef.current,\n        selectionEnd = _inputElementRef$curr.selectionEnd,\n        selectionStart = _inputElementRef$curr.selectionStart,\n        value = _inputElementRef$curr.value;\n    prevInputStateRef.current = {\n      selectionEnd: selectionEnd,\n      selectionStart: selectionStart,\n      value: value\n    };\n  }, [inputElementRef, prevInputStateRef]); // This is for TypeFocusSink. When the focus in on the script, then starting press \"a\", without this line, it would cause errors.\n  // We call rememberInputState() when \"onFocus\" event is fired, but since this is from TypeFocusSink, we are not able to receive \"onFocus\" event before it happen.\n\n  (0, _react.useEffect)(rememberInputState, [rememberInputState]); // This is for moving the selection while setting the send box value.\n  // If we only use setSendBox, we will need to wait for the next render cycle to get the value in, before we can set selectionEnd/Start.\n\n  var setSelectionRangeAndValue = (0, _react.useCallback)(function (_ref5) {\n    var selectionEnd = _ref5.selectionEnd,\n        selectionStart = _ref5.selectionStart,\n        value = _ref5.value;\n\n    if (inputElementRef.current) {\n      // We need to set the value, before selectionStart/selectionEnd.\n      inputElementRef.current.value = value;\n      inputElementRef.current.selectionStart = selectionStart;\n      inputElementRef.current.selectionEnd = selectionEnd;\n    }\n\n    setSendBox(value);\n  }, [inputElementRef, setSendBox]);\n  var handleChange = (0, _react.useCallback)(function (event) {\n    var _event$target = event.target,\n        selectionEnd = _event$target.selectionEnd,\n        selectionStart = _event$target.selectionStart,\n        value = _event$target.value;\n\n    if (placeCheckpointOnChangeRef.current) {\n      undoStackRef.current.push(_objectSpread({}, prevInputStateRef.current));\n      placeCheckpointOnChangeRef.current = false;\n    }\n\n    var nextInputState = setTextBoxValue(value, {\n      selectionEnd: selectionEnd,\n      selectionStart: selectionStart\n    }); // If an emoticon is converted to emoji, place another checkpoint.\n\n    if (nextInputState.value !== value) {\n      undoStackRef.current.push({\n        selectionEnd: selectionEnd,\n        selectionStart: selectionStart,\n        value: value\n      });\n      placeCheckpointOnChangeRef.current = true;\n      setSelectionRangeAndValue(nextInputState);\n    }\n  }, [placeCheckpointOnChangeRef, prevInputStateRef, setSelectionRangeAndValue, setTextBoxValue, undoStackRef]);\n  var handleFocus = (0, _react.useCallback)(function () {\n    rememberInputState();\n    placeCheckpointOnChangeRef.current = true;\n  }, [placeCheckpointOnChangeRef, rememberInputState]);\n  var handleKeyDown = (0, _react.useCallback)(function (event) {\n    var ctrlKey = event.ctrlKey,\n        key = event.key,\n        metaKey = event.metaKey;\n\n    if ((ctrlKey || metaKey) && (key === 'Z' || key === 'z')) {\n      event.preventDefault();\n      var poppedInputState = undoStackRef.current.pop();\n\n      if (poppedInputState) {\n        prevInputStateRef.current = _objectSpread({}, poppedInputState);\n      } else {\n        prevInputStateRef.current = {\n          selectionEnd: 0,\n          selectionStart: 0,\n          value: ''\n        };\n      }\n\n      setSelectionRangeAndValue(prevInputStateRef.current);\n    }\n  }, [prevInputStateRef, setSelectionRangeAndValue, undoStackRef]);\n  var handleKeyPress = (0, _react.useCallback)(function (event) {\n    var key = event.key,\n        shiftKey = event.shiftKey;\n\n    if (key === 'Enter' && !shiftKey) {\n      event.preventDefault(); // If text box is submitted, focus on the send box\n\n      submitTextBox('sendBox'); // After submit, we will clear the undo stack.\n\n      undoStackRef.current = [];\n    }\n  }, [submitTextBox, undoStackRef]);\n  var handleSelect = (0, _react.useCallback)(function (_ref6) {\n    var _ref6$target = _ref6.target,\n        selectionEnd = _ref6$target.selectionEnd,\n        selectionStart = _ref6$target.selectionStart,\n        value = _ref6$target.value;\n\n    if (value === prevInputStateRef.current.value) {\n      // When caret move, we should push to undo stack on change.\n      placeCheckpointOnChangeRef.current = true;\n    }\n\n    prevInputStateRef.current = {\n      selectionEnd: selectionEnd,\n      selectionStart: selectionStart,\n      value: value\n    };\n  }, [placeCheckpointOnChangeRef, prevInputStateRef]);\n  var handleSubmit = (0, _react.useCallback)(function (event) {\n    event.preventDefault(); // Consider clearing the send box only after we received POST_ACTIVITY_PENDING\n    // E.g. if the connection is bad, sending the message essentially do nothing but just clearing the send box\n\n    submitTextBox(); // After submit, we will clear the undo stack.\n\n    undoStackRef.current = [];\n  }, [submitTextBox, undoStackRef]);\n  return /*#__PURE__*/_react.default.createElement(\"form\", {\n    \"aria-disabled\": disabled,\n    className: (0, _classnames.default)('webchat__send-box-text-box', rootClassName, sendBoxTextAreaStyleSet + '', sendBoxTextBoxStyleSet + '', (className || '') + ''),\n    onSubmit: disabled ? PREVENT_DEFAULT_HANDLER : handleSubmit\n  }, !sendBoxTextWrap ? /*#__PURE__*/_react.default.createElement(_AccessibleInputText.default, {\n    \"aria-label\": sendBoxString,\n    className: \"webchat__send-box-text-box__input\",\n    \"data-id\": \"webchat-sendbox-input\",\n    disabled: disabled,\n    enterkeyhint: \"send\" // The version of React we are using does not support \"enterKeyHint\" yet\n    ,\n    inputMode: \"text\",\n    onChange: disabled ? undefined : handleChange,\n    onFocus: disabled ? undefined : handleFocus,\n    onKeyDown: disabled ? undefined : handleKeyDown,\n    onKeyPress: disabled ? undefined : handleKeyPress,\n    onSelect: disabled ? undefined : handleSelect,\n    placeholder: typeYourMessageString,\n    readOnly: disabled,\n    ref: inputRefCallback,\n    type: \"text\",\n    value: textBoxValue\n  }) : /*#__PURE__*/_react.default.createElement(\"div\", {\n    className: \"webchat__send-box-text-box__text-area-box\"\n  }, /*#__PURE__*/_react.default.createElement(_AccessibleTextArea.default, {\n    \"aria-label\": sendBoxString,\n    className: \"webchat__send-box-text-box__text-area\",\n    \"data-id\": \"webchat-sendbox-input\",\n    disabled: disabled,\n    enterkeyhint: \"send\" // The version of React we are using does not support \"enterKeyHint\" yet\n    ,\n    inputMode: \"text\",\n    onChange: disabled ? undefined : handleChange,\n    onFocus: disabled ? undefined : handleFocus,\n    onKeyDown: disabled ? undefined : handleKeyDown,\n    onKeyPress: disabled ? undefined : handleKeyPress,\n    onSelect: disabled ? undefined : handleSelect,\n    placeholder: typeYourMessageString,\n    readOnly: disabled,\n    ref: inputRefCallback,\n    rows: \"1\",\n    value: textBoxValue\n  }), /*#__PURE__*/_react.default.createElement(\"div\", {\n    className: \"webchat__send-box-text-box__text-area-doppelganger\"\n  }, textBoxValue + '\\n')), disabled && /*#__PURE__*/_react.default.createElement(\"div\", {\n    className: \"webchat__send-box-text-box__glass\"\n  }));\n});\nTextBoxCore.defaultProps = {\n  className: ''\n};\nTextBoxCore.propTypes = {\n  className: _propTypes.default.string\n};\n\nvar TextBox = function TextBox(_ref7) {\n  var className = _ref7.className;\n  return (\n    /*#__PURE__*/\n    // For DOM node referenced by sendFocusRef, we are using a hack to focus on it.\n    // By flipping readOnly attribute while setting focus, we can focus on text box without popping the virtual keyboard on mobile device.\n    _react.default.createElement(_TypeFocusSink.Context.Consumer, null, function (_ref8) {\n      var sendFocusRef = _ref8.sendFocusRef;\n      return /*#__PURE__*/_react.default.createElement(TextBoxCore, {\n        className: className,\n        ref: sendFocusRef\n      });\n    })\n  );\n};\n\nTextBox.defaultProps = {\n  className: ''\n};\nTextBox.propTypes = {\n  className: _propTypes.default.string\n};\nvar _default = TextBox;\nexports.default = _default;","map":{"version":3,"sources":["../../src/SendBox/TextBox.js"],"names":["useDisabled","useLocalizer","useSendBoxValue","useStopDictate","useStyleOptions","useSubmitSendBox","hooks","ROOT_STYLE","display","flex","connectSendTextBox","selectors","disabled","focusSendBox","language","scrollToEnd","sendBoxValue","setSendBox","stopDictate","submitSendBox","onChange","target","value","onKeyPress","key","shiftKey","event","onSubmit","focus","setFocus","console","setValue","replaceEmoticon","setter","selectionEnd","selectionStart","nextValue","nextSelectionEnd","nextSelectionStart","nextValueWithEmoji","PREVENT_DEFAULT_HANDLER","TextBoxCore","className","sendBoxTextAreaStyleSet","sendBoxTextBoxStyleSet","sendBoxTextWrap","textBoxValue","setTextBoxValue","useTextBoxValue","inputElementRef","localize","placeCheckpointOnChangeRef","prevInputStateRef","rootClassName","submitTextBox","useTextBoxSubmit","undoStackRef","inputRefCallback","forwardedRef","sendBoxString","typeYourMessageString","rememberInputState","setSelectionRangeAndValue","handleChange","nextInputState","handleFocus","handleKeyDown","ctrlKey","metaKey","poppedInputState","handleKeyPress","handleSelect","handleSubmit","PropTypes","string","TextBox","sendFocusRef"],"mappings":"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","sourcesContent":["import { hooks } from 'botframework-webchat-api';\nimport classNames from 'classnames';\nimport PropTypes from 'prop-types';\nimport React, { forwardRef, useCallback, useEffect, useRef } from 'react';\n\nimport { Context as TypeFocusSinkContext } from '../Utils/TypeFocusSink';\nimport AccessibleInputText from '../Utils/AccessibleInputText';\nimport AccessibleTextArea from '../Utils/AccessibleTextArea';\nimport connectToWebChat from '../connectToWebChat';\nimport useFocus from '../hooks/useFocus';\nimport useReplaceEmoticon from '../hooks/internal/useReplaceEmoticon';\nimport useScrollToEnd from '../hooks/useScrollToEnd';\nimport useStyleSet from '../hooks/useStyleSet';\nimport useStyleToEmotionObject from '../hooks/internal/useStyleToEmotionObject';\n\nconst { useDisabled, useLocalizer, useSendBoxValue, useStopDictate, useStyleOptions, useSubmitSendBox } = hooks;\n\nconst ROOT_STYLE = {\n  '&.webchat__send-box-text-box': {\n    display: 'flex',\n\n    '& .webchat__send-box-text-box__input, & .webchat__send-box-text-box__text-area-box': {\n      flex: 1\n    }\n  }\n};\n\nconst connectSendTextBox = (...selectors) =>\n  connectToWebChat(\n    ({ disabled, focusSendBox, language, scrollToEnd, sendBoxValue, setSendBox, stopDictate, submitSendBox }) => ({\n      disabled,\n      language,\n      onChange: ({ target: { value } }) => {\n        setSendBox(value);\n        stopDictate();\n      },\n      onKeyPress: event => {\n        const { key, shiftKey } = event;\n\n        if (key === 'Enter' && !shiftKey) {\n          event.preventDefault();\n\n          if (sendBoxValue) {\n            scrollToEnd();\n            submitSendBox();\n            focusSendBox();\n          }\n        }\n      },\n      onSubmit: event => {\n        event.preventDefault();\n\n        // Consider clearing the send box only after we received POST_ACTIVITY_PENDING\n        // E.g. if the connection is bad, sending the message essentially do nothing but just clearing the send box\n\n        if (sendBoxValue) {\n          scrollToEnd();\n          submitSendBox();\n        }\n      },\n      value: sendBoxValue\n    }),\n    ...selectors\n  );\n\nfunction useTextBoxSubmit() {\n  const [sendBoxValue] = useSendBoxValue();\n  const focus = useFocus();\n  const scrollToEnd = useScrollToEnd();\n  const submitSendBox = useSubmitSendBox();\n\n  return useCallback(\n    setFocus => {\n      if (sendBoxValue) {\n        scrollToEnd();\n        submitSendBox();\n\n        if (setFocus) {\n          if (setFocus === true) {\n            console.warn(\n              `\"botframework-webchat: Passing \"true\" to \"useTextBoxSubmit\" is deprecated and will be removed on or after 2022-04-23. Please pass \"sendBox\" instead.\"`\n            );\n\n            focus('sendBox');\n          } else {\n            focus(setFocus);\n          }\n        }\n      }\n\n      return !!sendBoxValue;\n    },\n    [focus, scrollToEnd, sendBoxValue, submitSendBox]\n  );\n}\n\nfunction useTextBoxValue() {\n  const [value, setValue] = useSendBoxValue();\n  const replaceEmoticon = useReplaceEmoticon();\n  const stopDictate = useStopDictate();\n\n  const setter = useCallback(\n    (nextValue, { selectionEnd, selectionStart } = {}) => {\n      if (typeof nextValue !== 'string') {\n        throw new Error('botframework-webchat: First argument passed to useTextBoxValue() must be a string.');\n      }\n\n      // Currently, we cannot detect whether the change is due to clipboard paste or pressing a key on the keyboard.\n      // We should not change to emoji when the user is pasting text.\n      // We would assume, for a single character addition, the user must be pressing a key.\n      if (nextValue.length === value.length + 1) {\n        const {\n          selectionEnd: nextSelectionEnd,\n          selectionStart: nextSelectionStart,\n          value: nextValueWithEmoji\n        } = replaceEmoticon({ selectionEnd, selectionStart, value: nextValue });\n\n        selectionEnd = nextSelectionEnd;\n        selectionStart = nextSelectionStart;\n        nextValue = nextValueWithEmoji;\n      }\n\n      setValue(nextValue);\n      stopDictate();\n\n      return {\n        selectionEnd,\n        selectionStart,\n        value: nextValue\n      };\n    },\n    [replaceEmoticon, setValue, stopDictate, value]\n  );\n\n  return [value, setter];\n}\n\nconst PREVENT_DEFAULT_HANDLER = event => event.preventDefault();\n\nconst TextBoxCore = forwardRef(({ className }, forwardedRef) => {\n  const [, setSendBox] = useSendBoxValue();\n  const [{ sendBoxTextArea: sendBoxTextAreaStyleSet, sendBoxTextBox: sendBoxTextBoxStyleSet }] = useStyleSet();\n  const [{ sendBoxTextWrap }] = useStyleOptions();\n  const [disabled] = useDisabled();\n  const [textBoxValue, setTextBoxValue] = useTextBoxValue();\n  const inputElementRef = useRef();\n  const localize = useLocalizer();\n  const placeCheckpointOnChangeRef = useRef(false);\n  const prevInputStateRef = useRef();\n  const rootClassName = useStyleToEmotionObject()(ROOT_STYLE) + '';\n  const submitTextBox = useTextBoxSubmit();\n  const undoStackRef = useRef([]);\n\n  const inputRefCallback = useCallback(\n    element => {\n      if (typeof forwardedRef === 'function') {\n        forwardedRef(element);\n      } else if (forwardedRef) {\n        forwardedRef.current = element;\n      }\n\n      inputElementRef.current = element;\n    },\n    [forwardedRef, inputElementRef]\n  );\n\n  const sendBoxString = localize('TEXT_INPUT_ALT');\n  const typeYourMessageString = localize('TEXT_INPUT_PLACEHOLDER');\n\n  const rememberInputState = useCallback(() => {\n    const {\n      current: { selectionEnd, selectionStart, value }\n    } = inputElementRef;\n\n    prevInputStateRef.current = { selectionEnd, selectionStart, value };\n  }, [inputElementRef, prevInputStateRef]);\n\n  // This is for TypeFocusSink. When the focus in on the script, then starting press \"a\", without this line, it would cause errors.\n  // We call rememberInputState() when \"onFocus\" event is fired, but since this is from TypeFocusSink, we are not able to receive \"onFocus\" event before it happen.\n  useEffect(rememberInputState, [rememberInputState]);\n\n  // This is for moving the selection while setting the send box value.\n  // If we only use setSendBox, we will need to wait for the next render cycle to get the value in, before we can set selectionEnd/Start.\n  const setSelectionRangeAndValue = useCallback(\n    ({ selectionEnd, selectionStart, value }) => {\n      if (inputElementRef.current) {\n        // We need to set the value, before selectionStart/selectionEnd.\n        inputElementRef.current.value = value;\n\n        inputElementRef.current.selectionStart = selectionStart;\n        inputElementRef.current.selectionEnd = selectionEnd;\n      }\n\n      setSendBox(value);\n    },\n    [inputElementRef, setSendBox]\n  );\n\n  const handleChange = useCallback(\n    event => {\n      const {\n        target: { selectionEnd, selectionStart, value }\n      } = event;\n\n      if (placeCheckpointOnChangeRef.current) {\n        undoStackRef.current.push({ ...prevInputStateRef.current });\n\n        placeCheckpointOnChangeRef.current = false;\n      }\n\n      const nextInputState = setTextBoxValue(value, { selectionEnd, selectionStart });\n\n      // If an emoticon is converted to emoji, place another checkpoint.\n      if (nextInputState.value !== value) {\n        undoStackRef.current.push({ selectionEnd, selectionStart, value });\n\n        placeCheckpointOnChangeRef.current = true;\n\n        setSelectionRangeAndValue(nextInputState);\n      }\n    },\n    [placeCheckpointOnChangeRef, prevInputStateRef, setSelectionRangeAndValue, setTextBoxValue, undoStackRef]\n  );\n\n  const handleFocus = useCallback(() => {\n    rememberInputState();\n\n    placeCheckpointOnChangeRef.current = true;\n  }, [placeCheckpointOnChangeRef, rememberInputState]);\n\n  const handleKeyDown = useCallback(\n    event => {\n      const { ctrlKey, key, metaKey } = event;\n\n      if ((ctrlKey || metaKey) && (key === 'Z' || key === 'z')) {\n        event.preventDefault();\n\n        const poppedInputState = undoStackRef.current.pop();\n\n        if (poppedInputState) {\n          prevInputStateRef.current = { ...poppedInputState };\n        } else {\n          prevInputStateRef.current = { selectionEnd: 0, selectionStart: 0, value: '' };\n        }\n\n        setSelectionRangeAndValue(prevInputStateRef.current);\n      }\n    },\n    [prevInputStateRef, setSelectionRangeAndValue, undoStackRef]\n  );\n\n  const handleKeyPress = useCallback(\n    event => {\n      const { key, shiftKey } = event;\n\n      if (key === 'Enter' && !shiftKey) {\n        event.preventDefault();\n\n        // If text box is submitted, focus on the send box\n        submitTextBox('sendBox');\n\n        // After submit, we will clear the undo stack.\n        undoStackRef.current = [];\n      }\n    },\n    [submitTextBox, undoStackRef]\n  );\n\n  const handleSelect = useCallback(\n    ({ target: { selectionEnd, selectionStart, value } }) => {\n      if (value === prevInputStateRef.current.value) {\n        // When caret move, we should push to undo stack on change.\n        placeCheckpointOnChangeRef.current = true;\n      }\n\n      prevInputStateRef.current = { selectionEnd, selectionStart, value };\n    },\n    [placeCheckpointOnChangeRef, prevInputStateRef]\n  );\n\n  const handleSubmit = useCallback(\n    event => {\n      event.preventDefault();\n\n      // Consider clearing the send box only after we received POST_ACTIVITY_PENDING\n      // E.g. if the connection is bad, sending the message essentially do nothing but just clearing the send box\n      submitTextBox();\n\n      // After submit, we will clear the undo stack.\n      undoStackRef.current = [];\n    },\n    [submitTextBox, undoStackRef]\n  );\n\n  return (\n    <form\n      aria-disabled={disabled}\n      className={classNames(\n        'webchat__send-box-text-box',\n        rootClassName,\n        sendBoxTextAreaStyleSet + '',\n        sendBoxTextBoxStyleSet + '',\n        (className || '') + ''\n      )}\n      onSubmit={disabled ? PREVENT_DEFAULT_HANDLER : handleSubmit}\n    >\n      {!sendBoxTextWrap ? (\n        <AccessibleInputText\n          aria-label={sendBoxString}\n          className=\"webchat__send-box-text-box__input\"\n          data-id=\"webchat-sendbox-input\"\n          disabled={disabled}\n          enterkeyhint=\"send\" // The version of React we are using does not support \"enterKeyHint\" yet\n          inputMode=\"text\"\n          onChange={disabled ? undefined : handleChange}\n          onFocus={disabled ? undefined : handleFocus}\n          onKeyDown={disabled ? undefined : handleKeyDown}\n          onKeyPress={disabled ? undefined : handleKeyPress}\n          onSelect={disabled ? undefined : handleSelect}\n          placeholder={typeYourMessageString}\n          readOnly={disabled}\n          ref={inputRefCallback}\n          type=\"text\"\n          value={textBoxValue}\n        />\n      ) : (\n        <div className=\"webchat__send-box-text-box__text-area-box\">\n          <AccessibleTextArea\n            aria-label={sendBoxString}\n            className=\"webchat__send-box-text-box__text-area\"\n            data-id=\"webchat-sendbox-input\"\n            disabled={disabled}\n            enterkeyhint=\"send\" // The version of React we are using does not support \"enterKeyHint\" yet\n            inputMode=\"text\"\n            onChange={disabled ? undefined : handleChange}\n            onFocus={disabled ? undefined : handleFocus}\n            onKeyDown={disabled ? undefined : handleKeyDown}\n            onKeyPress={disabled ? undefined : handleKeyPress}\n            onSelect={disabled ? undefined : handleSelect}\n            placeholder={typeYourMessageString}\n            readOnly={disabled}\n            ref={inputRefCallback}\n            rows=\"1\"\n            value={textBoxValue}\n          />\n          <div className=\"webchat__send-box-text-box__text-area-doppelganger\">{textBoxValue + '\\n'}</div>\n        </div>\n      )}\n      {disabled && <div className=\"webchat__send-box-text-box__glass\" />}\n    </form>\n  );\n});\n\nTextBoxCore.defaultProps = {\n  className: ''\n};\n\nTextBoxCore.propTypes = {\n  className: PropTypes.string\n};\n\nconst TextBox = ({ className }) => (\n  // For DOM node referenced by sendFocusRef, we are using a hack to focus on it.\n  // By flipping readOnly attribute while setting focus, we can focus on text box without popping the virtual keyboard on mobile device.\n  <TypeFocusSinkContext.Consumer>\n    {({ sendFocusRef }) => <TextBoxCore className={className} ref={sendFocusRef} />}\n  </TypeFocusSinkContext.Consumer>\n);\n\nTextBox.defaultProps = {\n  className: ''\n};\n\nTextBox.propTypes = {\n  className: PropTypes.string\n};\n\nexport default TextBox;\n\nexport { connectSendTextBox, useTextBoxSubmit, useTextBoxValue };\n"],"sourceRoot":"component:///"},"metadata":{},"sourceType":"script"}