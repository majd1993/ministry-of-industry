{"ast":null,"code":"import _classCallCheck from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { InvalidOperationError } from \"../../common/Error\";\n/**\n * Base audio player class\n * TODO: Plays only PCM for now.\n * @class\n */\n\nexport var BaseAudioPlayer = /*#__PURE__*/function () {\n  /**\n   * Creates and initializes an instance of this class.\n   * @constructor\n   */\n  function BaseAudioPlayer(audioFormat) {\n    _classCallCheck(this, BaseAudioPlayer);\n\n    this.audioContext = null;\n    this.gainNode = null;\n    this.autoUpdateBufferTimer = 0;\n    this.init(audioFormat);\n  }\n  /**\n   * play Audio sample\n   * @param newAudioData audio data to be played.\n   */\n\n\n  _createClass(BaseAudioPlayer, [{\n    key: \"playAudioSample\",\n    value: function playAudioSample(newAudioData) {\n      this.ensureInitializedContext();\n      var audioData = this.formatAudioData(newAudioData);\n      var newSamplesData = new Float32Array(this.samples.length + audioData.length);\n      newSamplesData.set(this.samples, 0);\n      newSamplesData.set(audioData, this.samples.length);\n      this.samples = newSamplesData;\n    }\n    /**\n     * stops audio and clears the buffers\n     */\n\n  }, {\n    key: \"stopAudio\",\n    value: function stopAudio() {\n      if (this.audioContext !== null) {\n        this.samples = new Float32Array();\n        clearInterval(this.autoUpdateBufferTimer);\n        this.audioContext.close();\n        this.audioContext = null;\n      }\n    }\n  }, {\n    key: \"init\",\n    value: function init(audioFormat) {\n      this.audioFormat = audioFormat;\n      this.samples = new Float32Array();\n    }\n  }, {\n    key: \"ensureInitializedContext\",\n    value: function ensureInitializedContext() {\n      var _this = this;\n\n      if (this.audioContext === null) {\n        this.createAudioContext();\n        var timerPeriod = 200;\n        this.autoUpdateBufferTimer = setInterval(function () {\n          _this.updateAudioBuffer();\n        }, timerPeriod);\n      }\n    }\n  }, {\n    key: \"createAudioContext\",\n    value: function createAudioContext() {\n      // new ((window as any).AudioContext || (window as any).webkitAudioContext)();\n      this.audioContext = new AudioContext(); // TODO: Various examples shows this gain node, it does not seem to be needed unless we plan\n      // to control the volume, not likely\n\n      this.gainNode = this.audioContext.createGain();\n      this.gainNode.gain.value = 1;\n      this.gainNode.connect(this.audioContext.destination);\n      this.startTime = this.audioContext.currentTime;\n    }\n  }, {\n    key: \"formatAudioData\",\n    value: function formatAudioData(audioData) {\n      switch (this.audioFormat.bitsPerSample) {\n        case 8:\n          return this.formatArrayBuffer(new Int8Array(audioData), 128);\n\n        case 16:\n          return this.formatArrayBuffer(new Int16Array(audioData), 32768);\n\n        case 32:\n          return this.formatArrayBuffer(new Int32Array(audioData), 2147483648);\n\n        default:\n          throw new InvalidOperationError(\"Only WAVE_FORMAT_PCM (8/16/32 bps) format supported at this time\");\n      }\n    }\n  }, {\n    key: \"formatArrayBuffer\",\n    value: function formatArrayBuffer(audioData, maxValue) {\n      var float32Data = new Float32Array(audioData.length);\n\n      for (var i = 0; i < audioData.length; i++) {\n        float32Data[i] = audioData[i] / maxValue;\n      }\n\n      return float32Data;\n    }\n  }, {\n    key: \"updateAudioBuffer\",\n    value: function updateAudioBuffer() {\n      if (this.samples.length === 0) {\n        return;\n      }\n\n      var channelCount = this.audioFormat.channels;\n      var bufferSource = this.audioContext.createBufferSource();\n      var frameCount = this.samples.length / channelCount;\n      var audioBuffer = this.audioContext.createBuffer(channelCount, frameCount, this.audioFormat.samplesPerSec); // TODO: Should we do the conversion in the pushAudioSample instead?\n\n      for (var channel = 0; channel < channelCount; channel++) {\n        // Fill in individual channel data\n        var channelOffset = channel;\n        var audioData = audioBuffer.getChannelData(channel);\n\n        for (var i = 0; i < this.samples.length; i++, channelOffset += channelCount) {\n          audioData[i] = this.samples[channelOffset];\n        }\n      }\n\n      if (this.startTime < this.audioContext.currentTime) {\n        this.startTime = this.audioContext.currentTime;\n      }\n\n      bufferSource.buffer = audioBuffer;\n      bufferSource.connect(this.gainNode);\n      bufferSource.start(this.startTime); // Make sure we play the next sample after the current one.\n\n      this.startTime += audioBuffer.duration; // Clear the samples for the next pushed data.\n\n      this.samples = new Float32Array();\n    }\n  }]);\n\n  return BaseAudioPlayer;\n}();","map":{"version":3,"sources":["src/sdk/Audio/BaseAudioPlayer.ts"],"names":[],"mappings":";;AAAA;AACA;AAEA,SAAS,qBAAT,QAAsC,oBAAtC;AAKA;;;;AAIG;;AACH,WAAa,eAAb;AASI;;;AAGG;AACH,2BAAmB,WAAnB,EAAiD;AAAA;;AAXzC,SAAA,YAAA,GAA6B,IAA7B;AACA,SAAA,QAAA,GAAqB,IAArB;AAEA,SAAA,qBAAA,GAA6B,CAA7B;AASJ,SAAK,IAAL,CAAU,WAAV;AACH;AAED;;;AAGG;;;AApBP;AAAA;AAAA,WAqBW,yBAAgB,YAAhB,EAAyC;AAC5C,WAAK,wBAAL;AACA,UAAM,SAAS,GAAG,KAAK,eAAL,CAAqB,YAArB,CAAlB;AACA,UAAM,cAAc,GAAG,IAAI,YAAJ,CAAiB,KAAK,OAAL,CAAa,MAAb,GAAsB,SAAS,CAAC,MAAjD,CAAvB;AACA,MAAA,cAAc,CAAC,GAAf,CAAmB,KAAK,OAAxB,EAAiC,CAAjC;AACA,MAAA,cAAc,CAAC,GAAf,CAAmB,SAAnB,EAA8B,KAAK,OAAL,CAAa,MAA3C;AACA,WAAK,OAAL,GAAe,cAAf;AACH;AACD;;AAEG;;AA/BP;AAAA;AAAA,WAgCW,qBAAS;AACZ,UAAI,KAAK,YAAL,KAAsB,IAA1B,EAAgC;AAC5B,aAAK,OAAL,GAAe,IAAI,YAAJ,EAAf;AACA,QAAA,aAAa,CAAC,KAAK,qBAAN,CAAb;AACA,aAAK,YAAL,CAAkB,KAAlB;AACA,aAAK,YAAL,GAAoB,IAApB;AACH;AACJ;AAvCL;AAAA;AAAA,WAyCY,cAAK,WAAL,EAAmC;AACvC,WAAK,WAAL,GAAmB,WAAnB;AACA,WAAK,OAAL,GAAe,IAAI,YAAJ,EAAf;AACH;AA5CL;AAAA;AAAA,WA8CY,oCAAwB;AAAA;;AAC5B,UAAI,KAAK,YAAL,KAAsB,IAA1B,EAAgC;AAC5B,aAAK,kBAAL;AACA,YAAM,WAAW,GAAG,GAApB;AACA,aAAK,qBAAL,GAA6B,WAAW,CAAC,YAAK;AACd,UAAA,KAAI,CAAC,iBAAL;AACH,SAFW,EAET,WAFS,CAAxC;AAGH;AACJ;AAtDL;AAAA;AAAA,WAwDY,8BAAkB;AACtB;AACA,WAAK,YAAL,GAAoB,IAAI,YAAJ,EAApB,CAFsB,CAItB;AACA;;AACA,WAAK,QAAL,GAAgB,KAAK,YAAL,CAAkB,UAAlB,EAAhB;AACA,WAAK,QAAL,CAAc,IAAd,CAAmB,KAAnB,GAA2B,CAA3B;AACA,WAAK,QAAL,CAAc,OAAd,CAAsB,KAAK,YAAL,CAAkB,WAAxC;AACA,WAAK,SAAL,GAAiB,KAAK,YAAL,CAAkB,WAAnC;AACH;AAlEL;AAAA;AAAA,WAoEY,yBAAgB,SAAhB,EAAsC;AAC1C,cAAQ,KAAK,WAAL,CAAiB,aAAzB;AACI,aAAK,CAAL;AACI,iBAAO,KAAK,iBAAL,CAAuB,IAAI,SAAJ,CAAc,SAAd,CAAvB,EAAiD,GAAjD,CAAP;;AACJ,aAAK,EAAL;AACI,iBAAO,KAAK,iBAAL,CAAuB,IAAI,UAAJ,CAAe,SAAf,CAAvB,EAAkD,KAAlD,CAAP;;AACJ,aAAK,EAAL;AACI,iBAAO,KAAK,iBAAL,CAAuB,IAAI,UAAJ,CAAe,SAAf,CAAvB,EAAkD,UAAlD,CAAP;;AACJ;AACI,gBAAM,IAAI,qBAAJ,CAA0B,kEAA1B,CAAN;AARR;AAUH;AA/EL;AAAA;AAAA,WAiFY,2BAAkB,SAAlB,EAAkD,QAAlD,EAAkE;AACtE,UAAM,WAAW,GAAG,IAAI,YAAJ,CAAiB,SAAS,CAAC,MAA3B,CAApB;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,SAAS,CAAC,MAA9B,EAAsC,CAAC,EAAvC,EAA2C;AACvC,QAAA,WAAW,CAAC,CAAD,CAAX,GAAiB,SAAS,CAAC,CAAD,CAAT,GAAe,QAAhC;AACH;;AACD,aAAO,WAAP;AACH;AAvFL;AAAA;AAAA,WAyFY,6BAAiB;AACrB,UAAI,KAAK,OAAL,CAAa,MAAb,KAAwB,CAA5B,EAA+B;AAC3B;AACH;;AAED,UAAM,YAAY,GAAG,KAAK,WAAL,CAAiB,QAAtC;AACA,UAAM,YAAY,GAAG,KAAK,YAAL,CAAkB,kBAAlB,EAArB;AACA,UAAM,UAAU,GAAG,KAAK,OAAL,CAAa,MAAb,GAAsB,YAAzC;AACA,UAAM,WAAW,GAAG,KAAK,YAAL,CAAkB,YAAlB,CAA+B,YAA/B,EAA6C,UAA7C,EAAyD,KAAK,WAAL,CAAiB,aAA1E,CAApB,CARqB,CAUrB;;AACA,WAAK,IAAI,OAAO,GAAG,CAAnB,EAAsB,OAAO,GAAG,YAAhC,EAA8C,OAAO,EAArD,EAAyD;AACrD;AACA,YAAI,aAAa,GAAG,OAApB;AACA,YAAM,SAAS,GAAG,WAAW,CAAC,cAAZ,CAA2B,OAA3B,CAAlB;;AACA,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,OAAL,CAAa,MAAjC,EAAyC,CAAC,IAAI,aAAa,IAAI,YAA/D,EAA6E;AACzE,UAAA,SAAS,CAAC,CAAD,CAAT,GAAe,KAAK,OAAL,CAAa,aAAb,CAAf;AACH;AACJ;;AAED,UAAI,KAAK,SAAL,GAAiB,KAAK,YAAL,CAAkB,WAAvC,EAAoD;AAChD,aAAK,SAAL,GAAiB,KAAK,YAAL,CAAkB,WAAnC;AACH;;AAED,MAAA,YAAY,CAAC,MAAb,GAAsB,WAAtB;AACA,MAAA,YAAY,CAAC,OAAb,CAAqB,KAAK,QAA1B;AACA,MAAA,YAAY,CAAC,KAAb,CAAmB,KAAK,SAAxB,EA1BqB,CA4BrB;;AACA,WAAK,SAAL,IAAkB,WAAW,CAAC,QAA9B,CA7BqB,CA+BrB;;AACA,WAAK,OAAL,GAAe,IAAI,YAAJ,EAAf;AACH;AA1HL;;AAAA;AAAA","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { InvalidOperationError } from \"../../common/Error\";\r\nimport { AudioStreamFormat, PullAudioInputStreamCallback } from \"../Exports\";\r\nimport { AudioStreamFormatImpl } from \"./AudioStreamFormat\";\r\n\r\ntype AudioDataTypedArray = Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array;\r\n/**\r\n * Base audio player class\r\n * TODO: Plays only PCM for now.\r\n * @class\r\n */\r\nexport class BaseAudioPlayer {\r\n\r\n    private audioContext: AudioContext = null;\r\n    private gainNode: GainNode = null;\r\n    private audioFormat: AudioStreamFormatImpl;\r\n    private autoUpdateBufferTimer: any = 0;\r\n    private samples: Float32Array;\r\n    private startTime: number;\r\n\r\n    /**\r\n     * Creates and initializes an instance of this class.\r\n     * @constructor\r\n     */\r\n    public constructor(audioFormat: AudioStreamFormat) {\r\n        this.init(audioFormat);\r\n    }\r\n\r\n    /**\r\n     * play Audio sample\r\n     * @param newAudioData audio data to be played.\r\n     */\r\n    public playAudioSample(newAudioData: ArrayBuffer): void {\r\n        this.ensureInitializedContext();\r\n        const audioData = this.formatAudioData(newAudioData);\r\n        const newSamplesData = new Float32Array(this.samples.length + audioData.length);\r\n        newSamplesData.set(this.samples, 0);\r\n        newSamplesData.set(audioData, this.samples.length);\r\n        this.samples = newSamplesData;\r\n    }\r\n    /**\r\n     * stops audio and clears the buffers\r\n     */\r\n    public stopAudio(): void {\r\n        if (this.audioContext !== null) {\r\n            this.samples = new Float32Array();\r\n            clearInterval(this.autoUpdateBufferTimer);\r\n            this.audioContext.close();\r\n            this.audioContext = null;\r\n        }\r\n    }\r\n\r\n    private init(audioFormat: AudioStreamFormat): void {\r\n        this.audioFormat = audioFormat as AudioStreamFormatImpl;\r\n        this.samples = new Float32Array();\r\n    }\r\n\r\n    private ensureInitializedContext(): void {\r\n        if (this.audioContext === null) {\r\n            this.createAudioContext();\r\n            const timerPeriod = 200;\r\n            this.autoUpdateBufferTimer = setInterval(() => {\r\n                                            this.updateAudioBuffer();\r\n                                        }, timerPeriod);\r\n        }\r\n    }\r\n\r\n    private createAudioContext(): void {\r\n        // new ((window as any).AudioContext || (window as any).webkitAudioContext)();\r\n        this.audioContext = new AudioContext();\r\n\r\n        // TODO: Various examples shows this gain node, it does not seem to be needed unless we plan\r\n        // to control the volume, not likely\r\n        this.gainNode = this.audioContext.createGain();\r\n        this.gainNode.gain.value = 1;\r\n        this.gainNode.connect(this.audioContext.destination);\r\n        this.startTime = this.audioContext.currentTime;\r\n    }\r\n\r\n    private formatAudioData(audioData: ArrayBuffer): Float32Array {\r\n        switch (this.audioFormat.bitsPerSample) {\r\n            case 8:\r\n                return this.formatArrayBuffer(new Int8Array(audioData), 128);\r\n            case 16:\r\n                return this.formatArrayBuffer(new Int16Array(audioData), 32768);\r\n            case 32:\r\n                return this.formatArrayBuffer(new Int32Array(audioData), 2147483648);\r\n            default:\r\n                throw new InvalidOperationError(\"Only WAVE_FORMAT_PCM (8/16/32 bps) format supported at this time\");\r\n        }\r\n    }\r\n\r\n    private formatArrayBuffer(audioData: AudioDataTypedArray, maxValue: number): Float32Array {\r\n        const float32Data = new Float32Array(audioData.length);\r\n        for (let i = 0; i < audioData.length; i++) {\r\n            float32Data[i] = audioData[i] / maxValue;\r\n        }\r\n        return float32Data;\r\n    }\r\n\r\n    private updateAudioBuffer(): void {\r\n        if (this.samples.length === 0) {\r\n            return;\r\n        }\r\n\r\n        const channelCount = this.audioFormat.channels;\r\n        const bufferSource = this.audioContext.createBufferSource();\r\n        const frameCount = this.samples.length / channelCount;\r\n        const audioBuffer = this.audioContext.createBuffer(channelCount, frameCount, this.audioFormat.samplesPerSec);\r\n\r\n        // TODO: Should we do the conversion in the pushAudioSample instead?\r\n        for (let channel = 0; channel < channelCount; channel++) {\r\n            // Fill in individual channel data\r\n            let channelOffset = channel;\r\n            const audioData = audioBuffer.getChannelData(channel);\r\n            for (let i = 0; i < this.samples.length; i++, channelOffset += channelCount) {\r\n                audioData[i] = this.samples[channelOffset];\r\n            }\r\n        }\r\n\r\n        if (this.startTime < this.audioContext.currentTime) {\r\n            this.startTime = this.audioContext.currentTime;\r\n        }\r\n\r\n        bufferSource.buffer = audioBuffer;\r\n        bufferSource.connect(this.gainNode);\r\n        bufferSource.start(this.startTime);\r\n\r\n        // Make sure we play the next sample after the current one.\r\n        this.startTime += audioBuffer.duration;\r\n\r\n        // Clear the samples for the next pushed data.\r\n        this.samples = new Float32Array();\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}