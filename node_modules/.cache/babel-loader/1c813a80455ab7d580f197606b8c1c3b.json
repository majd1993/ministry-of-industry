{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSpeechRecognitionPonyfillFromRecognizer = createSpeechRecognitionPonyfillFromRecognizer;\nexports.default = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _eventTargetShimEs = require(\"event-target-shim-es5\");\n\nvar _cognitiveServiceEventResultToWebSpeechRecognitionResultList = _interopRequireDefault(require(\"./cognitiveServiceEventResultToWebSpeechRecognitionResultList\"));\n\nvar _createPromiseQueue = _interopRequireDefault(require(\"../../Util/createPromiseQueue\"));\n\nvar _patchOptions2 = _interopRequireDefault(require(\"../patchOptions\"));\n\nvar _SpeechGrammarList = _interopRequireDefault(require(\"./SpeechGrammarList\"));\n\nvar _SpeechSDK = _interopRequireDefault(require(\"../SpeechSDK\"));\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function () {\n    var Super = (0, _getPrototypeOf2.default)(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return (0, _possibleConstructorReturn2.default)(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // https://docs.microsoft.com/en-us/javascript/api/microsoft-cognitiveservices-speech-sdk/speechconfig?view=azure-node-latest#outputformat\n// {\n//   \"RecognitionStatus\": \"Success\",\n//   \"Offset\": 900000,\n//   \"Duration\": 49000000,\n//   \"NBest\": [\n//     {\n//       \"Confidence\": 0.738919,\n//       \"Lexical\": \"second\",\n//       \"ITN\": \"second\",\n//       \"MaskedITN\": \"second\",\n//       \"Display\": \"Second.\"\n//     }\n//   ]\n// }\n// {\n//   \"RecognitionStatus\": \"InitialSilenceTimeout\",\n//   \"Offset\": 50000000,\n//   \"Duration\": 0\n// }\n\n\nvar AudioConfig = _SpeechSDK.default.AudioConfig,\n    OutputFormat = _SpeechSDK.default.OutputFormat,\n    ResultReason = _SpeechSDK.default.ResultReason,\n    SpeechConfig = _SpeechSDK.default.SpeechConfig,\n    SpeechRecognizer = _SpeechSDK.default.SpeechRecognizer;\n\nfunction serializeRecognitionResult(_ref) {\n  var duration = _ref.duration,\n      errorDetails = _ref.errorDetails,\n      json = _ref.json,\n      offset = _ref.offset,\n      properties = _ref.properties,\n      reason = _ref.reason,\n      resultId = _ref.resultId,\n      text = _ref.text;\n  return {\n    duration: duration,\n    errorDetails: errorDetails,\n    json: JSON.parse(json),\n    offset: offset,\n    properties: properties,\n    reason: reason,\n    resultId: resultId,\n    text: text\n  };\n}\n\nfunction improviseAsync(fn, improviser) {\n  return function () {\n    return fn.apply(void 0, arguments).onSuccessContinueWith(function (result) {\n      return improviser(result);\n    });\n  };\n}\n\nfunction averageAmplitude(arrayBuffer) {\n  var array = new Int16Array(arrayBuffer);\n  return [].reduce.call(array, function (averageAmplitude, amplitude) {\n    return averageAmplitude + Math.abs(amplitude);\n  }, 0) / array.length;\n}\n\nfunction cognitiveServicesAsyncToPromise(fn) {\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return new Promise(function (resolve, reject) {\n      return fn.apply(void 0, args.concat([resolve, reject]));\n    });\n  };\n}\n\nvar SpeechRecognitionEvent = function SpeechRecognitionEvent(type) {\n  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      data = _ref2.data,\n      emma = _ref2.emma,\n      interpretation = _ref2.interpretation,\n      resultIndex = _ref2.resultIndex,\n      results = _ref2.results;\n\n  (0, _classCallCheck2.default)(this, SpeechRecognitionEvent);\n  this.data = data;\n  this.emma = emma;\n  this.interpretation = interpretation;\n  this.resultIndex = resultIndex;\n  this.results = results;\n  this.type = type;\n};\n\nfunction prepareAudioConfig(audioConfig) {\n  var originalAttach = audioConfig.attach;\n  var firstChunk;\n  var muted; // We modify \"attach\" function and detect when audible chunk is read.\n  // We will only modify \"attach\" function once.\n\n  audioConfig.attach = improviseAsync(originalAttach.bind(audioConfig), function (reader) {\n    return _objectSpread(_objectSpread({}, reader), {}, {\n      read: improviseAsync(reader.read.bind(reader), function (chunk) {\n        // The magic number 150 is measured by:\n        // 1. Set microphone volume to 0\n        // 2. Observe the amplitude (100-110) for the first few chunks\n        //    (There is a short static caught when turning on the microphone)\n        // 3. Set the number a bit higher than the observation\n        if (!firstChunk && averageAmplitude(chunk.buffer) > 150) {\n          audioConfig.events.onEvent({\n            name: 'FirstAudibleChunk'\n          });\n          firstChunk = true;\n        }\n\n        if (muted) {\n          return {\n            buffer: new ArrayBuffer(0),\n            isEnd: true,\n            timeReceived: Date.now()\n          };\n        }\n\n        return chunk;\n      })\n    });\n  });\n  return {\n    audioConfig: audioConfig,\n    pause: function pause() {\n      muted = true;\n    },\n    unprepare: function unprepare() {\n      audioConfig.attach = originalAttach;\n    }\n  };\n}\n\nfunction createSpeechRecognitionPonyfillFromRecognizer(_ref3) {\n  var createRecognizer = _ref3.createRecognizer,\n      enableTelemetry = _ref3.enableTelemetry,\n      looseEvents = _ref3.looseEvents,\n      referenceGrammars = _ref3.referenceGrammars,\n      textNormalization = _ref3.textNormalization; // If enableTelemetry is set to null or non-boolean, we will default to true.\n\n  SpeechRecognizer.enableTelemetry(enableTelemetry !== false);\n\n  var SpeechRecognition = /*#__PURE__*/function (_EventTarget) {\n    (0, _inherits2.default)(SpeechRecognition, _EventTarget);\n\n    var _super = _createSuper(SpeechRecognition);\n\n    function SpeechRecognition() {\n      var _this;\n\n      (0, _classCallCheck2.default)(this, SpeechRecognition);\n      _this = _super.call(this);\n      _this._continuous = false;\n      _this._interimResults = false;\n      _this._lang = typeof window !== 'undefined' ? window.document.documentElement.getAttribute('lang') || window.navigator.language : 'en-US';\n      _this._grammars = new _SpeechGrammarList.default();\n      _this._maxAlternatives = 1;\n      return _this;\n    }\n\n    (0, _createClass2.default)(SpeechRecognition, [{\n      key: \"emitCognitiveServices\",\n      value: function emitCognitiveServices(type, event) {\n        this.dispatchEvent(new SpeechRecognitionEvent('cognitiveservices', {\n          data: _objectSpread(_objectSpread({}, event), {}, {\n            type: type\n          })\n        }));\n      }\n    }, {\n      key: \"start\",\n      value: function start() {\n        var _this2 = this;\n\n        this._startOnce().catch(function (err) {\n          _this2.dispatchEvent(new ErrorEvent('error', {\n            error: err,\n            message: err && (err.stack || err.message)\n          }));\n        });\n      }\n    }, {\n      key: \"_startOnce\",\n      value: function () {\n        var _startOnce2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {\n          var _this3 = this;\n\n          var recognizer, _prepareAudioConfig, pause, unprepare, queue, soundStarted, speechStarted, stopping, _recognizer$audioConf, detachAudioConfigEvent, phrases, dynamicGrammar, audioStarted, finalEvent, finalizedResults, _loop, loop, _ret;\n\n          return _regenerator.default.wrap(function _callee$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _context2.next = 2;\n                  return createRecognizer(this.lang);\n\n                case 2:\n                  recognizer = _context2.sent;\n                  _prepareAudioConfig = prepareAudioConfig(recognizer.audioConfig), pause = _prepareAudioConfig.pause, unprepare = _prepareAudioConfig.unprepare;\n                  _context2.prev = 4;\n                  queue = (0, _createPromiseQueue.default)();\n                  _recognizer$audioConf = recognizer.audioConfig.events.attach(function (event) {\n                    var name = event.name;\n\n                    if (name === 'AudioSourceReadyEvent') {\n                      queue.push({\n                        audioSourceReady: {}\n                      });\n                    } else if (name === 'AudioSourceOffEvent') {\n                      queue.push({\n                        audioSourceOff: {}\n                      });\n                    } else if (name === 'FirstAudibleChunk') {\n                      queue.push({\n                        firstAudibleChunk: {}\n                      });\n                    }\n                  }), detachAudioConfigEvent = _recognizer$audioConf.detach;\n\n                  recognizer.canceled = function (_, _ref4) {\n                    var errorDetails = _ref4.errorDetails,\n                        offset = _ref4.offset,\n                        reason = _ref4.reason,\n                        sessionId = _ref4.sessionId;\n                    queue.push({\n                      canceled: {\n                        errorDetails: errorDetails,\n                        offset: offset,\n                        reason: reason,\n                        sessionId: sessionId\n                      }\n                    });\n                  };\n\n                  recognizer.recognized = function (_, _ref5) {\n                    var offset = _ref5.offset,\n                        result = _ref5.result,\n                        sessionId = _ref5.sessionId;\n                    queue.push({\n                      recognized: {\n                        offset: offset,\n                        result: serializeRecognitionResult(result),\n                        sessionId: sessionId\n                      }\n                    });\n                  };\n\n                  recognizer.recognizing = function (_, _ref6) {\n                    var offset = _ref6.offset,\n                        result = _ref6.result,\n                        sessionId = _ref6.sessionId;\n                    queue.push({\n                      recognizing: {\n                        offset: offset,\n                        result: serializeRecognitionResult(result),\n                        sessionId: sessionId\n                      }\n                    });\n                  };\n\n                  recognizer.sessionStarted = function (_, _ref7) {\n                    var sessionId = _ref7.sessionId;\n                    queue.push({\n                      sessionStarted: {\n                        sessionId: sessionId\n                      }\n                    });\n                  };\n\n                  recognizer.sessionStopped = function (_, _ref8) {\n                    var sessionId = _ref8.sessionId; // \"sessionStopped\" is never fired, probably because we are using startContinuousRecognitionAsync instead of recognizeOnceAsync.\n\n                    queue.push({\n                      sessionStopped: {\n                        sessionId: sessionId\n                      }\n                    });\n                  };\n\n                  recognizer.speechStartDetected = function (_, _ref9) {\n                    var offset = _ref9.offset,\n                        sessionId = _ref9.sessionId;\n                    queue.push({\n                      speechStartDetected: {\n                        offset: offset,\n                        sessionId: sessionId\n                      }\n                    });\n                  };\n\n                  recognizer.speechEndDetected = function (_, _ref10) {\n                    var sessionId = _ref10.sessionId; // \"speechEndDetected\" is never fired, probably because we are using startContinuousRecognitionAsync instead of recognizeOnceAsync.\n                    // Update: \"speechEndDetected\" is fired for DLSpeech.listenOnceAsync()\n\n                    queue.push({\n                      speechEndDetected: {\n                        sessionId: sessionId\n                      }\n                    });\n                  };\n\n                  phrases = this.grammars.phrases; // HACK: We are using the internal of SpeechRecognizer because they did not expose it\n\n                  dynamicGrammar = recognizer.privReco.dynamicGrammar;\n                  referenceGrammars && referenceGrammars.length && dynamicGrammar.addReferenceGrammar(referenceGrammars);\n                  phrases && phrases.length && dynamicGrammar.addPhrase(phrases);\n                  _context2.next = 20;\n                  return cognitiveServicesAsyncToPromise(recognizer.startContinuousRecognitionAsync.bind(recognizer))();\n\n                case 20:\n                  if (recognizer.stopContinuousRecognitionAsync) {\n                    this.abort = function () {\n                      return queue.push({\n                        abort: {}\n                      });\n                    };\n\n                    this.stop = function () {\n                      return queue.push({\n                        stop: {}\n                      });\n                    };\n                  } else {\n                    this.abort = this.stop = undefined;\n                  }\n\n                  finalizedResults = [];\n                  _loop = /*#__PURE__*/_regenerator.default.mark(function _loop(loop) {\n                    var event, abort, audioSourceOff, audioSourceReady, canceled, firstAudibleChunk, recognized, recognizing, stop, errorMessage, result, recognizable;\n                    return _regenerator.default.wrap(function _loop$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            _context.next = 2;\n                            return queue.shift();\n\n                          case 2:\n                            event = _context.sent;\n                            abort = event.abort, audioSourceOff = event.audioSourceOff, audioSourceReady = event.audioSourceReady, canceled = event.canceled, firstAudibleChunk = event.firstAudibleChunk, recognized = event.recognized, recognizing = event.recognizing, stop = event.stop; // We are emitting event \"cognitiveservices\" for debugging purpose.\n\n                            Object.keys(event).forEach(function (name) {\n                              return _this3.emitCognitiveServices(name, event[name]);\n                            });\n                            errorMessage = canceled && canceled.errorDetails;\n\n                            if (!/Permission[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]denied/.test(errorMessage || '')) {\n                              _context.next = 9;\n                              break;\n                            } // If microphone is not allowed, we should not emit \"start\" event.\n\n\n                            finalEvent = {\n                              error: 'not-allowed',\n                              type: 'error'\n                            };\n                            return _context.abrupt(\"return\", \"break\");\n\n                          case 9:\n                            if (!loop) {\n                              _this3.dispatchEvent(new SpeechRecognitionEvent('start'));\n                            }\n\n                            if (!errorMessage) {\n                              _context.next = 15;\n                              break;\n                            }\n\n                            if (/1006/.test(errorMessage)) {\n                              if (!audioStarted) {\n                                _this3.dispatchEvent(new SpeechRecognitionEvent('audiostart'));\n\n                                _this3.dispatchEvent(new SpeechRecognitionEvent('audioend'));\n                              }\n\n                              finalEvent = {\n                                error: 'network',\n                                type: 'error'\n                              };\n                            } else {\n                              finalEvent = {\n                                error: 'unknown',\n                                type: 'error'\n                              };\n                            }\n\n                            return _context.abrupt(\"return\", \"break\");\n\n                          case 15:\n                            if (!(abort || stop)) {\n                              _context.next = 22;\n                              break;\n                            }\n\n                            if (abort) {\n                              finalEvent = {\n                                error: 'aborted',\n                                type: 'error'\n                              }; // If we are aborting, we will ignore lingering recognizing/recognized events. But if we are stopping, we need them.\n\n                              stopping = 'abort';\n                            } else {\n                              // When we pause, we will send { isEnd: true }, Speech Services will send us \"recognized\" event.\n                              pause();\n                              stopping = 'stop';\n                            } // Abort should not be dispatched without support of \"stopContinuousRecognitionAsync\".\n                            // But for defensive purpose, we make sure \"stopContinuousRecognitionAsync\" is available before we can call.\n\n\n                            if (!(abort && recognizer.stopContinuousRecognitionAsync)) {\n                              _context.next = 20;\n                              break;\n                            }\n\n                            _context.next = 20;\n                            return cognitiveServicesAsyncToPromise(recognizer.stopContinuousRecognitionAsync.bind(recognizer))();\n\n                          case 20:\n                            _context.next = 61;\n                            break;\n\n                          case 22:\n                            if (!audioSourceReady) {\n                              _context.next = 27;\n                              break;\n                            }\n\n                            _this3.dispatchEvent(new SpeechRecognitionEvent('audiostart'));\n\n                            audioStarted = true;\n                            _context.next = 61;\n                            break;\n\n                          case 27:\n                            if (!firstAudibleChunk) {\n                              _context.next = 32;\n                              break;\n                            }\n\n                            _this3.dispatchEvent(new SpeechRecognitionEvent('soundstart'));\n\n                            soundStarted = true;\n                            _context.next = 61;\n                            break;\n\n                          case 32:\n                            if (!audioSourceOff) {\n                              _context.next = 40;\n                              break;\n                            } // Looks like we don't need this line and all the tests are still working.\n                            // Guessing probably stopping is already truthy.\n                            // stopping = true;\n\n\n                            speechStarted && _this3.dispatchEvent(new SpeechRecognitionEvent('speechend'));\n                            soundStarted && _this3.dispatchEvent(new SpeechRecognitionEvent('soundend'));\n                            audioStarted && _this3.dispatchEvent(new SpeechRecognitionEvent('audioend'));\n                            audioStarted = soundStarted = speechStarted = false;\n                            return _context.abrupt(\"return\", \"break\");\n\n                          case 40:\n                            if (!(stopping !== 'abort')) {\n                              _context.next = 61;\n                              break;\n                            }\n\n                            if (!(recognized && recognized.result && recognized.result.reason === ResultReason.NoMatch)) {\n                              _context.next = 45;\n                              break;\n                            }\n\n                            finalEvent = {\n                              error: 'no-speech',\n                              type: 'error'\n                            };\n                            _context.next = 61;\n                            break;\n\n                          case 45:\n                            if (!(recognized || recognizing)) {\n                              _context.next = 61;\n                              break;\n                            }\n\n                            if (!audioStarted) {\n                              // Unconfirmed prevention of quirks\n                              _this3.dispatchEvent(new SpeechRecognitionEvent('audiostart'));\n\n                              audioStarted = true;\n                            }\n\n                            if (!soundStarted) {\n                              _this3.dispatchEvent(new SpeechRecognitionEvent('soundstart'));\n\n                              soundStarted = true;\n                            }\n\n                            if (!speechStarted) {\n                              _this3.dispatchEvent(new SpeechRecognitionEvent('speechstart'));\n\n                              speechStarted = true;\n                            }\n\n                            if (!recognized) {\n                              _context.next = 60;\n                              break;\n                            }\n\n                            result = (0, _cognitiveServiceEventResultToWebSpeechRecognitionResultList.default)(recognized.result, {\n                              maxAlternatives: _this3.maxAlternatives,\n                              textNormalization: textNormalization\n                            });\n                            recognizable = !!result[0].transcript;\n\n                            if (recognizable) {\n                              finalizedResults = [].concat((0, _toConsumableArray2.default)(finalizedResults), [result]);\n                              _this3.continuous && _this3.dispatchEvent(new SpeechRecognitionEvent('result', {\n                                results: finalizedResults\n                              }));\n                            } // If it is continuous, we just sent the finalized results. So we don't need to send it again after \"audioend\" event.\n\n\n                            if (_this3.continuous && recognizable) {\n                              finalEvent = null;\n                            } else {\n                              finalEvent = {\n                                results: finalizedResults,\n                                type: 'result'\n                              };\n                            }\n\n                            if (!(!_this3.continuous && recognizer.stopContinuousRecognitionAsync)) {\n                              _context.next = 57;\n                              break;\n                            }\n\n                            _context.next = 57;\n                            return cognitiveServicesAsyncToPromise(recognizer.stopContinuousRecognitionAsync.bind(recognizer))();\n\n                          case 57:\n                            // If event order can be loosened, we can send the recognized event as soon as we receive it.\n                            // 1. If it is not recognizable (no-speech), we should send an \"error\" event just before \"end\" event. We will not loosen \"error\" events.\n                            if (looseEvents && finalEvent && recognizable) {\n                              _this3.dispatchEvent(new SpeechRecognitionEvent(finalEvent.type, finalEvent));\n\n                              finalEvent = null;\n                            }\n\n                            _context.next = 61;\n                            break;\n\n                          case 60:\n                            if (recognizing) {\n                              _this3.interimResults && _this3.dispatchEvent(new SpeechRecognitionEvent('result', {\n                                results: [].concat((0, _toConsumableArray2.default)(finalizedResults), [(0, _cognitiveServiceEventResultToWebSpeechRecognitionResultList.default)(recognizing.result, {\n                                  maxAlternatives: _this3.maxAlternatives,\n                                  textNormalization: textNormalization\n                                })])\n                              }));\n                            }\n\n                          case 61:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _loop);\n                  });\n                  loop = 0;\n\n                case 24:\n                  if (!(!stopping || audioStarted)) {\n                    _context2.next = 32;\n                    break;\n                  }\n\n                  return _context2.delegateYield(_loop(loop), \"t0\", 26);\n\n                case 26:\n                  _ret = _context2.t0;\n\n                  if (!(_ret === \"break\")) {\n                    _context2.next = 29;\n                    break;\n                  }\n\n                  return _context2.abrupt(\"break\", 32);\n\n                case 29:\n                  loop++;\n                  _context2.next = 24;\n                  break;\n\n                case 32:\n                  if (speechStarted) {\n                    this.dispatchEvent(new SpeechRecognitionEvent('speechend'));\n                  }\n\n                  if (soundStarted) {\n                    this.dispatchEvent(new SpeechRecognitionEvent('soundend'));\n                  }\n\n                  if (audioStarted) {\n                    this.dispatchEvent(new SpeechRecognitionEvent('audioend'));\n                  }\n\n                  if (finalEvent) {\n                    if (finalEvent.type === 'result' && !finalEvent.results.length) {\n                      finalEvent = {\n                        error: 'no-speech',\n                        type: 'error'\n                      };\n                    }\n\n                    if (finalEvent.type === 'error') {\n                      this.dispatchEvent(new ErrorEvent('error', finalEvent));\n                    } else {\n                      this.dispatchEvent(new SpeechRecognitionEvent(finalEvent.type, finalEvent));\n                    }\n                  } // Even though there is no \"start\" event emitted, we will still emit \"end\" event\n                  // This is mainly for \"microphone blocked\" story.\n\n\n                  this.dispatchEvent(new SpeechRecognitionEvent('end'));\n                  detachAudioConfigEvent();\n                  _context2.next = 44;\n                  break;\n\n                case 40:\n                  _context2.prev = 40;\n                  _context2.t1 = _context2[\"catch\"](4); // Logging out the erorr because Speech SDK would fail silently.\n\n                  console.error(_context2.t1);\n                  throw _context2.t1;\n\n                case 44:\n                  _context2.prev = 44;\n                  unprepare();\n                  recognizer.dispose();\n                  return _context2.finish(44);\n\n                case 48:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee, this, [[4, 40, 44, 48]]);\n        }));\n\n        function _startOnce() {\n          return _startOnce2.apply(this, arguments);\n        }\n\n        return _startOnce;\n      }()\n    }, {\n      key: \"continuous\",\n      get: function get() {\n        return this._continuous;\n      },\n      set: function set(value) {\n        this._continuous = value;\n      }\n    }, {\n      key: \"grammars\",\n      get: function get() {\n        return this._grammars;\n      },\n      set: function set(value) {\n        if (value instanceof _SpeechGrammarList.default) {\n          this._grammars = value;\n        } else {\n          throw new Error(\"The provided value is not of type 'SpeechGrammarList'\");\n        }\n      }\n    }, {\n      key: \"interimResults\",\n      get: function get() {\n        return this._interimResults;\n      },\n      set: function set(value) {\n        this._interimResults = value;\n      }\n    }, {\n      key: \"maxAlternatives\",\n      get: function get() {\n        return this._maxAlternatives;\n      },\n      set: function set(value) {\n        this._maxAlternatives = value;\n      }\n    }, {\n      key: \"lang\",\n      get: function get() {\n        return this._lang;\n      },\n      set: function set(value) {\n        this._lang = value;\n      }\n    }]);\n    return SpeechRecognition;\n  }(_eventTargetShimEs.EventTarget);\n\n  (0, _eventTargetShimEs.defineEventAttribute)(SpeechRecognition.prototype, 'audioend');\n  (0, _eventTargetShimEs.defineEventAttribute)(SpeechRecognition.prototype, 'audiostart');\n  (0, _eventTargetShimEs.defineEventAttribute)(SpeechRecognition.prototype, 'cognitiveservices');\n  (0, _eventTargetShimEs.defineEventAttribute)(SpeechRecognition.prototype, 'end');\n  (0, _eventTargetShimEs.defineEventAttribute)(SpeechRecognition.prototype, 'error');\n  (0, _eventTargetShimEs.defineEventAttribute)(SpeechRecognition.prototype, 'nomatch');\n  (0, _eventTargetShimEs.defineEventAttribute)(SpeechRecognition.prototype, 'result');\n  (0, _eventTargetShimEs.defineEventAttribute)(SpeechRecognition.prototype, 'soundend');\n  (0, _eventTargetShimEs.defineEventAttribute)(SpeechRecognition.prototype, 'soundstart');\n  (0, _eventTargetShimEs.defineEventAttribute)(SpeechRecognition.prototype, 'speechend');\n  (0, _eventTargetShimEs.defineEventAttribute)(SpeechRecognition.prototype, 'speechstart');\n  (0, _eventTargetShimEs.defineEventAttribute)(SpeechRecognition.prototype, 'start');\n  return {\n    SpeechGrammarList: _SpeechGrammarList.default,\n    SpeechRecognition: SpeechRecognition,\n    SpeechRecognitionEvent: SpeechRecognitionEvent\n  };\n}\n\nvar _default = function _default(options) {\n  var _patchOptions = (0, _patchOptions2.default)(options),\n      _patchOptions$audioCo = _patchOptions.audioConfig,\n      audioConfig = _patchOptions$audioCo === void 0 ? AudioConfig.fromDefaultMicrophoneInput() : _patchOptions$audioCo,\n      _patchOptions$enableT = _patchOptions.enableTelemetry,\n      enableTelemetry = _patchOptions$enableT === void 0 ? true : _patchOptions$enableT,\n      fetchCredentials = _patchOptions.fetchCredentials,\n      looseEvents = _patchOptions.looseEvents,\n      referenceGrammars = _patchOptions.referenceGrammars,\n      speechRecognitionEndpointId = _patchOptions.speechRecognitionEndpointId,\n      _patchOptions$textNor = _patchOptions.textNormalization,\n      textNormalization = _patchOptions$textNor === void 0 ? 'display' : _patchOptions$textNor;\n\n  if (!audioConfig && (!window.navigator.mediaDevices || !window.navigator.mediaDevices.getUserMedia)) {\n    console.warn('web-speech-cognitive-services: This browser does not support WebRTC and it will not work with Cognitive Services Speech Services.');\n    return {};\n  }\n\n  var createRecognizer = /*#__PURE__*/function () {\n    var _ref11 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(lang) {\n      var _yield$fetchCredentia, authorizationToken, region, speechRecognitionHostname, subscriptionKey, speechConfig, host;\n\n      return _regenerator.default.wrap(function _callee2$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return fetchCredentials();\n\n            case 2:\n              _yield$fetchCredentia = _context3.sent;\n              authorizationToken = _yield$fetchCredentia.authorizationToken;\n              region = _yield$fetchCredentia.region;\n              speechRecognitionHostname = _yield$fetchCredentia.speechRecognitionHostname;\n              subscriptionKey = _yield$fetchCredentia.subscriptionKey;\n\n              if (speechRecognitionHostname) {\n                host = {\n                  hostname: speechRecognitionHostname,\n                  port: 443,\n                  protocol: 'wss:'\n                };\n\n                if (authorizationToken) {\n                  speechConfig = SpeechConfig.fromHost(host);\n                  speechConfig.authorizationToken = authorizationToken;\n                } else {\n                  speechConfig = SpeechConfig.fromHost(host, subscriptionKey);\n                }\n              } else {\n                speechConfig = authorizationToken ? SpeechConfig.fromAuthorizationToken(authorizationToken, region) : SpeechConfig.fromSubscription(subscriptionKey, region);\n              }\n\n              if (speechRecognitionEndpointId) {\n                speechConfig.endpointId = speechRecognitionEndpointId;\n              }\n\n              speechConfig.outputFormat = OutputFormat.Detailed;\n              speechConfig.speechRecognitionLanguage = lang || 'en-US';\n              return _context3.abrupt(\"return\", new SpeechRecognizer(speechConfig, audioConfig));\n\n            case 12:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function createRecognizer(_x) {\n      return _ref11.apply(this, arguments);\n    };\n  }();\n\n  return createSpeechRecognitionPonyfillFromRecognizer({\n    audioConfig: audioConfig,\n    createRecognizer: createRecognizer,\n    enableTelemetry: enableTelemetry,\n    looseEvents: looseEvents,\n    referenceGrammars: referenceGrammars,\n    textNormalization: textNormalization\n  });\n};\n\nexports.default = _default;","map":{"version":3,"sources":["../../../src/SpeechServices/SpeechToText/createSpeechRecognitionPonyfill.js"],"names":["AudioConfig","OutputFormat","ResultReason","SpeechConfig","SpeechRecognizer","SpeechSDK","duration","errorDetails","json","offset","properties","reason","resultId","text","JSON","improviser","array","averageAmplitude","Math","args","fn","SpeechRecognitionEvent","data","emma","interpretation","resultIndex","results","originalAttach","audioConfig","improviseAsync","read","reader","chunk","name","firstChunk","buffer","isEnd","timeReceived","Date","pause","muted","unprepare","createRecognizer","enableTelemetry","looseEvents","referenceGrammars","textNormalization","SpeechRecognition","EventTarget","window","SpeechGrammarList","type","value","error","message","err","recognizer","prepareAudioConfig","queue","detachAudioConfigEvent","event","audioSourceReady","audioSourceOff","firstAudibleChunk","sessionId","canceled","result","recognized","serializeRecognitionResult","recognizing","sessionStarted","sessionStopped","speechStartDetected","speechEndDetected","phrases","dynamicGrammar","cognitiveServicesAsyncToPromise","abort","stop","finalizedResults","loop","Object","errorMessage","finalEvent","stopping","audioStarted","soundStarted","speechStarted","maxAlternatives","recognizable","console","fetchCredentials","speechRecognitionEndpointId","authorizationToken","region","speechRecognitionHostname","subscriptionKey","host","hostname","port","protocol","speechConfig","lang","createSpeechRecognitionPonyfillFromRecognizer"],"mappings":"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","sourcesContent":["/* eslint class-methods-use-this: \"off\" */\n/* eslint complexity: [\"error\", 70] */\n/* eslint no-await-in-loop: \"off\" */\n/* eslint no-empty-function: \"off\" */\n/* eslint no-magic-numbers: [\"error\", { \"ignore\": [0, 100, 150] }] */\n\nimport { defineEventAttribute, EventTarget } from 'event-target-shim-es5';\n\nimport cognitiveServiceEventResultToWebSpeechRecognitionResultList from './cognitiveServiceEventResultToWebSpeechRecognitionResultList';\nimport createPromiseQueue from '../../Util/createPromiseQueue';\nimport patchOptions from '../patchOptions';\nimport SpeechGrammarList from './SpeechGrammarList';\nimport SpeechSDK from '../SpeechSDK';\n\n// https://docs.microsoft.com/en-us/javascript/api/microsoft-cognitiveservices-speech-sdk/speechconfig?view=azure-node-latest#outputformat\n// {\n//   \"RecognitionStatus\": \"Success\",\n//   \"Offset\": 900000,\n//   \"Duration\": 49000000,\n//   \"NBest\": [\n//     {\n//       \"Confidence\": 0.738919,\n//       \"Lexical\": \"second\",\n//       \"ITN\": \"second\",\n//       \"MaskedITN\": \"second\",\n//       \"Display\": \"Second.\"\n//     }\n//   ]\n// }\n\n// {\n//   \"RecognitionStatus\": \"InitialSilenceTimeout\",\n//   \"Offset\": 50000000,\n//   \"Duration\": 0\n// }\n\nconst { AudioConfig, OutputFormat, ResultReason, SpeechConfig, SpeechRecognizer } = SpeechSDK;\n\nfunction serializeRecognitionResult({ duration, errorDetails, json, offset, properties, reason, resultId, text }) {\n  return {\n    duration,\n    errorDetails,\n    json: JSON.parse(json),\n    offset,\n    properties,\n    reason,\n    resultId,\n    text\n  };\n}\n\nfunction improviseAsync(fn, improviser) {\n  return (...args) => fn(...args).onSuccessContinueWith(result => improviser(result));\n}\n\nfunction averageAmplitude(arrayBuffer) {\n  const array = new Int16Array(arrayBuffer);\n\n  return (\n    [].reduce.call(array, (averageAmplitude, amplitude) => averageAmplitude + Math.abs(amplitude), 0) / array.length\n  );\n}\n\nfunction cognitiveServicesAsyncToPromise(fn) {\n  return (...args) => new Promise((resolve, reject) => fn(...args, resolve, reject));\n}\n\nclass SpeechRecognitionEvent {\n  constructor(type, { data, emma, interpretation, resultIndex, results } = {}) {\n    this.data = data;\n    this.emma = emma;\n    this.interpretation = interpretation;\n    this.resultIndex = resultIndex;\n    this.results = results;\n    this.type = type;\n  }\n}\n\nfunction prepareAudioConfig(audioConfig) {\n  const originalAttach = audioConfig.attach;\n  let firstChunk;\n  let muted;\n\n  // We modify \"attach\" function and detect when audible chunk is read.\n  // We will only modify \"attach\" function once.\n  audioConfig.attach = improviseAsync(originalAttach.bind(audioConfig), reader => ({\n    ...reader,\n    read: improviseAsync(reader.read.bind(reader), chunk => {\n      // The magic number 150 is measured by:\n      // 1. Set microphone volume to 0\n      // 2. Observe the amplitude (100-110) for the first few chunks\n      //    (There is a short static caught when turning on the microphone)\n      // 3. Set the number a bit higher than the observation\n\n      if (!firstChunk && averageAmplitude(chunk.buffer) > 150) {\n        audioConfig.events.onEvent({ name: 'FirstAudibleChunk' });\n        firstChunk = true;\n      }\n\n      if (muted) {\n        return { buffer: new ArrayBuffer(0), isEnd: true, timeReceived: Date.now() };\n      }\n\n      return chunk;\n    })\n  }));\n\n  return {\n    audioConfig,\n    pause: () => {\n      muted = true;\n    },\n    unprepare: () => {\n      audioConfig.attach = originalAttach;\n    }\n  };\n}\n\nexport function createSpeechRecognitionPonyfillFromRecognizer({\n  createRecognizer,\n  enableTelemetry,\n  looseEvents,\n  referenceGrammars,\n  textNormalization\n}) {\n  // If enableTelemetry is set to null or non-boolean, we will default to true.\n  SpeechRecognizer.enableTelemetry(enableTelemetry !== false);\n\n  class SpeechRecognition extends EventTarget {\n    constructor() {\n      super();\n\n      this._continuous = false;\n      this._interimResults = false;\n      this._lang =\n        typeof window !== 'undefined'\n          ? window.document.documentElement.getAttribute('lang') || window.navigator.language\n          : 'en-US';\n      this._grammars = new SpeechGrammarList();\n      this._maxAlternatives = 1;\n    }\n\n    emitCognitiveServices(type, event) {\n      this.dispatchEvent(\n        new SpeechRecognitionEvent('cognitiveservices', {\n          data: {\n            ...event,\n            type\n          }\n        })\n      );\n    }\n\n    get continuous() {\n      return this._continuous;\n    }\n\n    set continuous(value) {\n      this._continuous = value;\n    }\n\n    get grammars() {\n      return this._grammars;\n    }\n\n    set grammars(value) {\n      if (value instanceof SpeechGrammarList) {\n        this._grammars = value;\n      } else {\n        throw new Error(`The provided value is not of type 'SpeechGrammarList'`);\n      }\n    }\n\n    get interimResults() {\n      return this._interimResults;\n    }\n\n    set interimResults(value) {\n      this._interimResults = value;\n    }\n\n    get maxAlternatives() {\n      return this._maxAlternatives;\n    }\n\n    set maxAlternatives(value) {\n      this._maxAlternatives = value;\n    }\n\n    get lang() {\n      return this._lang;\n    }\n\n    set lang(value) {\n      this._lang = value;\n    }\n\n    start() {\n      this._startOnce().catch(err => {\n        this.dispatchEvent(new ErrorEvent('error', { error: err, message: err && (err.stack || err.message) }));\n      });\n    }\n\n    async _startOnce() {\n      // TODO: [P2] Should check if recognition is active, we should not start recognition twice\n      const recognizer = await createRecognizer(this.lang);\n\n      const { pause, unprepare } = prepareAudioConfig(recognizer.audioConfig);\n\n      try {\n        const queue = createPromiseQueue();\n        let soundStarted;\n        let speechStarted;\n        let stopping;\n\n        const { detach: detachAudioConfigEvent } = recognizer.audioConfig.events.attach(event => {\n          const { name } = event;\n\n          if (name === 'AudioSourceReadyEvent') {\n            queue.push({ audioSourceReady: {} });\n          } else if (name === 'AudioSourceOffEvent') {\n            queue.push({ audioSourceOff: {} });\n          } else if (name === 'FirstAudibleChunk') {\n            queue.push({ firstAudibleChunk: {} });\n          }\n        });\n\n        recognizer.canceled = (_, { errorDetails, offset, reason, sessionId }) => {\n          queue.push({\n            canceled: {\n              errorDetails,\n              offset,\n              reason,\n              sessionId\n            }\n          });\n        };\n\n        recognizer.recognized = (_, { offset, result, sessionId }) => {\n          queue.push({\n            recognized: {\n              offset,\n              result: serializeRecognitionResult(result),\n              sessionId\n            }\n          });\n        };\n\n        recognizer.recognizing = (_, { offset, result, sessionId }) => {\n          queue.push({\n            recognizing: {\n              offset,\n              result: serializeRecognitionResult(result),\n              sessionId\n            }\n          });\n        };\n\n        recognizer.sessionStarted = (_, { sessionId }) => {\n          queue.push({ sessionStarted: { sessionId } });\n        };\n\n        recognizer.sessionStopped = (_, { sessionId }) => {\n          // \"sessionStopped\" is never fired, probably because we are using startContinuousRecognitionAsync instead of recognizeOnceAsync.\n          queue.push({ sessionStopped: { sessionId } });\n        };\n\n        recognizer.speechStartDetected = (_, { offset, sessionId }) => {\n          queue.push({ speechStartDetected: { offset, sessionId } });\n        };\n\n        recognizer.speechEndDetected = (_, { sessionId }) => {\n          // \"speechEndDetected\" is never fired, probably because we are using startContinuousRecognitionAsync instead of recognizeOnceAsync.\n          // Update: \"speechEndDetected\" is fired for DLSpeech.listenOnceAsync()\n          queue.push({ speechEndDetected: { sessionId } });\n        };\n\n        const { phrases } = this.grammars;\n\n        // HACK: We are using the internal of SpeechRecognizer because they did not expose it\n        const { dynamicGrammar } = recognizer.privReco;\n\n        referenceGrammars && referenceGrammars.length && dynamicGrammar.addReferenceGrammar(referenceGrammars);\n        phrases && phrases.length && dynamicGrammar.addPhrase(phrases);\n\n        await cognitiveServicesAsyncToPromise(recognizer.startContinuousRecognitionAsync.bind(recognizer))();\n\n        if (recognizer.stopContinuousRecognitionAsync) {\n          this.abort = () => queue.push({ abort: {} });\n          this.stop = () => queue.push({ stop: {} });\n        } else {\n          this.abort = this.stop = undefined;\n        }\n\n        let audioStarted;\n        let finalEvent;\n        let finalizedResults = [];\n\n        for (let loop = 0; !stopping || audioStarted; loop++) {\n          const event = await queue.shift();\n          const {\n            abort,\n            audioSourceOff,\n            audioSourceReady,\n            canceled,\n            firstAudibleChunk,\n            recognized,\n            recognizing,\n            stop\n          } = event;\n\n          // We are emitting event \"cognitiveservices\" for debugging purpose.\n          Object.keys(event).forEach(name => this.emitCognitiveServices(name, event[name]));\n\n          const errorMessage = canceled && canceled.errorDetails;\n\n          if (/Permission\\sdenied/u.test(errorMessage || '')) {\n            // If microphone is not allowed, we should not emit \"start\" event.\n\n            finalEvent = {\n              error: 'not-allowed',\n              type: 'error'\n            };\n\n            break;\n          }\n\n          if (!loop) {\n            this.dispatchEvent(new SpeechRecognitionEvent('start'));\n          }\n\n          if (errorMessage) {\n            if (/1006/u.test(errorMessage)) {\n              if (!audioStarted) {\n                this.dispatchEvent(new SpeechRecognitionEvent('audiostart'));\n                this.dispatchEvent(new SpeechRecognitionEvent('audioend'));\n              }\n\n              finalEvent = {\n                error: 'network',\n                type: 'error'\n              };\n            } else {\n              finalEvent = {\n                error: 'unknown',\n                type: 'error'\n              };\n            }\n\n            break;\n          } else if (abort || stop) {\n            if (abort) {\n              finalEvent = {\n                error: 'aborted',\n                type: 'error'\n              };\n\n              // If we are aborting, we will ignore lingering recognizing/recognized events. But if we are stopping, we need them.\n              stopping = 'abort';\n            } else {\n              // When we pause, we will send { isEnd: true }, Speech Services will send us \"recognized\" event.\n              pause();\n              stopping = 'stop';\n            }\n\n            // Abort should not be dispatched without support of \"stopContinuousRecognitionAsync\".\n            // But for defensive purpose, we make sure \"stopContinuousRecognitionAsync\" is available before we can call.\n            if (abort && recognizer.stopContinuousRecognitionAsync) {\n              await cognitiveServicesAsyncToPromise(recognizer.stopContinuousRecognitionAsync.bind(recognizer))();\n            }\n          } else if (audioSourceReady) {\n            this.dispatchEvent(new SpeechRecognitionEvent('audiostart'));\n\n            audioStarted = true;\n          } else if (firstAudibleChunk) {\n            this.dispatchEvent(new SpeechRecognitionEvent('soundstart'));\n\n            soundStarted = true;\n          } else if (audioSourceOff) {\n            // Looks like we don't need this line and all the tests are still working.\n            // Guessing probably stopping is already truthy.\n            // stopping = true;\n\n            speechStarted && this.dispatchEvent(new SpeechRecognitionEvent('speechend'));\n            soundStarted && this.dispatchEvent(new SpeechRecognitionEvent('soundend'));\n            audioStarted && this.dispatchEvent(new SpeechRecognitionEvent('audioend'));\n\n            audioStarted = soundStarted = speechStarted = false;\n\n            break;\n          } else if (stopping !== 'abort') {\n            if (recognized && recognized.result && recognized.result.reason === ResultReason.NoMatch) {\n              finalEvent = {\n                error: 'no-speech',\n                type: 'error'\n              };\n            } else if (recognized || recognizing) {\n              if (!audioStarted) {\n                // Unconfirmed prevention of quirks\n                this.dispatchEvent(new SpeechRecognitionEvent('audiostart'));\n\n                audioStarted = true;\n              }\n\n              if (!soundStarted) {\n                this.dispatchEvent(new SpeechRecognitionEvent('soundstart'));\n\n                soundStarted = true;\n              }\n\n              if (!speechStarted) {\n                this.dispatchEvent(new SpeechRecognitionEvent('speechstart'));\n\n                speechStarted = true;\n              }\n\n              if (recognized) {\n                const result = cognitiveServiceEventResultToWebSpeechRecognitionResultList(recognized.result, {\n                  maxAlternatives: this.maxAlternatives,\n                  textNormalization\n                });\n\n                const recognizable = !!result[0].transcript;\n\n                if (recognizable) {\n                  finalizedResults = [...finalizedResults, result];\n\n                  this.continuous &&\n                    this.dispatchEvent(\n                      new SpeechRecognitionEvent('result', {\n                        results: finalizedResults\n                      })\n                    );\n                }\n\n                // If it is continuous, we just sent the finalized results. So we don't need to send it again after \"audioend\" event.\n                if (this.continuous && recognizable) {\n                  finalEvent = null;\n                } else {\n                  finalEvent = {\n                    results: finalizedResults,\n                    type: 'result'\n                  };\n                }\n\n                if (!this.continuous && recognizer.stopContinuousRecognitionAsync) {\n                  await cognitiveServicesAsyncToPromise(recognizer.stopContinuousRecognitionAsync.bind(recognizer))();\n                }\n\n                // If event order can be loosened, we can send the recognized event as soon as we receive it.\n                // 1. If it is not recognizable (no-speech), we should send an \"error\" event just before \"end\" event. We will not loosen \"error\" events.\n                if (looseEvents && finalEvent && recognizable) {\n                  this.dispatchEvent(new SpeechRecognitionEvent(finalEvent.type, finalEvent));\n                  finalEvent = null;\n                }\n              } else if (recognizing) {\n                this.interimResults &&\n                  this.dispatchEvent(\n                    new SpeechRecognitionEvent('result', {\n                      results: [\n                        ...finalizedResults,\n                        cognitiveServiceEventResultToWebSpeechRecognitionResultList(recognizing.result, {\n                          maxAlternatives: this.maxAlternatives,\n                          textNormalization\n                        })\n                      ]\n                    })\n                  );\n              }\n            }\n          }\n        }\n\n        if (speechStarted) {\n          this.dispatchEvent(new SpeechRecognitionEvent('speechend'));\n        }\n\n        if (soundStarted) {\n          this.dispatchEvent(new SpeechRecognitionEvent('soundend'));\n        }\n\n        if (audioStarted) {\n          this.dispatchEvent(new SpeechRecognitionEvent('audioend'));\n        }\n\n        if (finalEvent) {\n          if (finalEvent.type === 'result' && !finalEvent.results.length) {\n            finalEvent = {\n              error: 'no-speech',\n              type: 'error'\n            };\n          }\n\n          if (finalEvent.type === 'error') {\n            this.dispatchEvent(new ErrorEvent('error', finalEvent));\n          } else {\n            this.dispatchEvent(new SpeechRecognitionEvent(finalEvent.type, finalEvent));\n          }\n        }\n\n        // Even though there is no \"start\" event emitted, we will still emit \"end\" event\n        // This is mainly for \"microphone blocked\" story.\n        this.dispatchEvent(new SpeechRecognitionEvent('end'));\n\n        detachAudioConfigEvent();\n      } catch (err) {\n        // Logging out the erorr because Speech SDK would fail silently.\n        console.error(err);\n\n        throw err;\n      } finally {\n        unprepare();\n        recognizer.dispose();\n      }\n    }\n  }\n\n  defineEventAttribute(SpeechRecognition.prototype, 'audioend');\n  defineEventAttribute(SpeechRecognition.prototype, 'audiostart');\n  defineEventAttribute(SpeechRecognition.prototype, 'cognitiveservices');\n  defineEventAttribute(SpeechRecognition.prototype, 'end');\n  defineEventAttribute(SpeechRecognition.prototype, 'error');\n  defineEventAttribute(SpeechRecognition.prototype, 'nomatch');\n  defineEventAttribute(SpeechRecognition.prototype, 'result');\n  defineEventAttribute(SpeechRecognition.prototype, 'soundend');\n  defineEventAttribute(SpeechRecognition.prototype, 'soundstart');\n  defineEventAttribute(SpeechRecognition.prototype, 'speechend');\n  defineEventAttribute(SpeechRecognition.prototype, 'speechstart');\n  defineEventAttribute(SpeechRecognition.prototype, 'start');\n\n  return {\n    SpeechGrammarList,\n    SpeechRecognition,\n    SpeechRecognitionEvent\n  };\n}\n\nexport default options => {\n  const {\n    audioConfig = AudioConfig.fromDefaultMicrophoneInput(),\n\n    // We set telemetry to true to honor the default telemetry settings of Speech SDK\n    // https://github.com/Microsoft/cognitive-services-speech-sdk-js#data--telemetry\n    enableTelemetry = true,\n\n    fetchCredentials,\n    looseEvents,\n    referenceGrammars,\n    speechRecognitionEndpointId,\n    textNormalization = 'display'\n  } = patchOptions(options);\n\n  if (!audioConfig && (!window.navigator.mediaDevices || !window.navigator.mediaDevices.getUserMedia)) {\n    console.warn(\n      'web-speech-cognitive-services: This browser does not support WebRTC and it will not work with Cognitive Services Speech Services.'\n    );\n\n    return {};\n  }\n\n  const createRecognizer = async lang => {\n    const { authorizationToken, region, speechRecognitionHostname, subscriptionKey } = await fetchCredentials();\n    let speechConfig;\n\n    if (speechRecognitionHostname) {\n      const host = { hostname: speechRecognitionHostname, port: 443, protocol: 'wss:' };\n\n      if (authorizationToken) {\n        speechConfig = SpeechConfig.fromHost(host);\n        speechConfig.authorizationToken = authorizationToken;\n      } else {\n        speechConfig = SpeechConfig.fromHost(host, subscriptionKey);\n      }\n    } else {\n      speechConfig = authorizationToken\n        ? SpeechConfig.fromAuthorizationToken(authorizationToken, region)\n        : SpeechConfig.fromSubscription(subscriptionKey, region);\n    }\n\n    if (speechRecognitionEndpointId) {\n      speechConfig.endpointId = speechRecognitionEndpointId;\n    }\n\n    speechConfig.outputFormat = OutputFormat.Detailed;\n    speechConfig.speechRecognitionLanguage = lang || 'en-US';\n\n    return new SpeechRecognizer(speechConfig, audioConfig);\n  };\n\n  return createSpeechRecognitionPonyfillFromRecognizer({\n    audioConfig,\n    createRecognizer,\n    enableTelemetry,\n    looseEvents,\n    referenceGrammars,\n    textNormalization\n  });\n};\n"]},"metadata":{},"sourceType":"script"}