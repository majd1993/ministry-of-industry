{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getEarliestUpdateNotBefore = getEarliestUpdateNotBefore;\nexports.default = void 0;\n\nvar _react = require(\"react\");\n\nvar _simpleUpdateIn = _interopRequireDefault(require(\"simple-update-in\"));\n\nvar _findMin = _interopRequireDefault(require(\"../utils/findMin\"));\n\nvar _useForceRender = _interopRequireDefault(require(\"./internal/useForceRender\"));\n\nvar _useNotifications3 = _interopRequireDefault(require(\"./useNotifications\"));\n\nvar _useStyleOptions3 = _interopRequireDefault(require(\"./useStyleOptions\"));\n\nvar _useTimer = _interopRequireDefault(require(\"./internal/useTimer\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e2) {\n          throw _e2;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e3) {\n      didErr = true;\n      err = _e3;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction getEarliestUpdateNotBefore(notificationMap) {\n  return (0, _findMin.default)(Object.values(notificationMap).filter(function (_ref) {\n    var outOfDate = _ref.outOfDate;\n    return outOfDate;\n  }).map(function (_ref2) {\n    var updateNotBefore = _ref2.updateNotBefore;\n    return updateNotBefore;\n  }));\n}\n\nfunction useDebouncedNotifications() {\n  var now = Date.now();\n\n  var _useStyleOptions = (0, _useStyleOptions3.default)(),\n      _useStyleOptions2 = _slicedToArray(_useStyleOptions, 1),\n      notificationDebounceTimeout = _useStyleOptions2[0].notificationDebounceTimeout;\n\n  var _useNotifications = (0, _useNotifications3.default)(),\n      _useNotifications2 = _slicedToArray(_useNotifications, 1),\n      notifications = _useNotifications2[0];\n\n  var debouncedNotificationsRef = (0, _react.useRef)({});\n  var forceRender = (0, _useForceRender.default)(); // Delete notifications or mark them to be deleted if debouncing.\n\n  var _iterator = _createForOfIteratorHelper(Object.keys(debouncedNotificationsRef.current).filter(function (id) {\n    return !(id in notifications);\n  })),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var id = _step.value;\n      debouncedNotificationsRef.current = (0, _simpleUpdateIn.default)(debouncedNotificationsRef.current, [id], function (debouncedNotification) {\n        if (now < debouncedNotification.updateNotBefore) {\n          // The update need to be postponed.\n          return _objectSpread(_objectSpread({}, debouncedNotification), {}, {\n            outOfDate: true\n          });\n        } // Otherwise, return undefined will remove it.\n\n      });\n    } // For any changes, update notifications or mark them to be updated if debouncing.\n\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var _loop = function _loop() {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),\n        _Object$entries$_i$ = _Object$entries$_i[1],\n        alt = _Object$entries$_i$.alt,\n        data = _Object$entries$_i$.data,\n        id = _Object$entries$_i$.id,\n        level = _Object$entries$_i$.level,\n        message = _Object$entries$_i$.message,\n        timestamp = _Object$entries$_i$.timestamp;\n\n    debouncedNotificationsRef.current = (0, _simpleUpdateIn.default)(debouncedNotificationsRef.current, [id], function (debouncedNotification) {\n      if (debouncedNotification && alt === debouncedNotification.alt && Object.is(data, debouncedNotification.data) && level === debouncedNotification.level && message === debouncedNotification.message && timestamp === debouncedNotification.timestamp) {\n        // If nothing changed, return as-is.\n        return debouncedNotification;\n      }\n\n      if (debouncedNotification && now < debouncedNotification.updateNotBefore) {\n        // The update need to be postponed.\n        return _objectSpread(_objectSpread({}, debouncedNotification), {}, {\n          outOfDate: true\n        });\n      } // Update the notification.\n\n\n      return _objectSpread(_objectSpread({}, debouncedNotification), {}, {\n        alt: alt,\n        data: data,\n        id: id,\n        level: level,\n        message: message,\n        outOfDate: false,\n        timestamp: timestamp,\n        updateNotBefore: now + notificationDebounceTimeout\n      });\n    });\n  };\n\n  for (var _i2 = 0, _Object$entries = Object.entries(notifications); _i2 < _Object$entries.length; _i2++) {\n    _loop();\n  }\n\n  (0, _useTimer.default)(getEarliestUpdateNotBefore(debouncedNotificationsRef.current), forceRender);\n  return [debouncedNotificationsRef.current];\n}\n\nvar _default = useDebouncedNotifications;\nexports.default = _default;","map":{"version":3,"sources":["../../src/hooks/useDebouncedNotifications.js"],"names":["outOfDate","updateNotBefore","now","Date","notificationDebounceTimeout","notifications","debouncedNotificationsRef","forceRender","id","debouncedNotification","alt","data","level","message","timestamp","Object","getEarliestUpdateNotBefore","useDebouncedNotifications"],"mappings":"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","sourcesContent":["import { useRef } from 'react';\nimport updateIn from 'simple-update-in';\n\nimport findMin from '../utils/findMin';\nimport useForceRender from './internal/useForceRender';\nimport useNotifications from './useNotifications';\nimport useStyleOptions from './useStyleOptions';\nimport useTimer from './internal/useTimer';\n\nfunction getEarliestUpdateNotBefore(notificationMap) {\n  return findMin(\n    Object.values(notificationMap)\n      .filter(({ outOfDate }) => outOfDate)\n      .map(({ updateNotBefore }) => updateNotBefore)\n  );\n}\n\nfunction useDebouncedNotifications() {\n  const now = Date.now();\n\n  const [{ notificationDebounceTimeout }] = useStyleOptions();\n  const [notifications] = useNotifications();\n  const debouncedNotificationsRef = useRef({});\n  const forceRender = useForceRender();\n\n  // Delete notifications or mark them to be deleted if debouncing.\n  for (const id of Object.keys(debouncedNotificationsRef.current).filter(id => !(id in notifications))) {\n    debouncedNotificationsRef.current = updateIn(debouncedNotificationsRef.current, [id], debouncedNotification => {\n      if (now < debouncedNotification.updateNotBefore) {\n        // The update need to be postponed.\n        return { ...debouncedNotification, outOfDate: true };\n      }\n\n      // Otherwise, return undefined will remove it.\n    });\n  }\n\n  // For any changes, update notifications or mark them to be updated if debouncing.\n  for (const [, { alt, data, id, level, message, timestamp }] of Object.entries(notifications)) {\n    debouncedNotificationsRef.current = updateIn(debouncedNotificationsRef.current, [id], debouncedNotification => {\n      if (\n        debouncedNotification &&\n        alt === debouncedNotification.alt &&\n        Object.is(data, debouncedNotification.data) &&\n        level === debouncedNotification.level &&\n        message === debouncedNotification.message &&\n        timestamp === debouncedNotification.timestamp\n      ) {\n        // If nothing changed, return as-is.\n        return debouncedNotification;\n      }\n\n      if (debouncedNotification && now < debouncedNotification.updateNotBefore) {\n        // The update need to be postponed.\n        return {\n          ...debouncedNotification,\n          outOfDate: true\n        };\n      }\n\n      // Update the notification.\n      return {\n        ...debouncedNotification,\n        alt,\n        data,\n        id,\n        level,\n        message,\n        outOfDate: false,\n        timestamp,\n        updateNotBefore: now + notificationDebounceTimeout\n      };\n    });\n  }\n\n  useTimer(getEarliestUpdateNotBefore(debouncedNotificationsRef.current), forceRender);\n\n  return [debouncedNotificationsRef.current];\n}\n\nexport default useDebouncedNotifications;\n\nexport { getEarliestUpdateNotBefore };\n"],"sourceRoot":"component:///"},"metadata":{},"sourceType":"script"}