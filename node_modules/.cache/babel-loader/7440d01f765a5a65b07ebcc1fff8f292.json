{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SpeechSynthesisVoice = exports.SpeechSynthesisUtterance = exports.SpeechSynthesisEvent = exports.speechSynthesis = void 0;\n\nvar _eventTargetShimEs = _interopRequireWildcard(require(\"event-target-shim-es5\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar SpeechSynthesisEvent = /*#__PURE__*/function () {\n  function SpeechSynthesisEvent(type, utterance) {\n    _classCallCheck(this, SpeechSynthesisEvent);\n\n    this._type = type;\n    this._utterance = utterance;\n  }\n\n  _createClass(SpeechSynthesisEvent, [{\n    key: \"charIndex\",\n    get: function get() {\n      return 0;\n    }\n  }, {\n    key: \"elapsedTime\",\n    get: function get() {\n      return 0;\n    }\n  }, {\n    key: \"name\",\n    get: function get() {}\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._type;\n    }\n  }, {\n    key: \"utterance\",\n    get: function get() {\n      return this._utterance;\n    }\n  }]);\n\n  return SpeechSynthesisEvent;\n}();\n\nexports.SpeechSynthesisEvent = SpeechSynthesisEvent;\n\nvar SpeechSynthesisUtterance = /*#__PURE__*/function (_EventTarget) {\n  _inherits(SpeechSynthesisUtterance, _EventTarget);\n\n  var _super = _createSuper(SpeechSynthesisUtterance);\n\n  function SpeechSynthesisUtterance(text) {\n    var _this;\n\n    _classCallCheck(this, SpeechSynthesisUtterance);\n\n    _this = _super.call(this);\n    _this._lang = 'en-US';\n    _this._pitch = 1;\n    _this._rate = 1;\n    _this._text = text;\n    _this._voice = null;\n    _this._volume = 1;\n    return _this;\n  }\n\n  _createClass(SpeechSynthesisUtterance, [{\n    key: \"lang\",\n    get: function get() {\n      return this._lang;\n    },\n    set: function set(value) {\n      this._lang = value;\n    }\n  }, {\n    key: \"pitch\",\n    get: function get() {\n      return this._pitch;\n    },\n    set: function set(value) {\n      this._pitch = value;\n    }\n  }, {\n    key: \"rate\",\n    get: function get() {\n      return this._rate;\n    },\n    set: function set(value) {\n      this._rate = value;\n    }\n  }, {\n    key: \"text\",\n    get: function get() {\n      return this._text;\n    },\n    set: function set(value) {\n      this._text = value;\n    }\n  }, {\n    key: \"voice\",\n    get: function get() {\n      return this._voice;\n    },\n    set: function set(value) {\n      this._voice = value;\n    }\n  }, {\n    key: \"volume\",\n    get: function get() {\n      return this._volume;\n    },\n    set: function set(value) {\n      this._volume = value;\n    }\n  }]);\n\n  return SpeechSynthesisUtterance;\n}(_eventTargetShimEs.default);\n\nexports.SpeechSynthesisUtterance = SpeechSynthesisUtterance;\n(0, _eventTargetShimEs.defineEventAttribute)(SpeechSynthesisUtterance.prototype, 'boundary');\n(0, _eventTargetShimEs.defineEventAttribute)(SpeechSynthesisUtterance.prototype, 'end');\n(0, _eventTargetShimEs.defineEventAttribute)(SpeechSynthesisUtterance.prototype, 'error');\n(0, _eventTargetShimEs.defineEventAttribute)(SpeechSynthesisUtterance.prototype, 'mark');\n(0, _eventTargetShimEs.defineEventAttribute)(SpeechSynthesisUtterance.prototype, 'pause');\n(0, _eventTargetShimEs.defineEventAttribute)(SpeechSynthesisUtterance.prototype, 'resume');\n(0, _eventTargetShimEs.defineEventAttribute)(SpeechSynthesisUtterance.prototype, 'start');\n\nvar SpeechSynthesisVoice = /*#__PURE__*/function () {\n  function SpeechSynthesisVoice() {\n    _classCallCheck(this, SpeechSynthesisVoice);\n  }\n\n  _createClass(SpeechSynthesisVoice, [{\n    key: \"default\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"lang\",\n    get: function get() {\n      return 'en-US';\n    }\n  }, {\n    key: \"localService\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return 'English (US)';\n    }\n  }, {\n    key: \"voiceURI\",\n    get: function get() {\n      return 'English (US)';\n    }\n  }]);\n\n  return SpeechSynthesisVoice;\n}();\n\nexports.SpeechSynthesisVoice = SpeechSynthesisVoice;\n\nvar SpeechSynthesis = /*#__PURE__*/function (_EventTarget2) {\n  _inherits(SpeechSynthesis, _EventTarget2);\n\n  var _super2 = _createSuper(SpeechSynthesis);\n\n  function SpeechSynthesis() {\n    _classCallCheck(this, SpeechSynthesis);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(SpeechSynthesis, [{\n    key: \"cancel\",\n    value: function cancel() {}\n  }, {\n    key: \"getVoices\",\n    value: function getVoices() {\n      return [new SpeechSynthesisVoice()];\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      throw new Error('pause is not implemented.');\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      throw new Error('resume is not implemented.');\n    }\n  }, {\n    key: \"speak\",\n    value: function speak(utterance) {\n      utterance.dispatchEvent(new SpeechSynthesisEvent('start', utterance));\n      utterance.dispatchEvent(new SpeechSynthesisEvent('end', utterance));\n    }\n  }, {\n    key: \"paused\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"pending\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"speaking\",\n    get: function get() {\n      return false;\n    }\n  }]);\n\n  return SpeechSynthesis;\n}(_eventTargetShimEs.default);\n\n(0, _eventTargetShimEs.defineEventAttribute)(SpeechSynthesis.prototype, 'voiceschanged');\nvar speechSynthesis = new SpeechSynthesis();\nexports.speechSynthesis = speechSynthesis;","map":{"version":3,"sources":["../../../src/hooks/internal/BypassSpeechSynthesisPonyfill.js"],"names":["SpeechSynthesisEvent","SpeechSynthesisUtterance","EventTarget","value","SpeechSynthesisVoice","SpeechSynthesis","utterance","speechSynthesis"],"mappings":"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","sourcesContent":["// Since this is a bypass, we will relax some ESLint rules.\n// All classes/properties defined here are in W3C Web Speech API.\n\n/* eslint class-methods-use-this: \"off\" */\n/* eslint getter-return: \"off\" */\n/* eslint max-classes-per-file: [\"error\", 4] */\n/* eslint no-empty-function: \"off\" */\n\nimport EventTarget, { defineEventAttribute } from 'event-target-shim-es5';\n\nclass SpeechSynthesisEvent {\n  constructor(type, utterance) {\n    this._type = type;\n    this._utterance = utterance;\n  }\n\n  get charIndex() {\n    return 0;\n  }\n\n  get elapsedTime() {\n    return 0;\n  }\n\n  get name() {}\n\n  get type() {\n    return this._type;\n  }\n\n  get utterance() {\n    return this._utterance;\n  }\n}\n\nclass SpeechSynthesisUtterance extends EventTarget {\n  constructor(text) {\n    super();\n\n    this._lang = 'en-US';\n    this._pitch = 1;\n    this._rate = 1;\n    this._text = text;\n    this._voice = null;\n    this._volume = 1;\n  }\n\n  get lang() {\n    return this._lang;\n  }\n\n  set lang(value) {\n    this._lang = value;\n  }\n\n  get pitch() {\n    return this._pitch;\n  }\n\n  set pitch(value) {\n    this._pitch = value;\n  }\n\n  get rate() {\n    return this._rate;\n  }\n\n  set rate(value) {\n    this._rate = value;\n  }\n\n  get text() {\n    return this._text;\n  }\n\n  set text(value) {\n    this._text = value;\n  }\n\n  get voice() {\n    return this._voice;\n  }\n\n  set voice(value) {\n    this._voice = value;\n  }\n\n  get volume() {\n    return this._volume;\n  }\n\n  set volume(value) {\n    this._volume = value;\n  }\n}\n\ndefineEventAttribute(SpeechSynthesisUtterance.prototype, 'boundary');\ndefineEventAttribute(SpeechSynthesisUtterance.prototype, 'end');\ndefineEventAttribute(SpeechSynthesisUtterance.prototype, 'error');\ndefineEventAttribute(SpeechSynthesisUtterance.prototype, 'mark');\ndefineEventAttribute(SpeechSynthesisUtterance.prototype, 'pause');\ndefineEventAttribute(SpeechSynthesisUtterance.prototype, 'resume');\ndefineEventAttribute(SpeechSynthesisUtterance.prototype, 'start');\n\nclass SpeechSynthesisVoice {\n  get default() {\n    return true;\n  }\n\n  get lang() {\n    return 'en-US';\n  }\n\n  get localService() {\n    return true;\n  }\n\n  get name() {\n    return 'English (US)';\n  }\n\n  get voiceURI() {\n    return 'English (US)';\n  }\n}\n\nclass SpeechSynthesis extends EventTarget {\n  get paused() {\n    return false;\n  }\n\n  get pending() {\n    return false;\n  }\n\n  get speaking() {\n    return false;\n  }\n\n  cancel() {}\n\n  getVoices() {\n    return [new SpeechSynthesisVoice()];\n  }\n\n  pause() {\n    throw new Error('pause is not implemented.');\n  }\n\n  resume() {\n    throw new Error('resume is not implemented.');\n  }\n\n  speak(utterance) {\n    utterance.dispatchEvent(new SpeechSynthesisEvent('start', utterance));\n    utterance.dispatchEvent(new SpeechSynthesisEvent('end', utterance));\n  }\n}\n\ndefineEventAttribute(SpeechSynthesis.prototype, 'voiceschanged');\n\nconst speechSynthesis = new SpeechSynthesis();\n\nexport { speechSynthesis, SpeechSynthesisEvent, SpeechSynthesisUtterance, SpeechSynthesisVoice };\n"],"sourceRoot":"component:///"},"metadata":{},"sourceType":"script"}