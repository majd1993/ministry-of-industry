{"ast":null,"code":"import _classCallCheck from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { createNoDashGuid, Deferred, Events, PromiseState } from \"../common/Exports\";\nimport { PullAudioOutputStreamImpl } from \"../sdk/Audio/AudioOutputStream\";\nimport { SynthesisAdapterBase } from \"./SynthesisAdapterBase\";\nimport { ConnectingToSynthesisServiceEvent, SynthesisStartedEvent, SynthesisTriggeredEvent } from \"./SynthesisEvents\";\nexport var SynthesisTurn = /*#__PURE__*/function () {\n  function SynthesisTurn() {\n    var _this = this;\n\n    _classCallCheck(this, SynthesisTurn);\n\n    this.privIsDisposed = false;\n    this.privIsSynthesizing = false;\n    this.privIsSynthesisEnded = false;\n    this.privBytesReceived = 0;\n    this.privTextOffset = 0;\n    this.privNextSearchTextIndex = 0;\n\n    this.onPreConnectionStart = function (authFetchEventId, connectionId) {\n      _this.privAuthFetchEventId = authFetchEventId;\n\n      _this.onEvent(new ConnectingToSynthesisServiceEvent(_this.privRequestId, _this.privAuthFetchEventId));\n    };\n\n    this.onAuthCompleted = function (isError, error) {\n      if (isError) {\n        _this.onComplete();\n      }\n    };\n\n    this.onConnectionEstablishCompleted = function (statusCode, reason) {\n      if (statusCode === 200) {\n        _this.onEvent(new SynthesisStartedEvent(_this.requestId, _this.privAuthFetchEventId));\n\n        _this.privBytesReceived = 0;\n        return;\n      } else if (statusCode === 403) {\n        _this.onComplete();\n      }\n    };\n\n    this.onServiceResponseMessage = function (responseJson) {\n      var response = JSON.parse(responseJson);\n      _this.streamId = response.audio.streamId;\n    };\n\n    this.onServiceTurnEndResponse = function () {\n      _this.privTurnDeferral.resolve(true);\n\n      _this.onComplete();\n    };\n\n    this.onServiceTurnStartResponse = function () {\n      if (_this.privTurnDeferral.state() === PromiseState.None) {\n        // What? How are we starting a turn with another not done?\n        _this.privTurnDeferral.reject(\"Another turn started before current completed.\");\n      }\n\n      _this.privTurnDeferral = new Deferred();\n    };\n\n    this.dispose = function (error) {\n      if (!_this.privIsDisposed) {\n        // we should have completed by now. If we did not its an unknown error.\n        _this.privIsDisposed = true;\n      }\n    };\n\n    this.onEvent = function (event) {\n      Events.instance.onEvent(event);\n    };\n\n    this.onComplete = function () {\n      if (_this.privIsSynthesizing) {\n        _this.privIsSynthesizing = false;\n        _this.privIsSynthesisEnded = true;\n\n        _this.privAudioOutputStream.close();\n\n        if (_this.privTurnAudioDestination !== undefined) {\n          _this.privTurnAudioDestination.close();\n\n          _this.privTurnAudioDestination = undefined;\n        }\n      }\n    };\n\n    this.privRequestId = createNoDashGuid();\n    this.privTurnDeferral = new Deferred(); // We're not in a turn, so resolve.\n\n    this.privTurnDeferral.resolve(true);\n  }\n\n  _createClass(SynthesisTurn, [{\n    key: \"requestId\",\n    get: function get() {\n      return this.privRequestId;\n    }\n  }, {\n    key: \"streamId\",\n    get: function get() {\n      return this.privStreamId;\n    },\n    set: function set(value) {\n      this.privStreamId = value;\n    }\n  }, {\n    key: \"audioOutputFormat\",\n    get: function get() {\n      return this.privAudioOutputFormat;\n    },\n    set: function set(format) {\n      this.privAudioOutputFormat = format;\n    }\n  }, {\n    key: \"turnCompletionPromise\",\n    get: function get() {\n      return this.privTurnDeferral.promise();\n    }\n  }, {\n    key: \"isSynthesisEnded\",\n    get: function get() {\n      return this.privIsSynthesisEnded;\n    }\n  }, {\n    key: \"isSynthesizing\",\n    get: function get() {\n      return this.privIsSynthesizing;\n    }\n  }, {\n    key: \"currentTextOffset\",\n    get: function get() {\n      return this.privTextOffset;\n    } // The number of bytes received for current turn\n\n  }, {\n    key: \"bytesReceived\",\n    get: function get() {\n      return this.privBytesReceived;\n    }\n  }, {\n    key: \"allReceivedAudio\",\n    get: function get() {\n      if (!!this.privReceivedAudio) {\n        return this.privReceivedAudio;\n      }\n\n      if (!this.privIsSynthesisEnded) {\n        return null;\n      }\n\n      this.readAllAudioFromStream();\n      return this.allReceivedAudio;\n    }\n  }, {\n    key: \"allReceivedAudioWithHeader\",\n    get: function get() {\n      if (!!this.privReceivedAudioWithHeader) {\n        return this.privReceivedAudioWithHeader;\n      }\n\n      if (!this.privIsSynthesisEnded) {\n        return null;\n      }\n\n      if (this.audioOutputFormat.hasHeader) {\n        this.privReceivedAudioWithHeader = SynthesisAdapterBase.addHeader(this.allReceivedAudio, this.audioOutputFormat);\n        return this.allReceivedAudioWithHeader;\n      } else {\n        return this.allReceivedAudio;\n      }\n    }\n  }, {\n    key: \"startNewSynthesis\",\n    value: function startNewSynthesis(requestId, rawText, isSSML, audioDestination) {\n      this.privIsSynthesisEnded = false;\n      this.privIsSynthesizing = true;\n      this.privRequestId = requestId;\n      this.privRawText = rawText;\n      this.privIsSSML = isSSML;\n      this.privAudioOutputStream = new PullAudioOutputStreamImpl();\n      this.privAudioOutputStream.format = this.privAudioOutputFormat;\n      this.privReceivedAudio = null;\n      this.privReceivedAudioWithHeader = null;\n      this.privBytesReceived = 0;\n      this.privTextOffset = 0;\n      this.privNextSearchTextIndex = 0;\n\n      if (audioDestination !== undefined) {\n        this.privTurnAudioDestination = audioDestination;\n        this.privTurnAudioDestination.format = this.privAudioOutputFormat;\n      }\n\n      this.onEvent(new SynthesisTriggeredEvent(this.requestId, undefined, audioDestination === undefined ? undefined : audioDestination.id()));\n    }\n  }, {\n    key: \"onAudioChunkReceived\",\n    value: function onAudioChunkReceived(data) {\n      if (this.isSynthesizing) {\n        this.privAudioOutputStream.write(data);\n        this.privBytesReceived += data.byteLength;\n\n        if (this.privTurnAudioDestination !== undefined) {\n          this.privTurnAudioDestination.write(data);\n        }\n      }\n    }\n  }, {\n    key: \"onWordBoundaryEvent\",\n    value: function onWordBoundaryEvent(text) {\n      this.updateTextOffset(text);\n    }\n  }, {\n    key: \"onStopSynthesizing\",\n    value: function onStopSynthesizing() {\n      this.onComplete();\n    }\n  }, {\n    key: \"updateTextOffset\",\n    value: function updateTextOffset(text) {\n      if (this.privTextOffset >= 0) {\n        this.privTextOffset = this.privRawText.indexOf(text, this.privNextSearchTextIndex);\n\n        if (this.privTextOffset >= 0) {\n          this.privNextSearchTextIndex = this.privTextOffset + text.length;\n        }\n\n        if (this.privIsSSML) {\n          if (this.privRawText.indexOf(\"<\", this.privTextOffset + 1) > this.privRawText.indexOf(\">\", this.privTextOffset + 1)) {\n            this.updateTextOffset(text);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"readAllAudioFromStream\",\n    value: function readAllAudioFromStream() {\n      if (this.privIsSynthesisEnded) {\n        this.privReceivedAudio = new ArrayBuffer(this.bytesReceived);\n\n        try {\n          this.privAudioOutputStream.read(this.privReceivedAudio);\n        } catch (e) {\n          this.privReceivedAudio = new ArrayBuffer(0);\n        }\n      }\n    }\n  }]);\n\n  return SynthesisTurn;\n}();","map":{"version":3,"sources":["src/common.speech/SynthesisTurn.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    createNoDashGuid,\r\n    Deferred,\r\n    Events, IAudioDestination,\r\n    Promise,\r\n    PromiseState\r\n} from \"../common/Exports\";\r\nimport { AudioOutputFormatImpl } from \"../sdk/Audio/AudioOutputFormat\";\r\nimport { PullAudioOutputStreamImpl } from \"../sdk/Audio/AudioOutputStream\";\r\nimport {SynthesisAdapterBase} from \"./SynthesisAdapterBase\";\r\nimport {\r\n    ConnectingToSynthesisServiceEvent,\r\n    SpeechSynthesisEvent,\r\n    SynthesisStartedEvent,\r\n    SynthesisTriggeredEvent,\r\n} from \"./SynthesisEvents\";\r\n\r\nexport interface ISynthesisResponseContext {\r\n    serviceTag: string;\r\n}\r\n\r\nexport interface ISynthesisResponseAudio {\r\n    type: string;\r\n    streamId: string;\r\n}\r\n\r\nexport interface ISynthesisResponse {\r\n    context: ISynthesisResponseContext;\r\n    audio: ISynthesisResponseAudio;\r\n}\r\n\r\nexport class SynthesisTurn {\r\n\r\n    public get requestId(): string {\r\n        return this.privRequestId;\r\n    }\r\n\r\n    public get streamId(): string {\r\n        return this.privStreamId;\r\n    }\r\n\r\n    public set streamId(value: string) {\r\n        this.privStreamId = value;\r\n    }\r\n\r\n    public get audioOutputFormat(): AudioOutputFormatImpl {\r\n        return this.privAudioOutputFormat;\r\n    }\r\n\r\n    public set audioOutputFormat(format: AudioOutputFormatImpl) {\r\n        this.privAudioOutputFormat = format;\r\n    }\r\n\r\n    public get turnCompletionPromise(): Promise<boolean> {\r\n        return this.privTurnDeferral.promise();\r\n    }\r\n\r\n    public get isSynthesisEnded(): boolean {\r\n        return this.privIsSynthesisEnded;\r\n    }\r\n\r\n    public get isSynthesizing(): boolean {\r\n        return this.privIsSynthesizing;\r\n    }\r\n\r\n    public get currentTextOffset(): number {\r\n        return this.privTextOffset;\r\n    }\r\n\r\n    // The number of bytes received for current turn\r\n    public get bytesReceived(): number {\r\n        return this.privBytesReceived;\r\n    }\r\n\r\n    public get allReceivedAudio(): ArrayBuffer {\r\n        if (!!this.privReceivedAudio) {\r\n            return this.privReceivedAudio;\r\n        }\r\n        if (!this.privIsSynthesisEnded) {\r\n            return null;\r\n        }\r\n        this.readAllAudioFromStream();\r\n        return this.allReceivedAudio;\r\n    }\r\n\r\n    public get allReceivedAudioWithHeader(): ArrayBuffer {\r\n        if (!!this.privReceivedAudioWithHeader) {\r\n            return this.privReceivedAudioWithHeader;\r\n        }\r\n        if (!this.privIsSynthesisEnded) {\r\n            return null;\r\n        }\r\n        if (this.audioOutputFormat.hasHeader) {\r\n            this.privReceivedAudioWithHeader = SynthesisAdapterBase.addHeader(this.allReceivedAudio, this.audioOutputFormat);\r\n            return this.allReceivedAudioWithHeader;\r\n        } else {\r\n            return this.allReceivedAudio;\r\n        }\r\n    }\r\n    private privIsDisposed: boolean = false;\r\n    private privAuthFetchEventId: string;\r\n    private privIsSynthesizing: boolean = false;\r\n    private privIsSynthesisEnded: boolean = false;\r\n    private privBytesReceived: number = 0;\r\n    private privRequestId: string;\r\n    private privStreamId: string;\r\n    private privTurnDeferral: Deferred<boolean>;\r\n    private privAudioOutputFormat: AudioOutputFormatImpl;\r\n    private privAudioOutputStream: PullAudioOutputStreamImpl;\r\n    private privReceivedAudio: ArrayBuffer;\r\n    private privReceivedAudioWithHeader: ArrayBuffer;\r\n    private privTextOffset: number = 0;\r\n    private privNextSearchTextIndex: number = 0;\r\n    private privRawText: string;\r\n    private privIsSSML: boolean;\r\n    private privTurnAudioDestination: IAudioDestination;\r\n\r\n    constructor() {\r\n        this.privRequestId = createNoDashGuid();\r\n        this.privTurnDeferral = new Deferred<boolean>();\r\n\r\n        // We're not in a turn, so resolve.\r\n        this.privTurnDeferral.resolve(true);\r\n    }\r\n\r\n    public startNewSynthesis(requestId: string, rawText: string, isSSML: boolean, audioDestination?: IAudioDestination): void {\r\n        this.privIsSynthesisEnded = false;\r\n        this.privIsSynthesizing = true;\r\n        this.privRequestId = requestId;\r\n        this.privRawText = rawText;\r\n        this.privIsSSML = isSSML;\r\n        this.privAudioOutputStream = new PullAudioOutputStreamImpl();\r\n        this.privAudioOutputStream.format = this.privAudioOutputFormat;\r\n        this.privReceivedAudio = null;\r\n        this.privReceivedAudioWithHeader = null;\r\n        this.privBytesReceived = 0;\r\n        this.privTextOffset = 0;\r\n        this.privNextSearchTextIndex = 0;\r\n        if (audioDestination !== undefined) {\r\n            this.privTurnAudioDestination = audioDestination;\r\n            this.privTurnAudioDestination.format = this.privAudioOutputFormat;\r\n        }\r\n        this.onEvent(new SynthesisTriggeredEvent(this.requestId, undefined, audioDestination === undefined ? undefined : audioDestination.id()));\r\n    }\r\n\r\n    public onPreConnectionStart = (authFetchEventId: string, connectionId: string): void => {\r\n        this.privAuthFetchEventId = authFetchEventId;\r\n        this.onEvent(new ConnectingToSynthesisServiceEvent(this.privRequestId, this.privAuthFetchEventId));\r\n    }\r\n\r\n    public onAuthCompleted = (isError: boolean, error?: string): void => {\r\n        if (isError) {\r\n            this.onComplete();\r\n        }\r\n    }\r\n\r\n    public onConnectionEstablishCompleted = (statusCode: number, reason?: string): void => {\r\n        if (statusCode === 200) {\r\n            this.onEvent(new SynthesisStartedEvent(this.requestId, this.privAuthFetchEventId));\r\n            this.privBytesReceived = 0;\r\n            return;\r\n        } else if (statusCode === 403) {\r\n            this.onComplete();\r\n        }\r\n    }\r\n\r\n    public onServiceResponseMessage = (responseJson: string): void => {\r\n        const response: ISynthesisResponse = JSON.parse(responseJson);\r\n        this.streamId = response.audio.streamId;\r\n    }\r\n\r\n    public onServiceTurnEndResponse = (): void => {\r\n        this.privTurnDeferral.resolve(true);\r\n        this.onComplete();\r\n    }\r\n\r\n    public onServiceTurnStartResponse = (): void => {\r\n        if (this.privTurnDeferral.state() === PromiseState.None) {\r\n            // What? How are we starting a turn with another not done?\r\n            this.privTurnDeferral.reject(\"Another turn started before current completed.\");\r\n        }\r\n\r\n        this.privTurnDeferral = new Deferred<boolean>();\r\n    }\r\n\r\n    public onAudioChunkReceived(data: ArrayBuffer): void {\r\n        if (this.isSynthesizing) {\r\n            this.privAudioOutputStream.write(data);\r\n            this.privBytesReceived += data.byteLength;\r\n            if (this.privTurnAudioDestination !== undefined) {\r\n                this.privTurnAudioDestination.write(data);\r\n            }\r\n        }\r\n    }\r\n\r\n    public onWordBoundaryEvent(text: string): void {\r\n        this.updateTextOffset(text);\r\n    }\r\n\r\n    public dispose = (error?: string): void => {\r\n        if (!this.privIsDisposed) {\r\n            // we should have completed by now. If we did not its an unknown error.\r\n            this.privIsDisposed = true;\r\n        }\r\n    }\r\n\r\n    public onStopSynthesizing(): void {\r\n        this.onComplete();\r\n    }\r\n\r\n    protected onEvent = (event: SpeechSynthesisEvent): void => {\r\n        Events.instance.onEvent(event);\r\n    }\r\n\r\n    private updateTextOffset(text: string): void {\r\n        if (this.privTextOffset >= 0) {\r\n            this.privTextOffset = this.privRawText.indexOf(text, this.privNextSearchTextIndex);\r\n            if (this.privTextOffset >= 0) {\r\n                this.privNextSearchTextIndex = this.privTextOffset + text.length;\r\n            }\r\n            if (this.privIsSSML) {\r\n                if (this.privRawText.indexOf(\"<\", this.privTextOffset + 1) > this.privRawText.indexOf(\">\", this.privTextOffset + 1)) {\r\n                    this.updateTextOffset(text);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private onComplete = (): void => {\r\n        if (this.privIsSynthesizing) {\r\n            this.privIsSynthesizing = false;\r\n            this.privIsSynthesisEnded = true;\r\n            this.privAudioOutputStream.close();\r\n            if (this.privTurnAudioDestination !== undefined) {\r\n                this.privTurnAudioDestination.close();\r\n                this.privTurnAudioDestination = undefined;\r\n            }\r\n        }\r\n    }\r\n\r\n    private readAllAudioFromStream(): void {\r\n        if (this.privIsSynthesisEnded) {\r\n            this.privReceivedAudio = new ArrayBuffer(this.bytesReceived);\r\n            try {\r\n                this.privAudioOutputStream.read(this.privReceivedAudio);\r\n            } catch (e) {\r\n                this.privReceivedAudio = new ArrayBuffer(0);\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}