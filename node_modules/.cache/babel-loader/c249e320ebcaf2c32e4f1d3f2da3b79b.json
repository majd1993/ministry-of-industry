{"ast":null,"code":"'use strict';\n\nvar decimal = require('is-decimal');\n\nvar alphanumeric = require('is-alphanumeric');\n\nvar whitespace = require('is-whitespace-character');\n\nvar escapes = require('markdown-escapes');\n\nvar prefix = require('./util/entity-prefix-length');\n\nmodule.exports = factory;\nvar tab = '\\t';\nvar lineFeed = '\\n';\nvar space = ' ';\nvar numberSign = '#';\nvar ampersand = '&';\nvar leftParenthesis = '(';\nvar rightParenthesis = ')';\nvar asterisk = '*';\nvar plusSign = '+';\nvar dash = '-';\nvar dot = '.';\nvar colon = ':';\nvar lessThan = '<';\nvar greaterThan = '>';\nvar leftSquareBracket = '[';\nvar backslash = '\\\\';\nvar rightSquareBracket = ']';\nvar underscore = '_';\nvar graveAccent = '`';\nvar verticalBar = '|';\nvar tilde = '~';\nvar exclamationMark = '!';\nvar entities = {\n  '<': '&lt;',\n  ':': '&#x3A;',\n  '&': '&amp;',\n  '|': '&#x7C;',\n  '~': '&#x7E;'\n};\nvar shortcut = 'shortcut';\nvar mailto = 'mailto';\nvar https = 'https';\nvar http = 'http';\nvar blankExpression = /\\n\\s*$/; // Factory to escape characters.\n\nfunction factory(options) {\n  return escape; // Escape punctuation characters in a node’s value.\n\n  function escape(value, node, parent) {\n    var self = this;\n    var gfm = options.gfm;\n    var commonmark = options.commonmark;\n    var pedantic = options.pedantic;\n    var markers = commonmark ? [dot, rightParenthesis] : [dot];\n    var siblings = parent && parent.children;\n    var index = siblings && siblings.indexOf(node);\n    var prev = siblings && siblings[index - 1];\n    var next = siblings && siblings[index + 1];\n    var length = value.length;\n    var escapable = escapes(options);\n    var position = -1;\n    var queue = [];\n    var escaped = queue;\n    var afterNewLine;\n    var character;\n    var wordCharBefore;\n    var wordCharAfter;\n    var offset;\n    var replace;\n\n    if (prev) {\n      afterNewLine = text(prev) && blankExpression.test(prev.value);\n    } else {\n      afterNewLine = !parent || parent.type === 'root' || parent.type === 'paragraph';\n    }\n\n    while (++position < length) {\n      character = value.charAt(position);\n      replace = false;\n\n      if (character === '\\n') {\n        afterNewLine = true;\n      } else if (character === backslash || character === graveAccent || character === asterisk || character === exclamationMark && value.charAt(position + 1) === leftSquareBracket || character === leftSquareBracket || character === lessThan || character === ampersand && prefix(value.slice(position)) > 0 || character === rightSquareBracket && self.inLink || gfm && character === tilde && value.charAt(position + 1) === tilde || gfm && character === verticalBar && (self.inTable || alignment(value, position)) || character === underscore && // Delegate leading/trailing underscores to the multinode version below.\n      position > 0 && position < length - 1 && (pedantic || !alphanumeric(value.charAt(position - 1)) || !alphanumeric(value.charAt(position + 1))) || gfm && !self.inLink && character === colon && protocol(queue.join(''))) {\n        replace = true;\n      } else if (afterNewLine) {\n        if (character === greaterThan || character === numberSign || character === asterisk || character === dash || character === plusSign) {\n          replace = true;\n        } else if (decimal(character)) {\n          offset = position + 1;\n\n          while (offset < length) {\n            if (!decimal(value.charAt(offset))) {\n              break;\n            }\n\n            offset++;\n          }\n\n          if (markers.indexOf(value.charAt(offset)) !== -1) {\n            next = value.charAt(offset + 1);\n\n            if (!next || next === space || next === tab || next === lineFeed) {\n              queue.push(value.slice(position, offset));\n              position = offset;\n              character = value.charAt(position);\n              replace = true;\n            }\n          }\n        }\n      }\n\n      if (afterNewLine && !whitespace(character)) {\n        afterNewLine = false;\n      }\n\n      queue.push(replace ? one(character) : character);\n    } // Multi-node versions.\n\n\n    if (siblings && text(node)) {\n      // Check for an opening parentheses after a link-reference (which can be\n      // joined by white-space).\n      if (prev && prev.referenceType === shortcut) {\n        position = -1;\n        length = escaped.length;\n\n        while (++position < length) {\n          character = escaped[position];\n\n          if (character === space || character === tab) {\n            continue;\n          }\n\n          if (character === leftParenthesis || character === colon) {\n            escaped[position] = one(character);\n          }\n\n          break;\n        } // If the current node is all spaces / tabs, preceded by a shortcut,\n        // and followed by a text starting with `(`, escape it.\n\n\n        if (text(next) && position === length && next.value.charAt(0) === leftParenthesis) {\n          escaped.push(backslash);\n        }\n      } // Ensure non-auto-links are not seen as links.  This pattern needs to\n      // check the preceding nodes too.\n\n\n      if (gfm && !self.inLink && text(prev) && value.charAt(0) === colon && protocol(prev.value.slice(-6))) {\n        escaped[0] = one(colon);\n      } // Escape ampersand if it would otherwise start an entity.\n\n\n      if (text(next) && value.charAt(length - 1) === ampersand && prefix(ampersand + next.value) !== 0) {\n        escaped[escaped.length - 1] = one(ampersand);\n      } // Escape exclamation marks immediately followed by links.\n\n\n      if (next && next.type === 'link' && value.charAt(length - 1) === exclamationMark) {\n        escaped[escaped.length - 1] = one(exclamationMark);\n      } // Escape double tildes in GFM.\n\n\n      if (gfm && text(next) && value.charAt(length - 1) === tilde && next.value.charAt(0) === tilde) {\n        escaped.splice(escaped.length - 1, 0, backslash);\n      } // Escape underscores, but not mid-word (unless in pedantic mode).\n\n\n      wordCharBefore = text(prev) && alphanumeric(prev.value.slice(-1));\n      wordCharAfter = text(next) && alphanumeric(next.value.charAt(0));\n\n      if (length === 1) {\n        if (value === underscore && (pedantic || !wordCharBefore || !wordCharAfter)) {\n          escaped.unshift(backslash);\n        }\n      } else {\n        if (value.charAt(0) === underscore && (pedantic || !wordCharBefore || !alphanumeric(value.charAt(1)))) {\n          escaped.unshift(backslash);\n        }\n\n        if (value.charAt(length - 1) === underscore && (pedantic || !wordCharAfter || !alphanumeric(value.charAt(length - 2)))) {\n          escaped.splice(escaped.length - 1, 0, backslash);\n        }\n      }\n    }\n\n    return escaped.join('');\n\n    function one(character) {\n      return escapable.indexOf(character) === -1 ? entities[character] : backslash + character;\n    }\n  }\n} // Check if `index` in `value` is inside an alignment row.\n\n\nfunction alignment(value, index) {\n  var start = value.lastIndexOf(lineFeed, index);\n  var end = value.indexOf(lineFeed, index);\n  var char;\n  end = end === -1 ? value.length : end;\n\n  while (++start < end) {\n    char = value.charAt(start);\n\n    if (char !== colon && char !== dash && char !== space && char !== verticalBar) {\n      return false;\n    }\n  }\n\n  return true;\n} // Check if `node` is a text node.\n\n\nfunction text(node) {\n  return node && node.type === 'text';\n} // Check if `value` ends in a protocol.\n\n\nfunction protocol(value) {\n  var val = value.slice(-6).toLowerCase();\n  return val === mailto || val.slice(-5) === https || val.slice(-4) === http;\n}","map":{"version":3,"sources":["/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/remark-stringify/lib/escape.js"],"names":["decimal","require","alphanumeric","whitespace","escapes","prefix","module","exports","factory","tab","lineFeed","space","numberSign","ampersand","leftParenthesis","rightParenthesis","asterisk","plusSign","dash","dot","colon","lessThan","greaterThan","leftSquareBracket","backslash","rightSquareBracket","underscore","graveAccent","verticalBar","tilde","exclamationMark","entities","shortcut","mailto","https","http","blankExpression","options","escape","value","node","parent","self","gfm","commonmark","pedantic","markers","siblings","children","index","indexOf","prev","next","length","escapable","position","queue","escaped","afterNewLine","character","wordCharBefore","wordCharAfter","offset","replace","text","test","type","charAt","slice","inLink","inTable","alignment","protocol","join","push","one","referenceType","splice","unshift","start","lastIndexOf","end","char","val","toLowerCase"],"mappings":"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","sourcesContent":["'use strict'\n\nvar decimal = require('is-decimal')\nvar alphanumeric = require('is-alphanumeric')\nvar whitespace = require('is-whitespace-character')\nvar escapes = require('markdown-escapes')\nvar prefix = require('./util/entity-prefix-length')\n\nmodule.exports = factory\n\nvar tab = '\\t'\nvar lineFeed = '\\n'\nvar space = ' '\nvar numberSign = '#'\nvar ampersand = '&'\nvar leftParenthesis = '('\nvar rightParenthesis = ')'\nvar asterisk = '*'\nvar plusSign = '+'\nvar dash = '-'\nvar dot = '.'\nvar colon = ':'\nvar lessThan = '<'\nvar greaterThan = '>'\nvar leftSquareBracket = '['\nvar backslash = '\\\\'\nvar rightSquareBracket = ']'\nvar underscore = '_'\nvar graveAccent = '`'\nvar verticalBar = '|'\nvar tilde = '~'\nvar exclamationMark = '!'\n\nvar entities = {\n  '<': '&lt;',\n  ':': '&#x3A;',\n  '&': '&amp;',\n  '|': '&#x7C;',\n  '~': '&#x7E;'\n}\n\nvar shortcut = 'shortcut'\nvar mailto = 'mailto'\nvar https = 'https'\nvar http = 'http'\n\nvar blankExpression = /\\n\\s*$/\n\n// Factory to escape characters.\nfunction factory(options) {\n  return escape\n\n  // Escape punctuation characters in a node’s value.\n  function escape(value, node, parent) {\n    var self = this\n    var gfm = options.gfm\n    var commonmark = options.commonmark\n    var pedantic = options.pedantic\n    var markers = commonmark ? [dot, rightParenthesis] : [dot]\n    var siblings = parent && parent.children\n    var index = siblings && siblings.indexOf(node)\n    var prev = siblings && siblings[index - 1]\n    var next = siblings && siblings[index + 1]\n    var length = value.length\n    var escapable = escapes(options)\n    var position = -1\n    var queue = []\n    var escaped = queue\n    var afterNewLine\n    var character\n    var wordCharBefore\n    var wordCharAfter\n    var offset\n    var replace\n\n    if (prev) {\n      afterNewLine = text(prev) && blankExpression.test(prev.value)\n    } else {\n      afterNewLine =\n        !parent || parent.type === 'root' || parent.type === 'paragraph'\n    }\n\n    while (++position < length) {\n      character = value.charAt(position)\n      replace = false\n\n      if (character === '\\n') {\n        afterNewLine = true\n      } else if (\n        character === backslash ||\n        character === graveAccent ||\n        character === asterisk ||\n        (character === exclamationMark &&\n          value.charAt(position + 1) === leftSquareBracket) ||\n        character === leftSquareBracket ||\n        character === lessThan ||\n        (character === ampersand && prefix(value.slice(position)) > 0) ||\n        (character === rightSquareBracket && self.inLink) ||\n        (gfm && character === tilde && value.charAt(position + 1) === tilde) ||\n        (gfm &&\n          character === verticalBar &&\n          (self.inTable || alignment(value, position))) ||\n        (character === underscore &&\n          // Delegate leading/trailing underscores to the multinode version below.\n          position > 0 &&\n          position < length - 1 &&\n          (pedantic ||\n            !alphanumeric(value.charAt(position - 1)) ||\n            !alphanumeric(value.charAt(position + 1)))) ||\n        (gfm && !self.inLink && character === colon && protocol(queue.join('')))\n      ) {\n        replace = true\n      } else if (afterNewLine) {\n        if (\n          character === greaterThan ||\n          character === numberSign ||\n          character === asterisk ||\n          character === dash ||\n          character === plusSign\n        ) {\n          replace = true\n        } else if (decimal(character)) {\n          offset = position + 1\n\n          while (offset < length) {\n            if (!decimal(value.charAt(offset))) {\n              break\n            }\n\n            offset++\n          }\n\n          if (markers.indexOf(value.charAt(offset)) !== -1) {\n            next = value.charAt(offset + 1)\n\n            if (!next || next === space || next === tab || next === lineFeed) {\n              queue.push(value.slice(position, offset))\n              position = offset\n              character = value.charAt(position)\n              replace = true\n            }\n          }\n        }\n      }\n\n      if (afterNewLine && !whitespace(character)) {\n        afterNewLine = false\n      }\n\n      queue.push(replace ? one(character) : character)\n    }\n\n    // Multi-node versions.\n    if (siblings && text(node)) {\n      // Check for an opening parentheses after a link-reference (which can be\n      // joined by white-space).\n      if (prev && prev.referenceType === shortcut) {\n        position = -1\n        length = escaped.length\n\n        while (++position < length) {\n          character = escaped[position]\n\n          if (character === space || character === tab) {\n            continue\n          }\n\n          if (character === leftParenthesis || character === colon) {\n            escaped[position] = one(character)\n          }\n\n          break\n        }\n\n        // If the current node is all spaces / tabs, preceded by a shortcut,\n        // and followed by a text starting with `(`, escape it.\n        if (\n          text(next) &&\n          position === length &&\n          next.value.charAt(0) === leftParenthesis\n        ) {\n          escaped.push(backslash)\n        }\n      }\n\n      // Ensure non-auto-links are not seen as links.  This pattern needs to\n      // check the preceding nodes too.\n      if (\n        gfm &&\n        !self.inLink &&\n        text(prev) &&\n        value.charAt(0) === colon &&\n        protocol(prev.value.slice(-6))\n      ) {\n        escaped[0] = one(colon)\n      }\n\n      // Escape ampersand if it would otherwise start an entity.\n      if (\n        text(next) &&\n        value.charAt(length - 1) === ampersand &&\n        prefix(ampersand + next.value) !== 0\n      ) {\n        escaped[escaped.length - 1] = one(ampersand)\n      }\n\n      // Escape exclamation marks immediately followed by links.\n      if (\n        next &&\n        next.type === 'link' &&\n        value.charAt(length - 1) === exclamationMark\n      ) {\n        escaped[escaped.length - 1] = one(exclamationMark)\n      }\n\n      // Escape double tildes in GFM.\n      if (\n        gfm &&\n        text(next) &&\n        value.charAt(length - 1) === tilde &&\n        next.value.charAt(0) === tilde\n      ) {\n        escaped.splice(escaped.length - 1, 0, backslash)\n      }\n\n      // Escape underscores, but not mid-word (unless in pedantic mode).\n      wordCharBefore = text(prev) && alphanumeric(prev.value.slice(-1))\n      wordCharAfter = text(next) && alphanumeric(next.value.charAt(0))\n\n      if (length === 1) {\n        if (\n          value === underscore &&\n          (pedantic || !wordCharBefore || !wordCharAfter)\n        ) {\n          escaped.unshift(backslash)\n        }\n      } else {\n        if (\n          value.charAt(0) === underscore &&\n          (pedantic || !wordCharBefore || !alphanumeric(value.charAt(1)))\n        ) {\n          escaped.unshift(backslash)\n        }\n\n        if (\n          value.charAt(length - 1) === underscore &&\n          (pedantic ||\n            !wordCharAfter ||\n            !alphanumeric(value.charAt(length - 2)))\n        ) {\n          escaped.splice(escaped.length - 1, 0, backslash)\n        }\n      }\n    }\n\n    return escaped.join('')\n\n    function one(character) {\n      return escapable.indexOf(character) === -1\n        ? entities[character]\n        : backslash + character\n    }\n  }\n}\n\n// Check if `index` in `value` is inside an alignment row.\nfunction alignment(value, index) {\n  var start = value.lastIndexOf(lineFeed, index)\n  var end = value.indexOf(lineFeed, index)\n  var char\n\n  end = end === -1 ? value.length : end\n\n  while (++start < end) {\n    char = value.charAt(start)\n\n    if (\n      char !== colon &&\n      char !== dash &&\n      char !== space &&\n      char !== verticalBar\n    ) {\n      return false\n    }\n  }\n\n  return true\n}\n\n// Check if `node` is a text node.\nfunction text(node) {\n  return node && node.type === 'text'\n}\n\n// Check if `value` ends in a protocol.\nfunction protocol(value) {\n  var val = value.slice(-6).toLowerCase()\n  return val === mailto || val.slice(-5) === https || val.slice(-4) === http\n}\n"]},"metadata":{},"sourceType":"script"}