{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = useReplaceEmoticon;\n\nvar _botframeworkWebchatApi = require(\"botframework-webchat-api\");\n\nvar _react = require(\"react\");\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nvar useStyleOptions = _botframeworkWebchatApi.hooks.useStyleOptions;\n\nfunction useReplaceEmoticon() {\n  var _useStyleOptions = useStyleOptions(),\n      _useStyleOptions2 = _slicedToArray(_useStyleOptions, 1),\n      emojiSet = _useStyleOptions2[0].emojiSet;\n\n  return (0, _react.useCallback)( // We need to know where (in offset) the change is, then we can decide which emoticon to update.\n  // We need to distinguish in this case, string change from \"abc:)xyz\" to \"abc:))xyz\".\n  // If the caret position is after the first parenthesis, we will change it to \"abcðŸ˜Š)xyz\".\n  // But if the caret position is after the second parenthesis, we will not change it but leave it as \"abc:))xyz\".\n  // This is because the user already decided to undo the emoji and just added a parenthesis after the emoticon. It should not affect the emoticon.\n  function (_ref) {\n    var selectionEnd = _ref.selectionEnd,\n        selectionStart = _ref.selectionStart,\n        value = _ref.value;\n\n    if (typeof selectionEnd !== 'number') {\n      console.warn('botframework-webchat: The first argument passed to \"useReplaceEmoticon\" must contains \"selectionEnd\" of type number, indicating the caret position.');\n    } else if (typeof selectionStart !== 'number') {\n      console.warn('botframework-webchat: The first argument passed to \"useReplaceEmoticon\" must contains \"selectionStart\" of type number, indicating the caret position.');\n    } else if (typeof value !== 'string') {\n      console.warn('botframework-webchat: The first argument passed to \"useReplaceEmoticon\" must contains \"value\" of type string.');\n    } // We only change when the user is not selecting anything.\n\n\n    selectionEnd === selectionStart && Object.entries(emojiSet).every(function (_ref2) {\n      var _ref3 = _slicedToArray(_ref2, 2),\n          emoticon = _ref3[0],\n          emoji = _ref3[1];\n\n      var length = emoticon.length;\n\n      if (value.slice(selectionStart - length, selectionStart) === emoticon) {\n        value = \"\".concat(value.slice(0, selectionStart - length)).concat(emoji).concat(value.slice(selectionStart));\n        selectionEnd = selectionStart += emoji.length - length;\n        return false;\n      }\n\n      return true;\n    });\n    return {\n      selectionEnd: selectionEnd,\n      selectionStart: selectionStart,\n      value: value\n    };\n  }, [emojiSet]);\n}","map":{"version":3,"sources":["../../../src/hooks/internal/useReplaceEmoticon.js"],"names":["useStyleOptions","hooks","emojiSet","selectionEnd","selectionStart","value","console","emoticon","emoji","length"],"mappings":";;;;;;;AAEA,IAAA,uBAAA,GAAA,OAAA,CAAA,0BAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,OAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAEQA,e,GAAoBC,uBAAAA,CAAAA,KAAAA,CAApBD,e;;AAEO,SAAA,kBAAA,GAA8B;AAAA,MAAA,gBAAA,GACpBA,eADoB,EAAA;AAAA,MAAA,iBAAA,GAAA,cAAA,CAAA,gBAAA,EAAA,CAAA,CAAA;AAAA,MAClCE,QADkC,GAAA,iBAAA,CAAA,CAAA,CAAA,CAAA,QAAA;;AAG3C,SAAO,CAAA,GAAA,MAAA,CAAA,WAAA,GACL;AACA;AACA;AACA;AACA;AACA,YAAA,IAAA,EAA6C;AAAA,QAA1CC,YAA0C,GAAA,IAAA,CAA1CA,YAA0C;AAAA,QAA5BC,cAA4B,GAAA,IAAA,CAA5BA,cAA4B;AAAA,QAAZC,KAAY,GAAA,IAAA,CAAZA,KAAY;;AAC3C,QAAI,OAAA,YAAA,KAAJ,QAAA,EAAsC;AACpCC,MAAAA,OAAO,CAAPA,IAAAA,CAAAA,qJAAAA;AADF,KAAA,MAIO,IAAI,OAAA,cAAA,KAAJ,QAAA,EAAwC;AAC7CA,MAAAA,OAAO,CAAPA,IAAAA,CAAAA,uJAAAA;AADK,KAAA,MAIA,IAAI,OAAA,KAAA,KAAJ,QAAA,EAA+B;AACpCA,MAAAA,OAAO,CAAPA,IAAAA,CAAAA,+GAAAA;AAVyC,KAAA,CAe3C;;;AACAH,IAAAA,YAAY,KAAZA,cAAAA,IACE,MAAM,CAAN,OAAA,CAAA,QAAA,EAAA,KAAA,CAA+B,UAAA,KAAA,EAAuB;AAAA,UAAA,KAAA,GAAA,cAAA,CAAA,KAAA,EAAA,CAAA,CAAA;AAAA,UAArBI,QAAqB,GAAA,KAAA,CAAA,CAAA,CAAA;AAAA,UAAXC,KAAW,GAAA,KAAA,CAAA,CAAA,CAAA;;AAAA,UAC5CC,MAD4C,GACjCF,QADiC,CAAA,MAAA;;AAGpD,UAAIF,KAAK,CAALA,KAAAA,CAAYD,cAAc,GAA1BC,MAAAA,EAAAA,cAAAA,MAAJ,QAAA,EAAuE;AACrEA,QAAAA,KAAK,GAAA,GAAA,MAAA,CAAMA,KAAK,CAALA,KAAAA,CAAAA,CAAAA,EAAeD,cAAc,GAAnC,MAAMC,CAAN,EAAA,MAAA,CAAA,KAAA,EAAA,MAAA,CAAwDA,KAAK,CAALA,KAAAA,CAA7DA,cAA6DA,CAAxD,CAALA;AACAF,QAAAA,YAAY,GAAGC,cAAc,IAAII,KAAK,CAALA,MAAAA,GAAjCL,MAAAA;AAEA,eAAA,KAAA;AACD;;AAED,aAAA,IAAA;AAXJA,KACE,CADFA;AAcA,WAAO;AAAEA,MAAAA,YAAY,EAAd,YAAA;AAAgBC,MAAAA,cAAc,EAA9B,cAAA;AAAgCC,MAAAA,KAAK,EAALA;AAAhC,KAAP;AApCG,GAAA,EAsCL,CAtCF,QAsCE,CAtCK,CAAP;AAwCD","sourcesContent":["/*eslint require-unicode-regexp: \"off\" */\n\nimport { hooks } from 'botframework-webchat-api';\nimport { useCallback } from 'react';\n\nconst { useStyleOptions } = hooks;\n\nexport default function useReplaceEmoticon() {\n  const [{ emojiSet }] = useStyleOptions();\n\n  return useCallback(\n    // We need to know where (in offset) the change is, then we can decide which emoticon to update.\n    // We need to distinguish in this case, string change from \"abc:)xyz\" to \"abc:))xyz\".\n    // If the caret position is after the first parenthesis, we will change it to \"abcðŸ˜Š)xyz\".\n    // But if the caret position is after the second parenthesis, we will not change it but leave it as \"abc:))xyz\".\n    // This is because the user already decided to undo the emoji and just added a parenthesis after the emoticon. It should not affect the emoticon.\n    ({ selectionEnd, selectionStart, value }) => {\n      if (typeof selectionEnd !== 'number') {\n        console.warn(\n          'botframework-webchat: The first argument passed to \"useReplaceEmoticon\" must contains \"selectionEnd\" of type number, indicating the caret position.'\n        );\n      } else if (typeof selectionStart !== 'number') {\n        console.warn(\n          'botframework-webchat: The first argument passed to \"useReplaceEmoticon\" must contains \"selectionStart\" of type number, indicating the caret position.'\n        );\n      } else if (typeof value !== 'string') {\n        console.warn(\n          'botframework-webchat: The first argument passed to \"useReplaceEmoticon\" must contains \"value\" of type string.'\n        );\n      }\n\n      // We only change when the user is not selecting anything.\n      selectionEnd === selectionStart &&\n        Object.entries(emojiSet).every(([emoticon, emoji]) => {\n          const { length } = emoticon;\n\n          if (value.slice(selectionStart - length, selectionStart) === emoticon) {\n            value = `${value.slice(0, selectionStart - length)}${emoji}${value.slice(selectionStart)}`;\n            selectionEnd = selectionStart += emoji.length - length;\n\n            return false;\n          }\n\n          return true;\n        });\n\n      return { selectionEnd, selectionStart, value };\n    },\n    [emojiSet]\n  );\n}\n"],"sourceRoot":"component:///"},"metadata":{},"sourceType":"script"}