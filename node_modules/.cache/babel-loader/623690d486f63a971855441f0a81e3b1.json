{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { createNoDashGuid, Deferred } from \"../../common/Exports\";\n/**\n * Placeholder class for the Conversation Request Session. Based off RequestSession.\n * TODO: define what telemetry is required.\n */\n\nexport var ConversationRequestSession = /*#__PURE__*/function () {\n  function ConversationRequestSession(sessionId) {\n    var _this = this;\n\n    _classCallCheck(this, ConversationRequestSession);\n\n    this.privIsDisposed = false;\n    this.privDetachables = new Array();\n\n    this.onPreConnectionStart = function (authFetchEventId, connectionId) {\n      _this.privSessionId = connectionId;\n    };\n\n    this.onAuthCompleted = function (isError, error) {\n      if (isError) {\n        _this.onComplete();\n      }\n    };\n\n    this.onConnectionEstablishCompleted = function (statusCode, reason) {\n      if (statusCode === 200) {\n        return;\n      } else if (statusCode === 403) {\n        _this.onComplete();\n      }\n    };\n\n    this.onServiceTurnEndResponse = function (continuousRecognition) {\n      if (!continuousRecognition) {\n        _this.onComplete();\n      } else {\n        _this.privRequestId = createNoDashGuid();\n      }\n    };\n\n    this.dispose = function (error) {\n      if (!_this.privIsDisposed) {\n        // we should have completed by now. If we did not its an unknown error.\n        _this.privIsDisposed = true;\n\n        var _iterator = _createForOfIteratorHelper(_this.privDetachables),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var detachable = _step.value;\n            detachable.detach();\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    };\n\n    this.onComplete = function () {//\n    };\n\n    this.privSessionId = sessionId;\n    this.privRequestId = createNoDashGuid();\n    this.privRequestCompletionDeferral = new Deferred();\n  }\n\n  _createClass(ConversationRequestSession, [{\n    key: \"sessionId\",\n    get: function get() {\n      return this.privSessionId;\n    }\n  }, {\n    key: \"requestId\",\n    get: function get() {\n      return this.privRequestId;\n    }\n  }, {\n    key: \"completionPromise\",\n    get: function get() {\n      return this.privRequestCompletionDeferral.promise();\n    }\n  }]);\n\n  return ConversationRequestSession;\n}();","map":{"version":3,"sources":["src/common.speech/Transcription/ConversationRequestSession.ts"],"names":[],"mappings":";;;AAAA;AACA;AAEA,SACI,gBADJ,EAEI,QAFJ,QAKO,sBALP;AAOA;;;AAGG;;AACH,WAAa,0BAAb;AAOI,sCAAY,SAAZ,EAA6B;AAAA;;AAAA;;AANrB,SAAA,cAAA,GAA0B,KAA1B;AACA,SAAA,eAAA,GAAiC,IAAI,KAAJ,EAAjC;;AAuBD,SAAA,oBAAA,GAAuB,UAAC,gBAAD,EAA2B,YAA3B,EAAyD;AACnF,MAAA,KAAI,CAAC,aAAL,GAAqB,YAArB;AACH,KAFM;;AAIA,SAAA,eAAA,GAAkB,UAAC,OAAD,EAAmB,KAAnB,EAA2C;AAChE,UAAI,OAAJ,EAAa;AACT,QAAA,KAAI,CAAC,UAAL;AACH;AACJ,KAJM;;AAMA,SAAA,8BAAA,GAAiC,UAAC,UAAD,EAAqB,MAArB,EAA8C;AAClF,UAAI,UAAU,KAAK,GAAnB,EAAwB;AACpB;AACH,OAFD,MAEO,IAAI,UAAU,KAAK,GAAnB,EAAwB;AAC3B,QAAA,KAAI,CAAC,UAAL;AACH;AACJ,KANM;;AAQA,SAAA,wBAAA,GAA2B,UAAC,qBAAD,EAAyC;AACvE,UAAI,CAAC,qBAAL,EAA4B;AACxB,QAAA,KAAI,CAAC,UAAL;AACH,OAFD,MAEO;AACH,QAAA,KAAI,CAAC,aAAL,GAAqB,gBAAgB,EAArC;AACH;AACJ,KANM;;AAQA,SAAA,OAAA,GAAU,UAAC,KAAD,EAAyB;AACtC,UAAI,CAAC,KAAI,CAAC,cAAV,EAA0B;AACtB;AACA,QAAA,KAAI,CAAC,cAAL,GAAsB,IAAtB;;AAFsB,mDAGG,KAAI,CAAC,eAHR;AAAA;;AAAA;AAGtB,8DAA+C;AAAA,gBAApC,UAAoC;AAC3C,YAAA,UAAU,CAAC,MAAX;AACH;AALqB;AAAA;AAAA;AAAA;AAAA;AAMzB;AACJ,KARM;;AAUC,SAAA,UAAA,GAAa,YAAW,CAC5B;AACH,KAFO;;AArDJ,SAAK,aAAL,GAAqB,SAArB;AACA,SAAK,aAAL,GAAqB,gBAAgB,EAArC;AACA,SAAK,6BAAL,GAAqC,IAAI,QAAJ,EAArC;AACH;;AAXL;AAAA;AAAA,SAaI,eAAoB;AAChB,aAAO,KAAK,aAAZ;AACH;AAfL;AAAA;AAAA,SAiBI,eAAoB;AAChB,aAAO,KAAK,aAAZ;AACH;AAnBL;AAAA;AAAA,SAqBI,eAA4B;AACxB,aAAO,KAAK,6BAAL,CAAmC,OAAnC,EAAP;AACH;AAvBL;;AAAA;AAAA","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    createNoDashGuid,\r\n    Deferred,\r\n    IDetachable,\r\n    Promise,\r\n} from \"../../common/Exports\";\r\n\r\n/**\r\n * Placeholder class for the Conversation Request Session. Based off RequestSession.\r\n * TODO: define what telemetry is required.\r\n */\r\nexport class ConversationRequestSession {\r\n    private privIsDisposed: boolean = false;\r\n    private privDetachables: IDetachable[] = new Array<IDetachable>();\r\n    private privRequestId: string;\r\n    private privRequestCompletionDeferral: Deferred<boolean>;\r\n    private privSessionId: string;\r\n\r\n    constructor(sessionId: string) {\r\n        this.privSessionId = sessionId;\r\n        this.privRequestId = createNoDashGuid();\r\n        this.privRequestCompletionDeferral = new Deferred<boolean>();\r\n    }\r\n\r\n    public get sessionId(): string {\r\n        return this.privSessionId;\r\n    }\r\n\r\n    public get requestId(): string {\r\n        return this.privRequestId;\r\n    }\r\n\r\n    public get completionPromise(): Promise<boolean> {\r\n        return this.privRequestCompletionDeferral.promise();\r\n    }\r\n\r\n    public onPreConnectionStart = (authFetchEventId: string, connectionId: string): void => {\r\n        this.privSessionId = connectionId;\r\n    }\r\n\r\n    public onAuthCompleted = (isError: boolean, error?: string): void => {\r\n        if (isError) {\r\n            this.onComplete();\r\n        }\r\n    }\r\n\r\n    public onConnectionEstablishCompleted = (statusCode: number, reason?: string): void => {\r\n        if (statusCode === 200) {\r\n            return;\r\n        } else if (statusCode === 403) {\r\n            this.onComplete();\r\n        }\r\n    }\r\n\r\n    public onServiceTurnEndResponse = (continuousRecognition: boolean): void => {\r\n        if (!continuousRecognition) {\r\n            this.onComplete();\r\n        } else {\r\n            this.privRequestId = createNoDashGuid();\r\n        }\r\n    }\r\n\r\n    public dispose = (error?: string): void => {\r\n        if (!this.privIsDisposed) {\r\n            // we should have completed by now. If we did not its an unknown error.\r\n            this.privIsDisposed = true;\r\n            for (const detachable of this.privDetachables) {\r\n                detachable.detach();\r\n            }\r\n        }\r\n    }\r\n\r\n    private onComplete = (): void => {\r\n        //\r\n    }\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}