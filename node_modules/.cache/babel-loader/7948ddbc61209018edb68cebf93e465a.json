{"ast":null,"code":"/**\n * Globalize Runtime v1.5.0\n *\n * http://github.com/jquery/globalize\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2020-03-25T12:19Z\n */\n\n/*!\n * Globalize Runtime v1.5.0 2020-03-25T12:19Z Released under the MIT license\n * http://git.io/TrdQbw\n */\n(function (root, factory) {\n  \"use strict\"; // UMD returnExports\n\n  if (typeof define === \"function\" && define.amd) {\n    // AMD\n    define([\"../globalize-runtime\", \"./number\"], factory);\n  } else if (typeof exports === \"object\") {\n    // Node, CommonJS\n    module.exports = factory(require(\"../globalize-runtime\"), require(\"./number\"));\n  } else {\n    // Extend global\n    factory(root.Globalize);\n  }\n})(this, function (Globalize) {\n  var createErrorUnsupportedFeature = Globalize._createErrorUnsupportedFeature,\n      looseMatching = Globalize._looseMatching,\n      partsJoin = Globalize._partsJoin,\n      partsPush = Globalize._partsPush,\n      regexpEscape = Globalize._regexpEscape,\n      removeLiteralQuotes = Globalize._removeLiteralQuotes,\n      runtimeKey = Globalize._runtimeKey,\n      stringPad = Globalize._stringPad,\n      validateParameterPresence = Globalize._validateParameterPresence,\n      validateParameterType = Globalize._validateParameterType,\n      validateParameterTypeString = Globalize._validateParameterTypeString;\n\n  var validateParameterTypeDate = function validateParameterTypeDate(value, name) {\n    validateParameterType(value, name, value === undefined || value instanceof Date, \"Date\");\n  };\n\n  var ZonedDateTime = function () {\n    function definePrivateProperty(object, property, value) {\n      Object.defineProperty(object, property, {\n        value: value\n      });\n    }\n\n    function getUntilsIndex(original, untils) {\n      var index = 0;\n      var originalTime = original.getTime(); // TODO Should we do binary search for improved performance?\n\n      while (index < untils.length - 1 && originalTime >= untils[index]) {\n        index++;\n      }\n\n      return index;\n    }\n\n    function setWrap(fn) {\n      var offset1 = this.getTimezoneOffset();\n      var ret = fn();\n      this.original.setTime(new Date(this.getTime()));\n      var offset2 = this.getTimezoneOffset();\n\n      if (offset2 - offset1) {\n        this.original.setMinutes(this.original.getMinutes() + offset2 - offset1);\n      }\n\n      return ret;\n    }\n\n    var ZonedDateTime = function ZonedDateTime(date, timeZoneData) {\n      definePrivateProperty(this, \"original\", new Date(date.getTime()));\n      definePrivateProperty(this, \"local\", new Date(date.getTime()));\n      definePrivateProperty(this, \"timeZoneData\", timeZoneData);\n      definePrivateProperty(this, \"setWrap\", setWrap);\n\n      if (!(timeZoneData.untils && timeZoneData.offsets && timeZoneData.isdsts)) {\n        throw new Error(\"Invalid IANA data\");\n      }\n\n      this.setTime(this.local.getTime() - this.getTimezoneOffset() * 60 * 1000);\n    };\n\n    ZonedDateTime.prototype.clone = function () {\n      return new ZonedDateTime(this.original, this.timeZoneData);\n    }; // Date field getters.\n\n\n    [\"getFullYear\", \"getMonth\", \"getDate\", \"getDay\", \"getHours\", \"getMinutes\", \"getSeconds\", \"getMilliseconds\"].forEach(function (method) {\n      // Corresponding UTC method, e.g., \"getUTCFullYear\" if method === \"getFullYear\".\n      var utcMethod = \"getUTC\" + method.substr(3);\n\n      ZonedDateTime.prototype[method] = function () {\n        return this.local[utcMethod]();\n      };\n    }); // Note: Define .valueOf = .getTime for arithmetic operations like date1 - date2.\n\n    ZonedDateTime.prototype.valueOf = ZonedDateTime.prototype.getTime = function () {\n      return this.local.getTime() + this.getTimezoneOffset() * 60 * 1000;\n    };\n\n    ZonedDateTime.prototype.getTimezoneOffset = function () {\n      var index = getUntilsIndex(this.original, this.timeZoneData.untils);\n      return this.timeZoneData.offsets[index];\n    }; // Date field setters.\n\n\n    [\"setFullYear\", \"setMonth\", \"setDate\", \"setHours\", \"setMinutes\", \"setSeconds\", \"setMilliseconds\"].forEach(function (method) {\n      // Corresponding UTC method, e.g., \"setUTCFullYear\" if method === \"setFullYear\".\n      var utcMethod = \"setUTC\" + method.substr(3);\n\n      ZonedDateTime.prototype[method] = function (value) {\n        var local = this.local; // Note setWrap is needed for seconds and milliseconds just because\n        // abs(value) could be >= a minute.\n\n        return this.setWrap(function () {\n          return local[utcMethod](value);\n        });\n      };\n    });\n\n    ZonedDateTime.prototype.setTime = function (time) {\n      return this.local.setTime(time);\n    };\n\n    ZonedDateTime.prototype.isDST = function () {\n      var index = getUntilsIndex(this.original, this.timeZoneData.untils);\n      return Boolean(this.timeZoneData.isdsts[index]);\n    };\n\n    ZonedDateTime.prototype.inspect = function () {\n      var index = getUntilsIndex(this.original, this.timeZoneData.untils);\n      var abbrs = this.timeZoneData.abbrs;\n      return this.local.toISOString().replace(/Z$/, \"\") + \" \" + (abbrs && abbrs[index] + \" \" || this.getTimezoneOffset() * -1 + \" \") + (this.isDST() ? \"(daylight savings)\" : \"\");\n    };\n\n    ZonedDateTime.prototype.toDate = function () {\n      return new Date(this.getTime());\n    }; // Type cast getters.\n\n\n    [\"toISOString\", \"toJSON\", \"toUTCString\"].forEach(function (method) {\n      ZonedDateTime.prototype[method] = function () {\n        return this.toDate()[method]();\n      };\n    });\n    return ZonedDateTime;\n  }();\n  /**\n   * dayOfWeek( date, firstDay )\n   *\n   * @date\n   *\n   * @firstDay the result of `dateFirstDayOfWeek( cldr )`\n   *\n   * Return the day of the week normalized by the territory's firstDay [0-6].\n   * Eg for \"mon\":\n   * - return 0 if territory is GB, or BR, or DE, or FR (week starts on \"mon\");\n   * - return 1 if territory is US (week starts on \"sun\");\n   * - return 2 if territory is EG (week starts on \"sat\");\n   */\n\n\n  var dateDayOfWeek = function dateDayOfWeek(date, firstDay) {\n    return (date.getDay() - firstDay + 7) % 7;\n  };\n  /**\n   * distanceInDays( from, to )\n   *\n   * Return the distance in days between from and to Dates.\n   */\n\n\n  var dateDistanceInDays = function dateDistanceInDays(from, to) {\n    var inDays = 864e5;\n    return (to.getTime() - from.getTime()) / inDays;\n  };\n  /**\n   * startOf changes the input to the beginning of the given unit.\n   *\n   * For example, starting at the start of a day, resets hours, minutes\n   * seconds and milliseconds to 0. Starting at the month does the same, but\n   * also sets the date to 1.\n   *\n   * Returns the modified date\n   */\n\n\n  var dateStartOf = function dateStartOf(date, unit) {\n    date = date instanceof ZonedDateTime ? date.clone() : new Date(date.getTime());\n\n    switch (unit) {\n      case \"year\":\n        date.setMonth(0);\n\n      /* falls through */\n\n      case \"month\":\n        date.setDate(1);\n\n      /* falls through */\n\n      case \"day\":\n        date.setHours(0);\n\n      /* falls through */\n\n      case \"hour\":\n        date.setMinutes(0);\n\n      /* falls through */\n\n      case \"minute\":\n        date.setSeconds(0);\n\n      /* falls through */\n\n      case \"second\":\n        date.setMilliseconds(0);\n    }\n\n    return date;\n  };\n  /**\n   * dayOfYear\n   *\n   * Return the distance in days of the date to the begin of the year [0-d].\n   */\n\n\n  var dateDayOfYear = function dateDayOfYear(date) {\n    return Math.floor(dateDistanceInDays(dateStartOf(date, \"year\"), date));\n  };\n  /**\n   * Returns a new object created by using `object`'s values as keys, and the keys as values.\n   */\n\n\n  var objectInvert = function objectInvert(object, fn) {\n    fn = fn || function (object, key, value) {\n      object[value] = key;\n      return object;\n    };\n\n    return Object.keys(object).reduce(function (newObject, key) {\n      return fn(newObject, key, object[key]);\n    }, {});\n  }; // Invert key and values, e.g., {\"year\": \"yY\"} ==> {\"y\": \"year\", \"Y\": \"year\"}\n\n\n  var dateFieldsMap = objectInvert({\n    \"era\": \"G\",\n    \"year\": \"yY\",\n    \"quarter\": \"qQ\",\n    \"month\": \"ML\",\n    \"week\": \"wW\",\n    \"day\": \"dDF\",\n    \"weekday\": \"ecE\",\n    \"dayperiod\": \"a\",\n    \"hour\": \"hHkK\",\n    \"minute\": \"m\",\n    \"second\": \"sSA\",\n    \"zone\": \"zvVOxX\"\n  }, function (object, key, value) {\n    value.split(\"\").forEach(function (symbol) {\n      object[symbol] = key;\n    });\n    return object;\n  });\n  /**\n   * millisecondsInDay\n   */\n\n  var dateMillisecondsInDay = function dateMillisecondsInDay(date) {\n    // TODO Handle daylight savings discontinuities\n    return date - dateStartOf(date, \"day\");\n  };\n\n  var datePatternRe = /([a-z])\\1*|'([^']|'')+'|''|./ig;\n  /**\n   * hourFormat( date, format, timeSeparator, formatNumber )\n   *\n   * Return date's timezone offset according to the format passed.\n   * Eg for format when timezone offset is 180:\n   * - \"+H;-H\": -3\n   * - \"+HHmm;-HHmm\": -0300\n   * - \"+HH:mm;-HH:mm\": -03:00\n   * - \"+HH:mm:ss;-HH:mm:ss\": -03:00:00\n   */\n\n  var dateTimezoneHourFormat = function dateTimezoneHourFormat(date, format, timeSeparator, formatNumber) {\n    var absOffset,\n        offset = date.getTimezoneOffset();\n    absOffset = Math.abs(offset);\n    formatNumber = formatNumber || {\n      1: function _(value) {\n        return stringPad(value, 1);\n      },\n      2: function _(value) {\n        return stringPad(value, 2);\n      }\n    };\n    return format // Pick the correct sign side (+ or -).\n    .split(\";\")[offset > 0 ? 1 : 0] // Localize time separator\n    .replace(\":\", timeSeparator) // Update hours offset.\n    .replace(/HH?/, function (match) {\n      return formatNumber[match.length](Math.floor(absOffset / 60));\n    }) // Update minutes offset and return.\n    .replace(/mm/, function () {\n      return formatNumber[2](Math.floor(absOffset % 60));\n    }) // Update minutes offset and return.\n    .replace(/ss/, function () {\n      return formatNumber[2](Math.floor(absOffset % 1 * 60));\n    });\n  };\n\n  var dateWeekDays = [\"sun\", \"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\"];\n  /**\n   * format( date, properties )\n   *\n   * @date [Date instance].\n   *\n   * @properties\n   *\n   * TODO Support other calendar types.\n   *\n   * Disclosure: this function borrows excerpts of dojo/date/locale.\n   */\n\n  var dateFormat = function dateFormat(date, numberFormatters, properties) {\n    var parts = [];\n    var timeSeparator = properties.timeSeparator; // create globalize date with given timezone data\n\n    if (properties.timeZoneData) {\n      date = new ZonedDateTime(date, properties.timeZoneData());\n    }\n\n    properties.pattern.replace(datePatternRe, function (current) {\n      var aux,\n          dateField,\n          type,\n          value,\n          chr = current.charAt(0),\n          length = current.length;\n\n      if (chr === \"j\") {\n        // Locale preferred hHKk.\n        // http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data\n        chr = properties.preferredTime;\n      }\n\n      if (chr === \"Z\") {\n        // Z..ZZZ: same as \"xxxx\".\n        if (length < 4) {\n          chr = \"x\";\n          length = 4; // ZZZZ: same as \"OOOO\".\n        } else if (length < 5) {\n          chr = \"O\";\n          length = 4; // ZZZZZ: same as \"XXXXX\"\n        } else {\n          chr = \"X\";\n          length = 5;\n        }\n      } // z...zzz: \"{shortRegion}\", e.g., \"PST\" or \"PDT\".\n      // zzzz: \"{regionName} {Standard Time}\" or \"{regionName} {Daylight Time}\",\n      //       e.g., \"Pacific Standard Time\" or \"Pacific Daylight Time\".\n\n\n      if (chr === \"z\") {\n        if (date.isDST) {\n          value = date.isDST() ? properties.daylightTzName : properties.standardTzName;\n        } // Fall back to \"O\" format.\n\n\n        if (!value) {\n          chr = \"O\";\n\n          if (length < 4) {\n            length = 1;\n          }\n        }\n      }\n\n      switch (chr) {\n        // Era\n        case \"G\":\n          value = properties.eras[date.getFullYear() < 0 ? 0 : 1];\n          break;\n        // Year\n\n        case \"y\":\n          // Plain year.\n          // The length specifies the padding, but for two letters it also specifies the\n          // maximum length.\n          value = date.getFullYear();\n\n          if (length === 2) {\n            value = String(value);\n            value = +value.substr(value.length - 2);\n          }\n\n          break;\n\n        case \"Y\":\n          // Year in \"Week of Year\"\n          // The length specifies the padding, but for two letters it also specifies the\n          // maximum length.\n          // yearInWeekofYear = date + DaysInAWeek - (dayOfWeek - firstDay) - minDays\n          value = new Date(date.getTime());\n          value.setDate(value.getDate() + 7 - dateDayOfWeek(date, properties.firstDay) - properties.firstDay - properties.minDays);\n          value = value.getFullYear();\n\n          if (length === 2) {\n            value = String(value);\n            value = +value.substr(value.length - 2);\n          }\n\n          break;\n        // Quarter\n\n        case \"Q\":\n        case \"q\":\n          value = Math.ceil((date.getMonth() + 1) / 3);\n\n          if (length > 2) {\n            value = properties.quarters[chr][length][value];\n          }\n\n          break;\n        // Month\n\n        case \"M\":\n        case \"L\":\n          value = date.getMonth() + 1;\n\n          if (length > 2) {\n            value = properties.months[chr][length][value];\n          }\n\n          break;\n        // Week\n\n        case \"w\":\n          // Week of Year.\n          // woy = ceil( ( doy + dow of 1/1 ) / 7 ) - minDaysStuff ? 1 : 0.\n          // TODO should pad on ww? Not documented, but I guess so.\n          value = dateDayOfWeek(dateStartOf(date, \"year\"), properties.firstDay);\n          value = Math.ceil((dateDayOfYear(date) + value) / 7) - (7 - value >= properties.minDays ? 0 : 1);\n          break;\n\n        case \"W\":\n          // Week of Month.\n          // wom = ceil( ( dom + dow of `1/month` ) / 7 ) - minDaysStuff ? 1 : 0.\n          value = dateDayOfWeek(dateStartOf(date, \"month\"), properties.firstDay);\n          value = Math.ceil((date.getDate() + value) / 7) - (7 - value >= properties.minDays ? 0 : 1);\n          break;\n        // Day\n\n        case \"d\":\n          value = date.getDate();\n          break;\n\n        case \"D\":\n          value = dateDayOfYear(date) + 1;\n          break;\n\n        case \"F\":\n          // Day of Week in month. eg. 2nd Wed in July.\n          value = Math.floor(date.getDate() / 7) + 1;\n          break;\n        // Week day\n\n        case \"e\":\n        case \"c\":\n          if (length <= 2) {\n            // Range is [1-7] (deduced by example provided on documentation)\n            // TODO Should pad with zeros (not specified in the docs)?\n            value = dateDayOfWeek(date, properties.firstDay) + 1;\n            break;\n          }\n\n        /* falls through */\n\n        case \"E\":\n          value = dateWeekDays[date.getDay()];\n          value = properties.days[chr][length][value];\n          break;\n        // Period (AM or PM)\n\n        case \"a\":\n          value = properties.dayPeriods[date.getHours() < 12 ? \"am\" : \"pm\"];\n          break;\n        // Hour\n\n        case \"h\":\n          // 1-12\n          value = date.getHours() % 12 || 12;\n          break;\n\n        case \"H\":\n          // 0-23\n          value = date.getHours();\n          break;\n\n        case \"K\":\n          // 0-11\n          value = date.getHours() % 12;\n          break;\n\n        case \"k\":\n          // 1-24\n          value = date.getHours() || 24;\n          break;\n        // Minute\n\n        case \"m\":\n          value = date.getMinutes();\n          break;\n        // Second\n\n        case \"s\":\n          value = date.getSeconds();\n          break;\n\n        case \"S\":\n          value = Math.round(date.getMilliseconds() * Math.pow(10, length - 3));\n          break;\n\n        case \"A\":\n          value = Math.round(dateMillisecondsInDay(date) * Math.pow(10, length - 3));\n          break;\n        // Zone\n\n        case \"z\":\n          break;\n\n        case \"v\":\n          // v...vvv: \"{shortRegion}\", eg. \"PT\".\n          // vvvv: \"{regionName} {Time}\",\n          //       e.g., \"Pacific Time\".\n          if (properties.genericTzName) {\n            value = properties.genericTzName;\n            break;\n          }\n\n        /* falls through */\n\n        case \"V\":\n          //VVVV: \"{explarCity} {Time}\", e.g., \"Los Angeles Time\"\n          if (properties.timeZoneName) {\n            value = properties.timeZoneName;\n            break;\n          }\n\n          if (current === \"v\") {\n            length = 1;\n          }\n\n        /* falls through */\n\n        case \"O\":\n          // O: \"{gmtFormat}+H;{gmtFormat}-H\" or \"{gmtZeroFormat}\", eg. \"GMT-8\" or \"GMT\".\n          // OOOO: \"{gmtFormat}{hourFormat}\" or \"{gmtZeroFormat}\", eg. \"GMT-08:00\" or \"GMT\".\n          if (date.getTimezoneOffset() === 0) {\n            value = properties.gmtZeroFormat;\n          } else {\n            // If O..OOO and timezone offset has non-zero minutes, show minutes.\n            if (length < 4) {\n              aux = date.getTimezoneOffset();\n              aux = properties.hourFormat[aux % 60 - aux % 1 === 0 ? 0 : 1];\n            } else {\n              aux = properties.hourFormat;\n            }\n\n            value = dateTimezoneHourFormat(date, aux, timeSeparator, numberFormatters);\n            value = properties.gmtFormat.replace(/\\{0\\}/, value);\n          }\n\n          break;\n\n        case \"X\":\n          // Same as x*, except it uses \"Z\" for zero offset.\n          if (date.getTimezoneOffset() === 0) {\n            value = \"Z\";\n            break;\n          }\n\n        /* falls through */\n\n        case \"x\":\n          // x: hourFormat(\"+HH[mm];-HH[mm]\")\n          // xx: hourFormat(\"+HHmm;-HHmm\")\n          // xxx: hourFormat(\"+HH:mm;-HH:mm\")\n          // xxxx: hourFormat(\"+HHmm[ss];-HHmm[ss]\")\n          // xxxxx: hourFormat(\"+HH:mm[:ss];-HH:mm[:ss]\")\n          aux = date.getTimezoneOffset(); // If x and timezone offset has non-zero minutes, use xx (i.e., show minutes).\n\n          if (length === 1 && aux % 60 - aux % 1 !== 0) {\n            length += 1;\n          } // If (xxxx or xxxxx) and timezone offset has zero seconds, use xx or xxx\n          // respectively (i.e., don't show optional seconds).\n\n\n          if ((length === 4 || length === 5) && aux % 1 === 0) {\n            length -= 2;\n          }\n\n          value = [\"+HH;-HH\", \"+HHmm;-HHmm\", \"+HH:mm;-HH:mm\", \"+HHmmss;-HHmmss\", \"+HH:mm:ss;-HH:mm:ss\"][length - 1];\n          value = dateTimezoneHourFormat(date, value, \":\");\n          break;\n        // timeSeparator\n\n        case \":\":\n          value = timeSeparator;\n          break;\n        // ' literals.\n\n        case \"'\":\n          value = removeLiteralQuotes(current);\n          break;\n        // Anything else is considered a literal, including [ ,:/.@#], chinese, japonese, and\n        // arabic characters.\n\n        default:\n          value = current;\n      }\n\n      if (typeof value === \"number\") {\n        value = numberFormatters[length](value);\n      }\n\n      dateField = dateFieldsMap[chr];\n      type = dateField ? dateField : \"literal\";\n      partsPush(parts, type, value);\n    });\n    return parts;\n  };\n\n  var dateFormatterFn = function dateFormatterFn(dateToPartsFormatter) {\n    return function dateFormatter(value) {\n      return partsJoin(dateToPartsFormatter(value));\n    };\n  };\n  /**\n   * isLeapYear( year )\n   *\n   * @year [Number]\n   *\n   * Returns an indication whether the specified year is a leap year.\n   */\n\n\n  var dateIsLeapYear = function dateIsLeapYear(year) {\n    return new Date(year, 1, 29).getMonth() === 1;\n  };\n  /**\n   * lastDayOfMonth( date )\n   *\n   * @date [Date]\n   *\n   * Return the last day of the given date's month\n   */\n\n\n  var dateLastDayOfMonth = function dateLastDayOfMonth(date) {\n    return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();\n  };\n  /**\n   * Differently from native date.setDate(), this function returns a date whose\n   * day remains inside the month boundaries. For example:\n   *\n   * setDate( FebDate, 31 ): a \"Feb 28\" date.\n   * setDate( SepDate, 31 ): a \"Sep 30\" date.\n   */\n\n\n  var dateSetDate = function dateSetDate(date, day) {\n    var lastDay = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();\n    date.setDate(day < 1 ? 1 : day < lastDay ? day : lastDay);\n  };\n  /**\n   * Differently from native date.setMonth(), this function adjusts date if\n   * needed, so final month is always the one set.\n   *\n   * setMonth( Jan31Date, 1 ): a \"Feb 28\" date.\n   * setDate( Jan31Date, 8 ): a \"Sep 30\" date.\n   */\n\n\n  var dateSetMonth = function dateSetMonth(date, month) {\n    var originalDate = date.getDate();\n    date.setDate(1);\n    date.setMonth(month);\n    dateSetDate(date, originalDate);\n  };\n\n  var outOfRange = function outOfRange(value, low, high) {\n    return value < low || value > high;\n  };\n  /**\n   * parse( value, tokens, properties )\n   *\n   * @value [String] string date.\n   *\n   * @tokens [Object] tokens returned by date/tokenizer.\n   *\n   * @properties [Object] output returned by date/tokenizer-properties.\n   *\n   * ref: http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n   */\n\n\n  var dateParse = function dateParse(value, tokens, properties) {\n    var amPm,\n        day,\n        daysOfYear,\n        month,\n        era,\n        hour,\n        hour12,\n        timezoneOffset,\n        valid,\n        YEAR = 0,\n        MONTH = 1,\n        DAY = 2,\n        HOUR = 3,\n        MINUTE = 4,\n        SECOND = 5,\n        MILLISECONDS = 6,\n        date = new Date(),\n        truncateAt = [],\n        units = [\"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\", \"milliseconds\"]; // Create globalize date with given timezone data.\n\n    if (properties.timeZoneData) {\n      date = new ZonedDateTime(date, properties.timeZoneData());\n    }\n\n    if (!tokens.length) {\n      return null;\n    }\n\n    valid = tokens.every(function (token) {\n      var century, chr, value, length;\n\n      if (token.type === \"literal\") {\n        // continue\n        return true;\n      }\n\n      chr = token.type.charAt(0);\n      length = token.type.length;\n\n      if (chr === \"j\") {\n        // Locale preferred hHKk.\n        // http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data\n        chr = properties.preferredTimeData;\n      }\n\n      switch (chr) {\n        // Era\n        case \"G\":\n          truncateAt.push(YEAR);\n          era = +token.value;\n          break;\n        // Year\n\n        case \"y\":\n          value = token.value;\n\n          if (length === 2) {\n            if (outOfRange(value, 0, 99)) {\n              return false;\n            } // mimic dojo/date/locale: choose century to apply, according to a sliding\n            // window of 80 years before and 20 years after present year.\n\n\n            century = Math.floor(date.getFullYear() / 100) * 100;\n            value += century;\n\n            if (value > date.getFullYear() + 20) {\n              value -= 100;\n            }\n          }\n\n          date.setFullYear(value);\n          truncateAt.push(YEAR);\n          break;\n\n        case \"Y\":\n          // Year in \"Week of Year\"\n          throw createErrorUnsupportedFeature({\n            feature: \"year pattern `\" + chr + \"`\"\n          });\n        // Quarter (skip)\n\n        case \"Q\":\n        case \"q\":\n          break;\n        // Month\n\n        case \"M\":\n        case \"L\":\n          if (length <= 2) {\n            value = token.value;\n          } else {\n            value = +token.value;\n          }\n\n          if (outOfRange(value, 1, 12)) {\n            return false;\n          } // Setting the month later so that we have the correct year and can determine\n          // the correct last day of February in case of leap year.\n\n\n          month = value;\n          truncateAt.push(MONTH);\n          break;\n        // Week (skip)\n\n        case \"w\": // Week of Year.\n\n        case \"W\":\n          // Week of Month.\n          break;\n        // Day\n\n        case \"d\":\n          day = token.value;\n          truncateAt.push(DAY);\n          break;\n\n        case \"D\":\n          daysOfYear = token.value;\n          truncateAt.push(DAY);\n          break;\n\n        case \"F\":\n          // Day of Week in month. eg. 2nd Wed in July.\n          // Skip\n          break;\n        // Week day\n\n        case \"e\":\n        case \"c\":\n        case \"E\":\n          // Skip.\n          // value = arrayIndexOf( dateWeekDays, token.value );\n          break;\n        // Period (AM or PM)\n\n        case \"a\":\n          amPm = token.value;\n          break;\n        // Hour\n\n        case \"h\":\n          // 1-12\n          value = token.value;\n\n          if (outOfRange(value, 1, 12)) {\n            return false;\n          }\n\n          hour = hour12 = true;\n          date.setHours(value === 12 ? 0 : value);\n          truncateAt.push(HOUR);\n          break;\n\n        case \"K\":\n          // 0-11\n          value = token.value;\n\n          if (outOfRange(value, 0, 11)) {\n            return false;\n          }\n\n          hour = hour12 = true;\n          date.setHours(value);\n          truncateAt.push(HOUR);\n          break;\n\n        case \"k\":\n          // 1-24\n          value = token.value;\n\n          if (outOfRange(value, 1, 24)) {\n            return false;\n          }\n\n          hour = true;\n          date.setHours(value === 24 ? 0 : value);\n          truncateAt.push(HOUR);\n          break;\n\n        case \"H\":\n          // 0-23\n          value = token.value;\n\n          if (outOfRange(value, 0, 23)) {\n            return false;\n          }\n\n          hour = true;\n          date.setHours(value);\n          truncateAt.push(HOUR);\n          break;\n        // Minute\n\n        case \"m\":\n          value = token.value;\n\n          if (outOfRange(value, 0, 59)) {\n            return false;\n          }\n\n          date.setMinutes(value);\n          truncateAt.push(MINUTE);\n          break;\n        // Second\n\n        case \"s\":\n          value = token.value;\n\n          if (outOfRange(value, 0, 59)) {\n            return false;\n          }\n\n          date.setSeconds(value);\n          truncateAt.push(SECOND);\n          break;\n\n        case \"A\":\n          date.setHours(0);\n          date.setMinutes(0);\n          date.setSeconds(0);\n\n        /* falls through */\n\n        case \"S\":\n          value = Math.round(token.value * Math.pow(10, 3 - length));\n          date.setMilliseconds(value);\n          truncateAt.push(MILLISECONDS);\n          break;\n        // Zone\n\n        case \"z\":\n        case \"Z\":\n        case \"O\":\n        case \"v\":\n        case \"V\":\n        case \"X\":\n        case \"x\":\n          if (typeof token.value === \"number\") {\n            timezoneOffset = token.value;\n          }\n\n          break;\n      }\n\n      return true;\n    });\n\n    if (!valid) {\n      return null;\n    } // 12-hour format needs AM or PM, 24-hour format doesn't, ie. return null\n    // if amPm && !hour12 || !amPm && hour12.\n\n\n    if (hour && !(!amPm ^ hour12)) {\n      return null;\n    }\n\n    if (era === 0) {\n      // 1 BC = year 0\n      date.setFullYear(date.getFullYear() * -1 + 1);\n    }\n\n    if (month !== undefined) {\n      dateSetMonth(date, month - 1);\n    }\n\n    if (day !== undefined) {\n      if (outOfRange(day, 1, dateLastDayOfMonth(date))) {\n        return null;\n      }\n\n      date.setDate(day);\n    } else if (daysOfYear !== undefined) {\n      if (outOfRange(daysOfYear, 1, dateIsLeapYear(date.getFullYear()) ? 366 : 365)) {\n        return null;\n      }\n\n      date.setMonth(0);\n      date.setDate(daysOfYear);\n    }\n\n    if (hour12 && amPm === \"pm\") {\n      date.setHours(date.getHours() + 12);\n    }\n\n    if (timezoneOffset !== undefined) {\n      date.setMinutes(date.getMinutes() + timezoneOffset - date.getTimezoneOffset());\n    } // Truncate date at the most precise unit defined. Eg.\n    // If value is \"12/31\", and pattern is \"MM/dd\":\n    // => new Date( <current Year>, 12, 31, 0, 0, 0, 0 );\n\n\n    truncateAt = Math.max.apply(null, truncateAt);\n    date = dateStartOf(date, units[truncateAt]); // Get date back from globalize date.\n\n    if (date instanceof ZonedDateTime) {\n      date = date.toDate();\n    }\n\n    return date;\n  };\n  /**\n   * tokenizer( value, numberParser, properties )\n   *\n   * @value [String] string date.\n   *\n   * @numberParser [Function]\n   *\n   * @properties [Object] output returned by date/tokenizer-properties.\n   *\n   * Returns an Array of tokens, eg. value \"5 o'clock PM\", pattern \"h 'o''clock' a\":\n   * [{\n   *   type: \"h\",\n   *   lexeme: \"5\"\n   * }, {\n   *   type: \"literal\",\n   *   lexeme: \" \"\n   * }, {\n   *   type: \"literal\",\n   *   lexeme: \"o'clock\"\n   * }, {\n   *   type: \"literal\",\n   *   lexeme: \" \"\n   * }, {\n   *   type: \"a\",\n   *   lexeme: \"PM\",\n   *   value: \"pm\"\n   * }]\n   *\n   * OBS: lexeme's are always String and may return invalid ranges depending of the token type.\n   * Eg. \"99\" for month number.\n   *\n   * Return an empty Array when not successfully parsed.\n   */\n\n\n  var dateTokenizer = function dateTokenizer(value, numberParser, properties) {\n    var digitsRe,\n        valid,\n        tokens = [],\n        widths = [\"abbreviated\", \"wide\", \"narrow\"];\n    digitsRe = properties.digitsRe;\n    value = looseMatching(value);\n    valid = properties.pattern.match(datePatternRe).every(function (current) {\n      var aux,\n          chr,\n          length,\n          numeric,\n          tokenRe,\n          token = {};\n\n      function hourFormatParse(tokenRe, numberParser) {\n        var aux,\n            isPositive,\n            match = value.match(tokenRe);\n\n        numberParser = numberParser || function (value) {\n          return +value;\n        };\n\n        if (!match) {\n          return false;\n        }\n\n        isPositive = match[1]; // hourFormat containing H only, e.g., `+H;-H`\n\n        if (match.length < 6) {\n          aux = isPositive ? 1 : 3;\n          token.value = numberParser(match[aux]) * 60; // hourFormat containing H and m, e.g., `+HHmm;-HHmm`\n        } else if (match.length < 10) {\n          aux = isPositive ? [1, 3] : [5, 7];\n          token.value = numberParser(match[aux[0]]) * 60 + numberParser(match[aux[1]]); // hourFormat containing H, m, and s e.g., `+HHmmss;-HHmmss`\n        } else {\n          aux = isPositive ? [1, 3, 5] : [7, 9, 11];\n          token.value = numberParser(match[aux[0]]) * 60 + numberParser(match[aux[1]]) + numberParser(match[aux[2]]) / 60;\n        }\n\n        if (isPositive) {\n          token.value *= -1;\n        }\n\n        return true;\n      }\n\n      function oneDigitIfLengthOne() {\n        if (length === 1) {\n          // Unicode equivalent to /\\d/\n          numeric = true;\n          return tokenRe = digitsRe;\n        }\n      }\n\n      function oneOrTwoDigitsIfLengthOne() {\n        if (length === 1) {\n          // Unicode equivalent to /\\d\\d?/\n          numeric = true;\n          return tokenRe = new RegExp(\"^(\" + digitsRe.source + \"){1,2}\");\n        }\n      }\n\n      function oneOrTwoDigitsIfLengthOneOrTwo() {\n        if (length === 1 || length === 2) {\n          // Unicode equivalent to /\\d\\d?/\n          numeric = true;\n          return tokenRe = new RegExp(\"^(\" + digitsRe.source + \"){1,2}\");\n        }\n      }\n\n      function twoDigitsIfLengthTwo() {\n        if (length === 2) {\n          // Unicode equivalent to /\\d\\d/\n          numeric = true;\n          return tokenRe = new RegExp(\"^(\" + digitsRe.source + \"){2}\");\n        }\n      } // Brute-force test every locale entry in an attempt to match the given value.\n      // Return the first found one (and set token accordingly), or null.\n\n\n      function lookup(path) {\n        var array = properties[path.join(\"/\")];\n\n        if (!array) {\n          return null;\n        } // array of pairs [key, value] sorted by desc value length.\n\n\n        array.some(function (item) {\n          var valueRe = item[1];\n\n          if (valueRe.test(value)) {\n            token.value = item[0];\n            tokenRe = item[1];\n            return true;\n          }\n        });\n        return null;\n      }\n\n      token.type = current;\n      chr = current.charAt(0);\n      length = current.length;\n\n      if (chr === \"Z\") {\n        // Z..ZZZ: same as \"xxxx\".\n        if (length < 4) {\n          chr = \"x\";\n          length = 4; // ZZZZ: same as \"OOOO\".\n        } else if (length < 5) {\n          chr = \"O\";\n          length = 4; // ZZZZZ: same as \"XXXXX\"\n        } else {\n          chr = \"X\";\n          length = 5;\n        }\n      }\n\n      if (chr === \"z\") {\n        if (properties.standardOrDaylightTzName) {\n          token.value = null;\n          tokenRe = properties.standardOrDaylightTzName;\n        }\n      } // v...vvv: \"{shortRegion}\", eg. \"PT\".\n      // vvvv: \"{regionName} {Time}\" or \"{regionName} {Time}\",\n      // e.g., \"Pacific Time\"\n      // http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n\n\n      if (chr === \"v\") {\n        if (properties.genericTzName) {\n          token.value = null;\n          tokenRe = properties.genericTzName; // Fall back to \"V\" format.\n        } else {\n          chr = \"V\";\n          length = 4;\n        }\n      }\n\n      if (chr === \"V\" && properties.timeZoneName) {\n        token.value = length === 2 ? properties.timeZoneName : null;\n        tokenRe = properties.timeZoneNameRe;\n      }\n\n      switch (chr) {\n        // Era\n        case \"G\":\n          lookup([\"gregorian/eras\", length <= 3 ? \"eraAbbr\" : length === 4 ? \"eraNames\" : \"eraNarrow\"]);\n          break;\n        // Year\n\n        case \"y\":\n        case \"Y\":\n          numeric = true; // number l=1:+, l=2:{2}, l=3:{3,}, l=4:{4,}, ...\n\n          if (length === 1) {\n            // Unicode equivalent to /\\d+/.\n            tokenRe = new RegExp(\"^(\" + digitsRe.source + \")+\");\n          } else if (length === 2) {\n            // Lenient parsing: there's no year pattern to indicate non-zero-padded 2-digits\n            // year, so parser accepts both zero-padded and non-zero-padded for `yy`.\n            //\n            // Unicode equivalent to /\\d\\d?/\n            tokenRe = new RegExp(\"^(\" + digitsRe.source + \"){1,2}\");\n          } else {\n            // Unicode equivalent to /\\d{length,}/\n            tokenRe = new RegExp(\"^(\" + digitsRe.source + \"){\" + length + \",}\");\n          }\n\n          break;\n        // Quarter\n\n        case \"Q\":\n        case \"q\":\n          // number l=1:{1}, l=2:{2}.\n          // lookup l=3...\n          oneDigitIfLengthOne() || twoDigitsIfLengthTwo() || lookup([\"gregorian/quarters\", chr === \"Q\" ? \"format\" : \"stand-alone\", widths[length - 3]]);\n          break;\n        // Month\n\n        case \"M\":\n        case \"L\":\n          // number l=1:{1,2}, l=2:{2}.\n          // lookup l=3...\n          //\n          // Lenient parsing: skeleton \"yMd\" (i.e., one M) may include MM for the pattern,\n          // therefore parser accepts both zero-padded and non-zero-padded for M and MM.\n          // Similar for L.\n          oneOrTwoDigitsIfLengthOneOrTwo() || lookup([\"gregorian/months\", chr === \"M\" ? \"format\" : \"stand-alone\", widths[length - 3]]);\n          break;\n        // Day\n\n        case \"D\":\n          // number {l,3}.\n          if (length <= 3) {\n            // Equivalent to /\\d{length,3}/\n            numeric = true;\n            tokenRe = new RegExp(\"^(\" + digitsRe.source + \"){\" + length + \",3}\");\n          }\n\n          break;\n\n        case \"W\":\n        case \"F\":\n          // number l=1:{1}.\n          oneDigitIfLengthOne();\n          break;\n        // Week day\n\n        case \"e\":\n        case \"c\":\n          // number l=1:{1}, l=2:{2}.\n          // lookup for length >=3.\n          if (length <= 2) {\n            oneDigitIfLengthOne() || twoDigitsIfLengthTwo();\n            break;\n          }\n\n        /* falls through */\n\n        case \"E\":\n          if (length === 6) {\n            // Note: if short day names are not explicitly specified, abbreviated day\n            // names are used instead http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras\n            lookup([\"gregorian/days\", [chr === \"c\" ? \"stand-alone\" : \"format\"], \"short\"]) || lookup([\"gregorian/days\", [chr === \"c\" ? \"stand-alone\" : \"format\"], \"abbreviated\"]);\n          } else {\n            lookup([\"gregorian/days\", [chr === \"c\" ? \"stand-alone\" : \"format\"], widths[length < 3 ? 0 : length - 3]]);\n          }\n\n          break;\n        // Period (AM or PM)\n\n        case \"a\":\n          lookup([\"gregorian/dayPeriods/format/wide\"]);\n          break;\n        // Week\n\n        case \"w\":\n          // number l1:{1,2}, l2:{2}.\n          oneOrTwoDigitsIfLengthOne() || twoDigitsIfLengthTwo();\n          break;\n        // Day, Hour, Minute, or Second\n\n        case \"d\":\n        case \"h\":\n        case \"H\":\n        case \"K\":\n        case \"k\":\n        case \"j\":\n        case \"m\":\n        case \"s\":\n          // number l1:{1,2}, l2:{2}.\n          //\n          // Lenient parsing:\n          // - skeleton \"hms\" (i.e., one m) always includes mm for the pattern, i.e., it's\n          //   impossible to use a different skeleton to parse non-zero-padded minutes,\n          //   therefore parser accepts both zero-padded and non-zero-padded for m. Similar\n          //   for seconds s.\n          // - skeleton \"hms\" (i.e., one h) may include h or hh for the pattern, i.e., it's\n          //   impossible to use a different skeleton to parser non-zero-padded hours for some\n          //   locales, therefore parser accepts both zero-padded and non-zero-padded for h.\n          //   Similar for d (in skeleton yMd).\n          oneOrTwoDigitsIfLengthOneOrTwo();\n          break;\n\n        case \"S\":\n          // number {l}.\n          // Unicode equivalent to /\\d{length}/\n          numeric = true;\n          tokenRe = new RegExp(\"^(\" + digitsRe.source + \"){\" + length + \"}\");\n          break;\n\n        case \"A\":\n          // number {l+5}.\n          // Unicode equivalent to /\\d{length+5}/\n          numeric = true;\n          tokenRe = new RegExp(\"^(\" + digitsRe.source + \"){\" + (length + 5) + \"}\");\n          break;\n        // Zone\n\n        case \"v\":\n        case \"V\":\n        case \"z\":\n          if (tokenRe && tokenRe.test(value)) {\n            break;\n          }\n\n          if (chr === \"V\" && length === 2) {\n            break;\n          }\n\n        /* falls through */\n\n        case \"O\":\n          // O: \"{gmtFormat}+H;{gmtFormat}-H\" or \"{gmtZeroFormat}\", eg. \"GMT-8\" or \"GMT\".\n          // OOOO: \"{gmtFormat}{hourFormat}\" or \"{gmtZeroFormat}\", eg. \"GMT-08:00\" or \"GMT\".\n          if (value === properties[\"timeZoneNames/gmtZeroFormat\"]) {\n            token.value = 0;\n            tokenRe = properties[\"timeZoneNames/gmtZeroFormatRe\"];\n          } else {\n            aux = properties[\"timeZoneNames/hourFormat\"].some(function (hourFormatRe) {\n              if (hourFormatParse(hourFormatRe, numberParser)) {\n                tokenRe = hourFormatRe;\n                return true;\n              }\n            });\n\n            if (!aux) {\n              return null;\n            }\n          }\n\n          break;\n\n        case \"X\":\n          // Same as x*, except it uses \"Z\" for zero offset.\n          if (value === \"Z\") {\n            token.value = 0;\n            tokenRe = /^Z/;\n            break;\n          }\n\n        /* falls through */\n\n        case \"x\":\n          // x: hourFormat(\"+HH[mm];-HH[mm]\")\n          // xx: hourFormat(\"+HHmm;-HHmm\")\n          // xxx: hourFormat(\"+HH:mm;-HH:mm\")\n          // xxxx: hourFormat(\"+HHmm[ss];-HHmm[ss]\")\n          // xxxxx: hourFormat(\"+HH:mm[:ss];-HH:mm[:ss]\")\n          aux = properties.x.some(function (hourFormatRe) {\n            if (hourFormatParse(hourFormatRe)) {\n              tokenRe = hourFormatRe;\n              return true;\n            }\n          });\n\n          if (!aux) {\n            return null;\n          }\n\n          break;\n\n        case \"'\":\n          token.type = \"literal\";\n          tokenRe = new RegExp(\"^\" + regexpEscape(removeLiteralQuotes(current)));\n          break;\n\n        default:\n          token.type = \"literal\";\n          tokenRe = new RegExp(\"^\" + regexpEscape(current));\n      }\n\n      if (!tokenRe) {\n        return false;\n      } // Get lexeme and consume it.\n\n\n      value = value.replace(tokenRe, function (lexeme) {\n        token.lexeme = lexeme;\n\n        if (numeric) {\n          token.value = numberParser(lexeme);\n        }\n\n        return \"\";\n      });\n\n      if (!token.lexeme) {\n        return false;\n      }\n\n      if (numeric && isNaN(token.value)) {\n        return false;\n      }\n\n      tokens.push(token);\n      return true;\n    });\n\n    if (value !== \"\") {\n      valid = false;\n    }\n\n    return valid ? tokens : [];\n  };\n\n  var dateParserFn = function dateParserFn(numberParser, parseProperties, tokenizerProperties) {\n    return function dateParser(value) {\n      var tokens;\n      validateParameterPresence(value, \"value\");\n      validateParameterTypeString(value, \"value\");\n      tokens = dateTokenizer(value, numberParser, tokenizerProperties);\n      return dateParse(value, tokens, parseProperties) || null;\n    };\n  };\n\n  var dateToPartsFormatterFn = function dateToPartsFormatterFn(numberFormatters, properties) {\n    return function dateToPartsFormatter(value) {\n      validateParameterPresence(value, \"value\");\n      validateParameterTypeDate(value, \"value\");\n      return dateFormat(value, numberFormatters, properties);\n    };\n  };\n\n  Globalize._dateFormat = dateFormat;\n  Globalize._dateFormatterFn = dateFormatterFn;\n  Globalize._dateParser = dateParse;\n  Globalize._dateParserFn = dateParserFn;\n  Globalize._dateTokenizer = dateTokenizer;\n  Globalize._dateToPartsFormatterFn = dateToPartsFormatterFn;\n  Globalize._validateParameterTypeDate = validateParameterTypeDate;\n\n  function optionsHasStyle(options) {\n    return options.skeleton !== undefined || options.date !== undefined || options.time !== undefined || options.datetime !== undefined || options.raw !== undefined;\n  }\n\n  Globalize.dateFormatter = Globalize.prototype.dateFormatter = function (options) {\n    options = options || {};\n\n    if (!optionsHasStyle(options)) {\n      options.skeleton = \"yMd\";\n    }\n\n    return Globalize[runtimeKey(\"dateFormatter\", this._locale, [options])];\n  };\n\n  Globalize.dateToPartsFormatter = Globalize.prototype.dateToPartsFormatter = function (options) {\n    options = options || {};\n\n    if (!optionsHasStyle(options)) {\n      options.skeleton = \"yMd\";\n    }\n\n    return Globalize[runtimeKey(\"dateToPartsFormatter\", this._locale, [options])];\n  };\n\n  Globalize.dateParser = Globalize.prototype.dateParser = function (options) {\n    options = options || {};\n\n    if (!optionsHasStyle(options)) {\n      options.skeleton = \"yMd\";\n    }\n\n    return Globalize[runtimeKey(\"dateParser\", this._locale, [options])];\n  };\n\n  Globalize.formatDate = Globalize.prototype.formatDate = function (value, options) {\n    validateParameterPresence(value, \"value\");\n    validateParameterTypeDate(value, \"value\");\n    return this.dateFormatter(options)(value);\n  };\n\n  Globalize.formatDateToParts = Globalize.prototype.formatDateToParts = function (value, options) {\n    validateParameterPresence(value, \"value\");\n    validateParameterTypeDate(value, \"value\");\n    return this.dateToPartsFormatter(options)(value);\n  };\n\n  Globalize.parseDate = Globalize.prototype.parseDate = function (value, options) {\n    validateParameterPresence(value, \"value\");\n    validateParameterTypeString(value, \"value\");\n    return this.dateParser(options)(value);\n  };\n\n  return Globalize;\n});","map":{"version":3,"sources":["/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/globalize/dist/globalize-runtime/date.js"],"names":["root","factory","define","amd","exports","module","require","Globalize","createErrorUnsupportedFeature","_createErrorUnsupportedFeature","looseMatching","_looseMatching","partsJoin","_partsJoin","partsPush","_partsPush","regexpEscape","_regexpEscape","removeLiteralQuotes","_removeLiteralQuotes","runtimeKey","_runtimeKey","stringPad","_stringPad","validateParameterPresence","_validateParameterPresence","validateParameterType","_validateParameterType","validateParameterTypeString","_validateParameterTypeString","validateParameterTypeDate","value","name","undefined","Date","ZonedDateTime","definePrivateProperty","object","property","Object","defineProperty","getUntilsIndex","original","untils","index","originalTime","getTime","length","setWrap","fn","offset1","getTimezoneOffset","ret","setTime","offset2","setMinutes","getMinutes","date","timeZoneData","offsets","isdsts","Error","local","prototype","clone","forEach","method","utcMethod","substr","valueOf","time","isDST","Boolean","inspect","abbrs","toISOString","replace","toDate","dateDayOfWeek","firstDay","getDay","dateDistanceInDays","from","to","inDays","dateStartOf","unit","setMonth","setDate","setHours","setSeconds","setMilliseconds","dateDayOfYear","Math","floor","objectInvert","key","keys","reduce","newObject","dateFieldsMap","split","symbol","dateMillisecondsInDay","datePatternRe","dateTimezoneHourFormat","format","timeSeparator","formatNumber","absOffset","offset","abs","match","dateWeekDays","dateFormat","numberFormatters","properties","parts","pattern","current","aux","dateField","type","chr","charAt","preferredTime","daylightTzName","standardTzName","eras","getFullYear","String","getDate","minDays","ceil","getMonth","quarters","months","days","dayPeriods","getHours","getSeconds","round","getMilliseconds","pow","genericTzName","timeZoneName","gmtZeroFormat","hourFormat","gmtFormat","dateFormatterFn","dateToPartsFormatter","dateFormatter","dateIsLeapYear","year","dateLastDayOfMonth","dateSetDate","day","lastDay","dateSetMonth","month","originalDate","outOfRange","low","high","dateParse","tokens","amPm","daysOfYear","era","hour","hour12","timezoneOffset","valid","YEAR","MONTH","DAY","HOUR","MINUTE","SECOND","MILLISECONDS","truncateAt","units","every","token","century","preferredTimeData","push","setFullYear","feature","max","apply","dateTokenizer","numberParser","digitsRe","widths","numeric","tokenRe","hourFormatParse","isPositive","oneDigitIfLengthOne","oneOrTwoDigitsIfLengthOne","RegExp","source","oneOrTwoDigitsIfLengthOneOrTwo","twoDigitsIfLengthTwo","lookup","path","array","join","some","item","valueRe","test","standardOrDaylightTzName","timeZoneNameRe","hourFormatRe","x","lexeme","isNaN","dateParserFn","parseProperties","tokenizerProperties","dateParser","dateToPartsFormatterFn","_dateFormat","_dateFormatterFn","_dateParser","_dateParserFn","_dateTokenizer","_dateToPartsFormatterFn","_validateParameterTypeDate","optionsHasStyle","options","skeleton","datetime","raw","_locale","formatDate","formatDateToParts","parseDate"],"mappings":"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","sourcesContent":["/**\n * Globalize Runtime v1.5.0\n *\n * http://github.com/jquery/globalize\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2020-03-25T12:19Z\n */\n/*!\n * Globalize Runtime v1.5.0 2020-03-25T12:19Z Released under the MIT license\n * http://git.io/TrdQbw\n */\n(function( root, factory ) {\n\n\t\"use strict\";\n\n\t// UMD returnExports\n\tif ( typeof define === \"function\" && define.amd ) {\n\n\t\t// AMD\n\t\tdefine([\n\t\t\t\"../globalize-runtime\",\n\t\t\t\"./number\"\n\t\t], factory );\n\t} else if ( typeof exports === \"object\" ) {\n\n\t\t// Node, CommonJS\n\t\tmodule.exports = factory(\n\t\t\trequire( \"../globalize-runtime\" ),\n\t\t\trequire( \"./number\" )\n\t\t);\n\t} else {\n\n\t\t// Extend global\n\t\tfactory( root.Globalize );\n\t}\n}(this, function( Globalize ) {\n\n\n\nvar createErrorUnsupportedFeature = Globalize._createErrorUnsupportedFeature,\n\tlooseMatching = Globalize._looseMatching,\n\tpartsJoin = Globalize._partsJoin,\n\tpartsPush = Globalize._partsPush,\n\tregexpEscape = Globalize._regexpEscape,\n\tremoveLiteralQuotes = Globalize._removeLiteralQuotes,\n\truntimeKey = Globalize._runtimeKey,\n\tstringPad = Globalize._stringPad,\n\tvalidateParameterPresence = Globalize._validateParameterPresence,\n\tvalidateParameterType = Globalize._validateParameterType,\n\tvalidateParameterTypeString = Globalize._validateParameterTypeString;\n\n\nvar validateParameterTypeDate = function( value, name ) {\n\tvalidateParameterType( value, name, value === undefined || value instanceof Date, \"Date\" );\n};\n\n\nvar ZonedDateTime = (function() {\nfunction definePrivateProperty(object, property, value) {\n  Object.defineProperty(object, property, {\n    value: value\n  });\n}\n\nfunction getUntilsIndex(original, untils) {\n  var index = 0;\n  var originalTime = original.getTime();\n\n  // TODO Should we do binary search for improved performance?\n  while (index < untils.length - 1 && originalTime >= untils[index]) {\n    index++;\n  }\n  return index;\n}\n\nfunction setWrap(fn) {\n  var offset1 = this.getTimezoneOffset();\n  var ret = fn();\n  this.original.setTime(new Date(this.getTime()));\n  var offset2 = this.getTimezoneOffset();\n  if (offset2 - offset1) {\n    this.original.setMinutes(this.original.getMinutes() + offset2 - offset1);\n  }\n  return ret;\n}\n\nvar ZonedDateTime = function(date, timeZoneData) {\n  definePrivateProperty(this, \"original\", new Date(date.getTime()));\n  definePrivateProperty(this, \"local\", new Date(date.getTime()));\n  definePrivateProperty(this, \"timeZoneData\", timeZoneData);\n  definePrivateProperty(this, \"setWrap\", setWrap);\n  if (!(timeZoneData.untils && timeZoneData.offsets && timeZoneData.isdsts)) {\n    throw new Error(\"Invalid IANA data\");\n  }\n  this.setTime(this.local.getTime() - this.getTimezoneOffset() * 60 * 1000);\n};\n\nZonedDateTime.prototype.clone = function() {\n  return new ZonedDateTime(this.original, this.timeZoneData);\n};\n\n// Date field getters.\n[\"getFullYear\", \"getMonth\", \"getDate\", \"getDay\", \"getHours\", \"getMinutes\",\n\"getSeconds\", \"getMilliseconds\"].forEach(function(method) {\n  // Corresponding UTC method, e.g., \"getUTCFullYear\" if method === \"getFullYear\".\n  var utcMethod = \"getUTC\" + method.substr(3);\n  ZonedDateTime.prototype[method] = function() {\n    return this.local[utcMethod]();\n  };\n});\n\n// Note: Define .valueOf = .getTime for arithmetic operations like date1 - date2.\nZonedDateTime.prototype.valueOf =\nZonedDateTime.prototype.getTime = function() {\n  return this.local.getTime() + this.getTimezoneOffset() * 60 * 1000;\n};\n\nZonedDateTime.prototype.getTimezoneOffset = function() {\n  var index = getUntilsIndex(this.original, this.timeZoneData.untils);\n  return this.timeZoneData.offsets[index];\n};\n\n// Date field setters.\n[\"setFullYear\", \"setMonth\", \"setDate\", \"setHours\", \"setMinutes\", \"setSeconds\", \"setMilliseconds\"].forEach(function(method) {\n  // Corresponding UTC method, e.g., \"setUTCFullYear\" if method === \"setFullYear\".\n  var utcMethod = \"setUTC\" + method.substr(3);\n  ZonedDateTime.prototype[method] = function(value) {\n    var local = this.local;\n    // Note setWrap is needed for seconds and milliseconds just because\n    // abs(value) could be >= a minute.\n    return this.setWrap(function() {\n      return local[utcMethod](value);\n    });\n  };\n});\n\nZonedDateTime.prototype.setTime = function(time) {\n  return this.local.setTime(time);\n};\n\nZonedDateTime.prototype.isDST = function() {\n  var index = getUntilsIndex(this.original, this.timeZoneData.untils);\n  return Boolean(this.timeZoneData.isdsts[index]);\n};\n\nZonedDateTime.prototype.inspect = function() {\n  var index = getUntilsIndex(this.original, this.timeZoneData.untils);\n  var abbrs = this.timeZoneData.abbrs;\n  return this.local.toISOString().replace(/Z$/, \"\") + \" \" +\n    (abbrs && abbrs[index] + \" \" || (this.getTimezoneOffset() * -1) + \" \") +\n    (this.isDST() ? \"(daylight savings)\" : \"\");\n};\n\nZonedDateTime.prototype.toDate = function() {\n  return new Date(this.getTime());\n};\n\n// Type cast getters.\n[\"toISOString\", \"toJSON\", \"toUTCString\"].forEach(function(method) {\n  ZonedDateTime.prototype[method] = function() {\n    return this.toDate()[method]();\n  };\n});\n\nreturn ZonedDateTime;\n}());\n\n\n/**\n * dayOfWeek( date, firstDay )\n *\n * @date\n *\n * @firstDay the result of `dateFirstDayOfWeek( cldr )`\n *\n * Return the day of the week normalized by the territory's firstDay [0-6].\n * Eg for \"mon\":\n * - return 0 if territory is GB, or BR, or DE, or FR (week starts on \"mon\");\n * - return 1 if territory is US (week starts on \"sun\");\n * - return 2 if territory is EG (week starts on \"sat\");\n */\nvar dateDayOfWeek = function( date, firstDay ) {\n\treturn ( date.getDay() - firstDay + 7 ) % 7;\n};\n\n\n\n\n/**\n * distanceInDays( from, to )\n *\n * Return the distance in days between from and to Dates.\n */\nvar dateDistanceInDays = function( from, to ) {\n\tvar inDays = 864e5;\n\treturn ( to.getTime() - from.getTime() ) / inDays;\n};\n\n\n\n\n/**\n * startOf changes the input to the beginning of the given unit.\n *\n * For example, starting at the start of a day, resets hours, minutes\n * seconds and milliseconds to 0. Starting at the month does the same, but\n * also sets the date to 1.\n *\n * Returns the modified date\n */\nvar dateStartOf = function( date, unit ) {\n\tdate = date instanceof ZonedDateTime ? date.clone() : new Date( date.getTime() );\n\tswitch ( unit ) {\n\t\tcase \"year\":\n\t\t\tdate.setMonth( 0 );\n\t\t/* falls through */\n\t\tcase \"month\":\n\t\t\tdate.setDate( 1 );\n\t\t/* falls through */\n\t\tcase \"day\":\n\t\t\tdate.setHours( 0 );\n\t\t/* falls through */\n\t\tcase \"hour\":\n\t\t\tdate.setMinutes( 0 );\n\t\t/* falls through */\n\t\tcase \"minute\":\n\t\t\tdate.setSeconds( 0 );\n\t\t/* falls through */\n\t\tcase \"second\":\n\t\t\tdate.setMilliseconds( 0 );\n\t}\n\treturn date;\n};\n\n\n\n\n/**\n * dayOfYear\n *\n * Return the distance in days of the date to the begin of the year [0-d].\n */\nvar dateDayOfYear = function( date ) {\n\treturn Math.floor( dateDistanceInDays( dateStartOf( date, \"year\" ), date ) );\n};\n\n\n\n\n/**\n * Returns a new object created by using `object`'s values as keys, and the keys as values.\n */\nvar objectInvert = function( object, fn ) {\n\tfn = fn || function( object, key, value ) {\n\t\tobject[ value ] = key;\n\t\treturn object;\n\t};\n\treturn Object.keys( object ).reduce(function( newObject, key ) {\n\t\treturn fn( newObject, key, object[ key ] );\n\t}, {});\n};\n\n\n\n\n// Invert key and values, e.g., {\"year\": \"yY\"} ==> {\"y\": \"year\", \"Y\": \"year\"}\nvar dateFieldsMap = objectInvert({\n\t\"era\": \"G\",\n\t\"year\": \"yY\",\n\t\"quarter\": \"qQ\",\n\t\"month\": \"ML\",\n\t\"week\": \"wW\",\n\t\"day\": \"dDF\",\n\t\"weekday\": \"ecE\",\n\t\"dayperiod\": \"a\",\n\t\"hour\": \"hHkK\",\n\t\"minute\": \"m\",\n\t\"second\": \"sSA\",\n\t\"zone\": \"zvVOxX\"\n}, function( object, key, value ) {\n\tvalue.split( \"\" ).forEach(function( symbol ) {\n\t\tobject[ symbol ] = key;\n\t});\n\treturn object;\n});\n\n\n\n\n/**\n * millisecondsInDay\n */\nvar dateMillisecondsInDay = function( date ) {\n\n\t// TODO Handle daylight savings discontinuities\n\treturn date - dateStartOf( date, \"day\" );\n};\n\n\n\n\nvar datePatternRe = ( /([a-z])\\1*|'([^']|'')+'|''|./ig );\n\n\n\n\n/**\n * hourFormat( date, format, timeSeparator, formatNumber )\n *\n * Return date's timezone offset according to the format passed.\n * Eg for format when timezone offset is 180:\n * - \"+H;-H\": -3\n * - \"+HHmm;-HHmm\": -0300\n * - \"+HH:mm;-HH:mm\": -03:00\n * - \"+HH:mm:ss;-HH:mm:ss\": -03:00:00\n */\nvar dateTimezoneHourFormat = function( date, format, timeSeparator, formatNumber ) {\n\tvar absOffset,\n\t\toffset = date.getTimezoneOffset();\n\n\tabsOffset = Math.abs( offset );\n\tformatNumber = formatNumber || {\n\t\t1: function( value ) {\n\t\t\treturn stringPad( value, 1 );\n\t\t},\n\t\t2: function( value ) {\n\t\t\treturn stringPad( value, 2 );\n\t\t}\n\t};\n\n\treturn format\n\n\t\t// Pick the correct sign side (+ or -).\n\t\t.split( \";\" )[ offset > 0 ? 1 : 0 ]\n\n\t\t// Localize time separator\n\t\t.replace( \":\", timeSeparator )\n\n\t\t// Update hours offset.\n\t\t.replace( /HH?/, function( match ) {\n\t\t\treturn formatNumber[ match.length ]( Math.floor( absOffset / 60 ) );\n\t\t})\n\n\t\t// Update minutes offset and return.\n\t\t.replace( /mm/, function() {\n\t\t\treturn formatNumber[ 2 ]( Math.floor( absOffset % 60 ) );\n\t\t})\n\n\t\t// Update minutes offset and return.\n\t\t.replace( /ss/, function() {\n\t\t\treturn formatNumber[ 2 ]( Math.floor( absOffset % 1 * 60 ) );\n\t\t});\n};\n\n\n\n\nvar dateWeekDays = [ \"sun\", \"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\" ];\n\n\n\n\n/**\n * format( date, properties )\n *\n * @date [Date instance].\n *\n * @properties\n *\n * TODO Support other calendar types.\n *\n * Disclosure: this function borrows excerpts of dojo/date/locale.\n */\nvar dateFormat = function( date, numberFormatters, properties ) {\n\tvar parts = [];\n\n\tvar timeSeparator = properties.timeSeparator;\n\n\t// create globalize date with given timezone data\n\tif ( properties.timeZoneData ) {\n\t\tdate = new ZonedDateTime( date, properties.timeZoneData() );\n\t}\n\n\tproperties.pattern.replace( datePatternRe, function( current ) {\n\t\tvar aux, dateField, type, value,\n\t\t\tchr = current.charAt( 0 ),\n\t\t\tlength = current.length;\n\n\t\tif ( chr === \"j\" ) {\n\n\t\t\t// Locale preferred hHKk.\n\t\t\t// http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data\n\t\t\tchr = properties.preferredTime;\n\t\t}\n\n\t\tif ( chr === \"Z\" ) {\n\n\t\t\t// Z..ZZZ: same as \"xxxx\".\n\t\t\tif ( length < 4 ) {\n\t\t\t\tchr = \"x\";\n\t\t\t\tlength = 4;\n\n\t\t\t// ZZZZ: same as \"OOOO\".\n\t\t\t} else if ( length < 5 ) {\n\t\t\t\tchr = \"O\";\n\t\t\t\tlength = 4;\n\n\t\t\t// ZZZZZ: same as \"XXXXX\"\n\t\t\t} else {\n\t\t\t\tchr = \"X\";\n\t\t\t\tlength = 5;\n\t\t\t}\n\t\t}\n\n\t\t// z...zzz: \"{shortRegion}\", e.g., \"PST\" or \"PDT\".\n\t\t// zzzz: \"{regionName} {Standard Time}\" or \"{regionName} {Daylight Time}\",\n\t\t//       e.g., \"Pacific Standard Time\" or \"Pacific Daylight Time\".\n\t\tif ( chr === \"z\" ) {\n\t\t\tif ( date.isDST ) {\n\t\t\t\tvalue = date.isDST() ? properties.daylightTzName : properties.standardTzName;\n\t\t\t}\n\n\t\t\t// Fall back to \"O\" format.\n\t\t\tif ( !value ) {\n\t\t\t\tchr = \"O\";\n\t\t\t\tif ( length < 4 ) {\n\t\t\t\t\tlength = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tswitch ( chr ) {\n\n\t\t\t// Era\n\t\t\tcase \"G\":\n\t\t\t\tvalue = properties.eras[ date.getFullYear() < 0 ? 0 : 1 ];\n\t\t\t\tbreak;\n\n\t\t\t// Year\n\t\t\tcase \"y\":\n\n\t\t\t\t// Plain year.\n\t\t\t\t// The length specifies the padding, but for two letters it also specifies the\n\t\t\t\t// maximum length.\n\t\t\t\tvalue = date.getFullYear();\n\t\t\t\tif ( length === 2 ) {\n\t\t\t\t\tvalue = String( value );\n\t\t\t\t\tvalue = +value.substr( value.length - 2 );\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"Y\":\n\n\t\t\t\t// Year in \"Week of Year\"\n\t\t\t\t// The length specifies the padding, but for two letters it also specifies the\n\t\t\t\t// maximum length.\n\t\t\t\t// yearInWeekofYear = date + DaysInAWeek - (dayOfWeek - firstDay) - minDays\n\t\t\t\tvalue = new Date( date.getTime() );\n\t\t\t\tvalue.setDate(\n\t\t\t\t\tvalue.getDate() + 7 -\n\t\t\t\t\tdateDayOfWeek( date, properties.firstDay ) -\n\t\t\t\t\tproperties.firstDay -\n\t\t\t\t\tproperties.minDays\n\t\t\t\t);\n\t\t\t\tvalue = value.getFullYear();\n\t\t\t\tif ( length === 2 ) {\n\t\t\t\t\tvalue = String( value );\n\t\t\t\t\tvalue = +value.substr( value.length - 2 );\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Quarter\n\t\t\tcase \"Q\":\n\t\t\tcase \"q\":\n\t\t\t\tvalue = Math.ceil( ( date.getMonth() + 1 ) / 3 );\n\t\t\t\tif ( length > 2 ) {\n\t\t\t\t\tvalue = properties.quarters[ chr ][ length ][ value ];\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Month\n\t\t\tcase \"M\":\n\t\t\tcase \"L\":\n\t\t\t\tvalue = date.getMonth() + 1;\n\t\t\t\tif ( length > 2 ) {\n\t\t\t\t\tvalue = properties.months[ chr ][ length ][ value ];\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Week\n\t\t\tcase \"w\":\n\n\t\t\t\t// Week of Year.\n\t\t\t\t// woy = ceil( ( doy + dow of 1/1 ) / 7 ) - minDaysStuff ? 1 : 0.\n\t\t\t\t// TODO should pad on ww? Not documented, but I guess so.\n\t\t\t\tvalue = dateDayOfWeek( dateStartOf( date, \"year\" ), properties.firstDay );\n\t\t\t\tvalue = Math.ceil( ( dateDayOfYear( date ) + value ) / 7 ) -\n\t\t\t\t\t( 7 - value >= properties.minDays ? 0 : 1 );\n\t\t\t\tbreak;\n\n\t\t\tcase \"W\":\n\n\t\t\t\t// Week of Month.\n\t\t\t\t// wom = ceil( ( dom + dow of `1/month` ) / 7 ) - minDaysStuff ? 1 : 0.\n\t\t\t\tvalue = dateDayOfWeek( dateStartOf( date, \"month\" ), properties.firstDay );\n\t\t\t\tvalue = Math.ceil( ( date.getDate() + value ) / 7 ) -\n\t\t\t\t\t( 7 - value >= properties.minDays ? 0 : 1 );\n\t\t\t\tbreak;\n\n\t\t\t// Day\n\t\t\tcase \"d\":\n\t\t\t\tvalue = date.getDate();\n\t\t\t\tbreak;\n\n\t\t\tcase \"D\":\n\t\t\t\tvalue = dateDayOfYear( date ) + 1;\n\t\t\t\tbreak;\n\n\t\t\tcase \"F\":\n\n\t\t\t\t// Day of Week in month. eg. 2nd Wed in July.\n\t\t\t\tvalue = Math.floor( date.getDate() / 7 ) + 1;\n\t\t\t\tbreak;\n\n\t\t\t// Week day\n\t\t\tcase \"e\":\n\t\t\tcase \"c\":\n\t\t\t\tif ( length <= 2 ) {\n\n\t\t\t\t\t// Range is [1-7] (deduced by example provided on documentation)\n\t\t\t\t\t// TODO Should pad with zeros (not specified in the docs)?\n\t\t\t\t\tvalue = dateDayOfWeek( date, properties.firstDay ) + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* falls through */\n\t\t\tcase \"E\":\n\t\t\t\tvalue = dateWeekDays[ date.getDay() ];\n\t\t\t\tvalue = properties.days[ chr ][ length ][ value ];\n\t\t\t\tbreak;\n\n\t\t\t// Period (AM or PM)\n\t\t\tcase \"a\":\n\t\t\t\tvalue = properties.dayPeriods[ date.getHours() < 12 ? \"am\" : \"pm\" ];\n\t\t\t\tbreak;\n\n\t\t\t// Hour\n\t\t\tcase \"h\": // 1-12\n\t\t\t\tvalue = ( date.getHours() % 12 ) || 12;\n\t\t\t\tbreak;\n\n\t\t\tcase \"H\": // 0-23\n\t\t\t\tvalue = date.getHours();\n\t\t\t\tbreak;\n\n\t\t\tcase \"K\": // 0-11\n\t\t\t\tvalue = date.getHours() % 12;\n\t\t\t\tbreak;\n\n\t\t\tcase \"k\": // 1-24\n\t\t\t\tvalue = date.getHours() || 24;\n\t\t\t\tbreak;\n\n\t\t\t// Minute\n\t\t\tcase \"m\":\n\t\t\t\tvalue = date.getMinutes();\n\t\t\t\tbreak;\n\n\t\t\t// Second\n\t\t\tcase \"s\":\n\t\t\t\tvalue = date.getSeconds();\n\t\t\t\tbreak;\n\n\t\t\tcase \"S\":\n\t\t\t\tvalue = Math.round( date.getMilliseconds() * Math.pow( 10, length - 3 ) );\n\t\t\t\tbreak;\n\n\t\t\tcase \"A\":\n\t\t\t\tvalue = Math.round( dateMillisecondsInDay( date ) * Math.pow( 10, length - 3 ) );\n\t\t\t\tbreak;\n\n\t\t\t// Zone\n\t\t\tcase \"z\":\n\t\t\t\tbreak;\n\n\t\t\tcase \"v\":\n\n\t\t\t\t// v...vvv: \"{shortRegion}\", eg. \"PT\".\n\t\t\t\t// vvvv: \"{regionName} {Time}\",\n\t\t\t\t//       e.g., \"Pacific Time\".\n\t\t\t\tif ( properties.genericTzName ) {\n\t\t\t\t\tvalue = properties.genericTzName;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* falls through */\n\t\t\tcase \"V\":\n\n\t\t\t\t//VVVV: \"{explarCity} {Time}\", e.g., \"Los Angeles Time\"\n\t\t\t\tif ( properties.timeZoneName ) {\n\t\t\t\t\tvalue = properties.timeZoneName;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ( current === \"v\" ) {\n\t\t\t\t\tlength = 1;\n\t\t\t\t}\n\n\t\t\t/* falls through */\n\t\t\tcase \"O\":\n\n\t\t\t\t// O: \"{gmtFormat}+H;{gmtFormat}-H\" or \"{gmtZeroFormat}\", eg. \"GMT-8\" or \"GMT\".\n\t\t\t\t// OOOO: \"{gmtFormat}{hourFormat}\" or \"{gmtZeroFormat}\", eg. \"GMT-08:00\" or \"GMT\".\n\t\t\t\tif ( date.getTimezoneOffset() === 0 ) {\n\t\t\t\t\tvalue = properties.gmtZeroFormat;\n\t\t\t\t} else {\n\n\t\t\t\t\t// If O..OOO and timezone offset has non-zero minutes, show minutes.\n\t\t\t\t\tif ( length < 4 ) {\n\t\t\t\t\t\taux = date.getTimezoneOffset();\n\t\t\t\t\t\taux = properties.hourFormat[ aux % 60 - aux % 1 === 0 ? 0 : 1 ];\n\t\t\t\t\t} else {\n\t\t\t\t\t\taux = properties.hourFormat;\n\t\t\t\t\t}\n\n\t\t\t\t\tvalue = dateTimezoneHourFormat(\n\t\t\t\t\t\tdate,\n\t\t\t\t\t\taux,\n\t\t\t\t\t\ttimeSeparator,\n\t\t\t\t\t\tnumberFormatters\n\t\t\t\t\t);\n\t\t\t\t\tvalue = properties.gmtFormat.replace( /\\{0\\}/, value );\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"X\":\n\n\t\t\t\t// Same as x*, except it uses \"Z\" for zero offset.\n\t\t\t\tif ( date.getTimezoneOffset() === 0 ) {\n\t\t\t\t\tvalue = \"Z\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* falls through */\n\t\t\tcase \"x\":\n\n\t\t\t\t// x: hourFormat(\"+HH[mm];-HH[mm]\")\n\t\t\t\t// xx: hourFormat(\"+HHmm;-HHmm\")\n\t\t\t\t// xxx: hourFormat(\"+HH:mm;-HH:mm\")\n\t\t\t\t// xxxx: hourFormat(\"+HHmm[ss];-HHmm[ss]\")\n\t\t\t\t// xxxxx: hourFormat(\"+HH:mm[:ss];-HH:mm[:ss]\")\n\t\t\t\taux = date.getTimezoneOffset();\n\n\t\t\t\t// If x and timezone offset has non-zero minutes, use xx (i.e., show minutes).\n\t\t\t\tif ( length === 1 && aux % 60 - aux % 1 !== 0 ) {\n\t\t\t\t\tlength += 1;\n\t\t\t\t}\n\n\t\t\t\t// If (xxxx or xxxxx) and timezone offset has zero seconds, use xx or xxx\n\t\t\t\t// respectively (i.e., don't show optional seconds).\n\t\t\t\tif ( ( length === 4 || length === 5 ) && aux % 1 === 0 ) {\n\t\t\t\t\tlength -= 2;\n\t\t\t\t}\n\n\t\t\t\tvalue = [\n\t\t\t\t\t\"+HH;-HH\",\n\t\t\t\t\t\"+HHmm;-HHmm\",\n\t\t\t\t\t\"+HH:mm;-HH:mm\",\n\t\t\t\t\t\"+HHmmss;-HHmmss\",\n\t\t\t\t\t\"+HH:mm:ss;-HH:mm:ss\"\n\t\t\t\t][ length - 1 ];\n\n\t\t\t\tvalue = dateTimezoneHourFormat( date, value, \":\" );\n\t\t\t\tbreak;\n\n\t\t\t// timeSeparator\n\t\t\tcase \":\":\n\t\t\t\tvalue = timeSeparator;\n\t\t\t\tbreak;\n\n\t\t\t// ' literals.\n\t\t\tcase \"'\":\n\t\t\t\tvalue = removeLiteralQuotes( current );\n\t\t\t\tbreak;\n\n\t\t\t// Anything else is considered a literal, including [ ,:/.@#], chinese, japonese, and\n\t\t\t// arabic characters.\n\t\t\tdefault:\n\t\t\t\tvalue = current;\n\n\t\t}\n\t\tif ( typeof value === \"number\" ) {\n\t\t\tvalue = numberFormatters[ length ]( value );\n\t\t}\n\n\t\tdateField = dateFieldsMap[ chr ];\n\t\ttype = dateField ? dateField : \"literal\";\n\n\t\tpartsPush( parts, type, value );\n\t});\n\n\treturn parts;\n\n};\n\n\n\n\nvar dateFormatterFn = function( dateToPartsFormatter ) {\n\treturn function dateFormatter( value ) {\n\t\treturn partsJoin( dateToPartsFormatter( value ));\n\t};\n};\n\n\n\n\n/**\n * isLeapYear( year )\n *\n * @year [Number]\n *\n * Returns an indication whether the specified year is a leap year.\n */\nvar dateIsLeapYear = function( year ) {\n\treturn new Date( year, 1, 29 ).getMonth() === 1;\n};\n\n\n\n\n/**\n * lastDayOfMonth( date )\n *\n * @date [Date]\n *\n * Return the last day of the given date's month\n */\nvar dateLastDayOfMonth = function( date ) {\n\treturn new Date( date.getFullYear(), date.getMonth() + 1, 0 ).getDate();\n};\n\n\n\n\n/**\n * Differently from native date.setDate(), this function returns a date whose\n * day remains inside the month boundaries. For example:\n *\n * setDate( FebDate, 31 ): a \"Feb 28\" date.\n * setDate( SepDate, 31 ): a \"Sep 30\" date.\n */\nvar dateSetDate = function( date, day ) {\n\tvar lastDay = new Date( date.getFullYear(), date.getMonth() + 1, 0 ).getDate();\n\n\tdate.setDate( day < 1 ? 1 : day < lastDay ? day : lastDay );\n};\n\n\n\n\n/**\n * Differently from native date.setMonth(), this function adjusts date if\n * needed, so final month is always the one set.\n *\n * setMonth( Jan31Date, 1 ): a \"Feb 28\" date.\n * setDate( Jan31Date, 8 ): a \"Sep 30\" date.\n */\nvar dateSetMonth = function( date, month ) {\n\tvar originalDate = date.getDate();\n\n\tdate.setDate( 1 );\n\tdate.setMonth( month );\n\tdateSetDate( date, originalDate );\n};\n\n\n\n\nvar outOfRange = function( value, low, high ) {\n\treturn value < low || value > high;\n};\n\n\n\n\n/**\n * parse( value, tokens, properties )\n *\n * @value [String] string date.\n *\n * @tokens [Object] tokens returned by date/tokenizer.\n *\n * @properties [Object] output returned by date/tokenizer-properties.\n *\n * ref: http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n */\nvar dateParse = function( value, tokens, properties ) {\n\tvar amPm, day, daysOfYear, month, era, hour, hour12, timezoneOffset, valid,\n\t\tYEAR = 0,\n\t\tMONTH = 1,\n\t\tDAY = 2,\n\t\tHOUR = 3,\n\t\tMINUTE = 4,\n\t\tSECOND = 5,\n\t\tMILLISECONDS = 6,\n\t\tdate = new Date(),\n\t\ttruncateAt = [],\n\t\tunits = [ \"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\", \"milliseconds\" ];\n\n\t// Create globalize date with given timezone data.\n\tif ( properties.timeZoneData ) {\n\t\tdate = new ZonedDateTime( date, properties.timeZoneData() );\n\t}\n\n\tif ( !tokens.length ) {\n\t\treturn null;\n\t}\n\n\tvalid = tokens.every(function( token ) {\n\t\tvar century, chr, value, length;\n\n\t\tif ( token.type === \"literal\" ) {\n\n\t\t\t// continue\n\t\t\treturn true;\n\t\t}\n\n\t\tchr = token.type.charAt( 0 );\n\t\tlength = token.type.length;\n\n\t\tif ( chr === \"j\" ) {\n\n\t\t\t// Locale preferred hHKk.\n\t\t\t// http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data\n\t\t\tchr = properties.preferredTimeData;\n\t\t}\n\n\t\tswitch ( chr ) {\n\n\t\t\t// Era\n\t\t\tcase \"G\":\n\t\t\t\ttruncateAt.push( YEAR );\n\t\t\t\tera = +token.value;\n\t\t\t\tbreak;\n\n\t\t\t// Year\n\t\t\tcase \"y\":\n\t\t\t\tvalue = token.value;\n\t\t\t\tif ( length === 2 ) {\n\t\t\t\t\tif ( outOfRange( value, 0, 99 ) ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t// mimic dojo/date/locale: choose century to apply, according to a sliding\n\t\t\t\t\t// window of 80 years before and 20 years after present year.\n\t\t\t\t\tcentury = Math.floor( date.getFullYear() / 100 ) * 100;\n\t\t\t\t\tvalue += century;\n\t\t\t\t\tif ( value > date.getFullYear() + 20 ) {\n\t\t\t\t\t\tvalue -= 100;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdate.setFullYear( value );\n\t\t\t\ttruncateAt.push( YEAR );\n\t\t\t\tbreak;\n\n\t\t\tcase \"Y\": // Year in \"Week of Year\"\n\t\t\t\tthrow createErrorUnsupportedFeature({\n\t\t\t\t\tfeature: \"year pattern `\" + chr + \"`\"\n\t\t\t\t});\n\n\t\t\t// Quarter (skip)\n\t\t\tcase \"Q\":\n\t\t\tcase \"q\":\n\t\t\t\tbreak;\n\n\t\t\t// Month\n\t\t\tcase \"M\":\n\t\t\tcase \"L\":\n\t\t\t\tif ( length <= 2 ) {\n\t\t\t\t\tvalue = token.value;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = +token.value;\n\t\t\t\t}\n\t\t\t\tif ( outOfRange( value, 1, 12 ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Setting the month later so that we have the correct year and can determine\n\t\t\t\t// the correct last day of February in case of leap year.\n\t\t\t\tmonth = value;\n\t\t\t\ttruncateAt.push( MONTH );\n\t\t\t\tbreak;\n\n\t\t\t// Week (skip)\n\t\t\tcase \"w\": // Week of Year.\n\t\t\tcase \"W\": // Week of Month.\n\t\t\t\tbreak;\n\n\t\t\t// Day\n\t\t\tcase \"d\":\n\t\t\t\tday = token.value;\n\t\t\t\ttruncateAt.push( DAY );\n\t\t\t\tbreak;\n\n\t\t\tcase \"D\":\n\t\t\t\tdaysOfYear = token.value;\n\t\t\t\ttruncateAt.push( DAY );\n\t\t\t\tbreak;\n\n\t\t\tcase \"F\":\n\n\t\t\t\t// Day of Week in month. eg. 2nd Wed in July.\n\t\t\t\t// Skip\n\t\t\t\tbreak;\n\n\t\t\t// Week day\n\t\t\tcase \"e\":\n\t\t\tcase \"c\":\n\t\t\tcase \"E\":\n\n\t\t\t\t// Skip.\n\t\t\t\t// value = arrayIndexOf( dateWeekDays, token.value );\n\t\t\t\tbreak;\n\n\t\t\t// Period (AM or PM)\n\t\t\tcase \"a\":\n\t\t\t\tamPm = token.value;\n\t\t\t\tbreak;\n\n\t\t\t// Hour\n\t\t\tcase \"h\": // 1-12\n\t\t\t\tvalue = token.value;\n\t\t\t\tif ( outOfRange( value, 1, 12 ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\thour = hour12 = true;\n\t\t\t\tdate.setHours( value === 12 ? 0 : value );\n\t\t\t\ttruncateAt.push( HOUR );\n\t\t\t\tbreak;\n\n\t\t\tcase \"K\": // 0-11\n\t\t\t\tvalue = token.value;\n\t\t\t\tif ( outOfRange( value, 0, 11 ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\thour = hour12 = true;\n\t\t\t\tdate.setHours( value );\n\t\t\t\ttruncateAt.push( HOUR );\n\t\t\t\tbreak;\n\n\t\t\tcase \"k\": // 1-24\n\t\t\t\tvalue = token.value;\n\t\t\t\tif ( outOfRange( value, 1, 24 ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\thour = true;\n\t\t\t\tdate.setHours( value === 24 ? 0 : value );\n\t\t\t\ttruncateAt.push( HOUR );\n\t\t\t\tbreak;\n\n\t\t\tcase \"H\": // 0-23\n\t\t\t\tvalue = token.value;\n\t\t\t\tif ( outOfRange( value, 0, 23 ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\thour = true;\n\t\t\t\tdate.setHours( value );\n\t\t\t\ttruncateAt.push( HOUR );\n\t\t\t\tbreak;\n\n\t\t\t// Minute\n\t\t\tcase \"m\":\n\t\t\t\tvalue = token.value;\n\t\t\t\tif ( outOfRange( value, 0, 59 ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tdate.setMinutes( value );\n\t\t\t\ttruncateAt.push( MINUTE );\n\t\t\t\tbreak;\n\n\t\t\t// Second\n\t\t\tcase \"s\":\n\t\t\t\tvalue = token.value;\n\t\t\t\tif ( outOfRange( value, 0, 59 ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tdate.setSeconds( value );\n\t\t\t\ttruncateAt.push( SECOND );\n\t\t\t\tbreak;\n\n\t\t\tcase \"A\":\n\t\t\t\tdate.setHours( 0 );\n\t\t\t\tdate.setMinutes( 0 );\n\t\t\t\tdate.setSeconds( 0 );\n\n\t\t\t/* falls through */\n\t\t\tcase \"S\":\n\t\t\t\tvalue = Math.round( token.value * Math.pow( 10, 3 - length ) );\n\t\t\t\tdate.setMilliseconds( value );\n\t\t\t\ttruncateAt.push( MILLISECONDS );\n\t\t\t\tbreak;\n\n\t\t\t// Zone\n\t\t\tcase \"z\":\n\t\t\tcase \"Z\":\n\t\t\tcase \"O\":\n\t\t\tcase \"v\":\n\t\t\tcase \"V\":\n\t\t\tcase \"X\":\n\t\t\tcase \"x\":\n\t\t\t\tif ( typeof token.value === \"number\" ) {\n\t\t\t\t\ttimezoneOffset = token.value;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn true;\n\t});\n\n\tif ( !valid ) {\n\t\treturn null;\n\t}\n\n\t// 12-hour format needs AM or PM, 24-hour format doesn't, ie. return null\n\t// if amPm && !hour12 || !amPm && hour12.\n\tif ( hour && !( !amPm ^ hour12 ) ) {\n\t\treturn null;\n\t}\n\n\tif ( era === 0 ) {\n\n\t\t// 1 BC = year 0\n\t\tdate.setFullYear( date.getFullYear() * -1 + 1 );\n\t}\n\n\tif ( month !== undefined ) {\n\t\tdateSetMonth( date, month - 1 );\n\t}\n\n\tif ( day !== undefined ) {\n\t\tif ( outOfRange( day, 1, dateLastDayOfMonth( date ) ) ) {\n\t\t\treturn null;\n\t\t}\n\t\tdate.setDate( day );\n\t} else if ( daysOfYear !== undefined ) {\n\t\tif ( outOfRange( daysOfYear, 1, dateIsLeapYear( date.getFullYear() ) ? 366 : 365 ) ) {\n\t\t\treturn null;\n\t\t}\n\t\tdate.setMonth( 0 );\n\t\tdate.setDate( daysOfYear );\n\t}\n\n\tif ( hour12 && amPm === \"pm\" ) {\n\t\tdate.setHours( date.getHours() + 12 );\n\t}\n\n\tif ( timezoneOffset !== undefined ) {\n\t\tdate.setMinutes( date.getMinutes() + timezoneOffset - date.getTimezoneOffset() );\n\t}\n\n\t// Truncate date at the most precise unit defined. Eg.\n\t// If value is \"12/31\", and pattern is \"MM/dd\":\n\t// => new Date( <current Year>, 12, 31, 0, 0, 0, 0 );\n\ttruncateAt = Math.max.apply( null, truncateAt );\n\tdate = dateStartOf( date, units[ truncateAt ] );\n\n\t// Get date back from globalize date.\n\tif ( date instanceof ZonedDateTime ) {\n\t\tdate = date.toDate();\n\t}\n\n\treturn date;\n};\n\n\n\n\n/**\n * tokenizer( value, numberParser, properties )\n *\n * @value [String] string date.\n *\n * @numberParser [Function]\n *\n * @properties [Object] output returned by date/tokenizer-properties.\n *\n * Returns an Array of tokens, eg. value \"5 o'clock PM\", pattern \"h 'o''clock' a\":\n * [{\n *   type: \"h\",\n *   lexeme: \"5\"\n * }, {\n *   type: \"literal\",\n *   lexeme: \" \"\n * }, {\n *   type: \"literal\",\n *   lexeme: \"o'clock\"\n * }, {\n *   type: \"literal\",\n *   lexeme: \" \"\n * }, {\n *   type: \"a\",\n *   lexeme: \"PM\",\n *   value: \"pm\"\n * }]\n *\n * OBS: lexeme's are always String and may return invalid ranges depending of the token type.\n * Eg. \"99\" for month number.\n *\n * Return an empty Array when not successfully parsed.\n */\nvar dateTokenizer = function( value, numberParser, properties ) {\n\tvar digitsRe, valid,\n\t\ttokens = [],\n\t\twidths = [ \"abbreviated\", \"wide\", \"narrow\" ];\n\n\tdigitsRe = properties.digitsRe;\n\tvalue = looseMatching( value );\n\n\tvalid = properties.pattern.match( datePatternRe ).every(function( current ) {\n\t\tvar aux, chr, length, numeric, tokenRe,\n\t\t\ttoken = {};\n\n\t\tfunction hourFormatParse( tokenRe, numberParser ) {\n\t\t\tvar aux, isPositive,\n\t\t\t\tmatch = value.match( tokenRe );\n\t\t\tnumberParser = numberParser || function( value ) {\n\t\t\t\treturn +value;\n\t\t\t};\n\n\t\t\tif ( !match ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tisPositive = match[ 1 ];\n\n\t\t\t// hourFormat containing H only, e.g., `+H;-H`\n\t\t\tif ( match.length < 6 ) {\n\t\t\t\taux = isPositive ? 1 : 3;\n\t\t\t\ttoken.value = numberParser( match[ aux ] ) * 60;\n\n\t\t\t// hourFormat containing H and m, e.g., `+HHmm;-HHmm`\n\t\t\t} else if ( match.length < 10 ) {\n\t\t\t\taux = isPositive ? [ 1, 3 ] : [ 5, 7 ];\n\t\t\t\ttoken.value = numberParser( match[ aux[ 0 ] ] ) * 60 +\n\t\t\t\t\tnumberParser( match[ aux[ 1 ] ] );\n\n\t\t\t// hourFormat containing H, m, and s e.g., `+HHmmss;-HHmmss`\n\t\t\t} else {\n\t\t\t\taux = isPositive ? [ 1, 3, 5 ] : [ 7, 9, 11 ];\n\t\t\t\ttoken.value = numberParser( match[ aux[ 0 ] ] ) * 60 +\n\t\t\t\t\tnumberParser( match[ aux[ 1 ] ] ) +\n\t\t\t\t\tnumberParser( match[ aux[ 2 ] ] ) / 60;\n\t\t\t}\n\n\t\t\tif ( isPositive ) {\n\t\t\t\ttoken.value *= -1;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tfunction oneDigitIfLengthOne() {\n\t\t\tif ( length === 1 ) {\n\n\t\t\t\t// Unicode equivalent to /\\d/\n\t\t\t\tnumeric = true;\n\t\t\t\treturn tokenRe = digitsRe;\n\t\t\t}\n\t\t}\n\n\t\tfunction oneOrTwoDigitsIfLengthOne() {\n\t\t\tif ( length === 1 ) {\n\n\t\t\t\t// Unicode equivalent to /\\d\\d?/\n\t\t\t\tnumeric = true;\n\t\t\t\treturn tokenRe = new RegExp( \"^(\" + digitsRe.source + \"){1,2}\" );\n\t\t\t}\n\t\t}\n\n\t\tfunction oneOrTwoDigitsIfLengthOneOrTwo() {\n\t\t\tif ( length === 1 || length === 2 ) {\n\n\t\t\t\t// Unicode equivalent to /\\d\\d?/\n\t\t\t\tnumeric = true;\n\t\t\t\treturn tokenRe = new RegExp( \"^(\" + digitsRe.source + \"){1,2}\" );\n\t\t\t}\n\t\t}\n\n\t\tfunction twoDigitsIfLengthTwo() {\n\t\t\tif ( length === 2 ) {\n\n\t\t\t\t// Unicode equivalent to /\\d\\d/\n\t\t\t\tnumeric = true;\n\t\t\t\treturn tokenRe = new RegExp( \"^(\" + digitsRe.source + \"){2}\" );\n\t\t\t}\n\t\t}\n\n\t\t// Brute-force test every locale entry in an attempt to match the given value.\n\t\t// Return the first found one (and set token accordingly), or null.\n\t\tfunction lookup( path ) {\n\t\t\tvar array = properties[ path.join( \"/\" ) ];\n\n\t\t\tif ( !array ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// array of pairs [key, value] sorted by desc value length.\n\t\t\tarray.some(function( item ) {\n\t\t\t\tvar valueRe = item[ 1 ];\n\t\t\t\tif ( valueRe.test( value ) ) {\n\t\t\t\t\ttoken.value = item[ 0 ];\n\t\t\t\t\ttokenRe = item[ 1 ];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn null;\n\t\t}\n\n\t\ttoken.type = current;\n\t\tchr = current.charAt( 0 );\n\t\tlength = current.length;\n\n\t\tif ( chr === \"Z\" ) {\n\n\t\t\t// Z..ZZZ: same as \"xxxx\".\n\t\t\tif ( length < 4 ) {\n\t\t\t\tchr = \"x\";\n\t\t\t\tlength = 4;\n\n\t\t\t// ZZZZ: same as \"OOOO\".\n\t\t\t} else if ( length < 5 ) {\n\t\t\t\tchr = \"O\";\n\t\t\t\tlength = 4;\n\n\t\t\t// ZZZZZ: same as \"XXXXX\"\n\t\t\t} else {\n\t\t\t\tchr = \"X\";\n\t\t\t\tlength = 5;\n\t\t\t}\n\t\t}\n\n\t\tif ( chr === \"z\" ) {\n\t\t\tif ( properties.standardOrDaylightTzName ) {\n\t\t\t\ttoken.value = null;\n\t\t\t\ttokenRe = properties.standardOrDaylightTzName;\n\t\t\t}\n\t\t}\n\n\t\t// v...vvv: \"{shortRegion}\", eg. \"PT\".\n\t\t// vvvv: \"{regionName} {Time}\" or \"{regionName} {Time}\",\n\t\t// e.g., \"Pacific Time\"\n\t\t// http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\n\t\tif ( chr === \"v\" ) {\n\t\t\tif ( properties.genericTzName ) {\n\t\t\t\ttoken.value = null;\n\t\t\t\ttokenRe = properties.genericTzName;\n\n\t\t\t// Fall back to \"V\" format.\n\t\t\t} else {\n\t\t\t\tchr = \"V\";\n\t\t\t\tlength = 4;\n\t\t\t}\n\t\t}\n\n\t\tif ( chr === \"V\" && properties.timeZoneName ) {\n\t\t\ttoken.value = length === 2 ? properties.timeZoneName : null;\n\t\t\ttokenRe = properties.timeZoneNameRe;\n\t\t}\n\n\t\tswitch ( chr ) {\n\n\t\t\t// Era\n\t\t\tcase \"G\":\n\t\t\t\tlookup([\n\t\t\t\t\t\"gregorian/eras\",\n\t\t\t\t\tlength <= 3 ? \"eraAbbr\" : ( length === 4 ? \"eraNames\" : \"eraNarrow\" )\n\t\t\t\t]);\n\t\t\t\tbreak;\n\n\t\t\t// Year\n\t\t\tcase \"y\":\n\t\t\tcase \"Y\":\n\t\t\t\tnumeric = true;\n\n\t\t\t\t// number l=1:+, l=2:{2}, l=3:{3,}, l=4:{4,}, ...\n\t\t\t\tif ( length === 1 ) {\n\n\t\t\t\t\t// Unicode equivalent to /\\d+/.\n\t\t\t\t\ttokenRe = new RegExp( \"^(\" + digitsRe.source + \")+\" );\n\t\t\t\t} else if ( length === 2 ) {\n\n\t\t\t\t\t// Lenient parsing: there's no year pattern to indicate non-zero-padded 2-digits\n\t\t\t\t\t// year, so parser accepts both zero-padded and non-zero-padded for `yy`.\n\t\t\t\t\t//\n\t\t\t\t\t// Unicode equivalent to /\\d\\d?/\n\t\t\t\t\ttokenRe = new RegExp( \"^(\" + digitsRe.source + \"){1,2}\" );\n\t\t\t\t} else {\n\n\t\t\t\t\t// Unicode equivalent to /\\d{length,}/\n\t\t\t\t\ttokenRe = new RegExp( \"^(\" + digitsRe.source + \"){\" + length + \",}\" );\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Quarter\n\t\t\tcase \"Q\":\n\t\t\tcase \"q\":\n\n\t\t\t\t// number l=1:{1}, l=2:{2}.\n\t\t\t\t// lookup l=3...\n\t\t\t\toneDigitIfLengthOne() || twoDigitsIfLengthTwo() ||\n\t\t\t\t\tlookup([\n\t\t\t\t\t\t\"gregorian/quarters\",\n\t\t\t\t\t\tchr === \"Q\" ? \"format\" : \"stand-alone\",\n\t\t\t\t\t\twidths[ length - 3 ]\n\t\t\t\t\t]);\n\t\t\t\tbreak;\n\n\t\t\t// Month\n\t\t\tcase \"M\":\n\t\t\tcase \"L\":\n\n\t\t\t\t// number l=1:{1,2}, l=2:{2}.\n\t\t\t\t// lookup l=3...\n\t\t\t\t//\n\t\t\t\t// Lenient parsing: skeleton \"yMd\" (i.e., one M) may include MM for the pattern,\n\t\t\t\t// therefore parser accepts both zero-padded and non-zero-padded for M and MM.\n\t\t\t\t// Similar for L.\n\t\t\t\toneOrTwoDigitsIfLengthOneOrTwo() || lookup([\n\t\t\t\t\t\"gregorian/months\",\n\t\t\t\t\tchr === \"M\" ? \"format\" : \"stand-alone\",\n\t\t\t\t\twidths[ length - 3 ]\n\t\t\t\t]);\n\t\t\t\tbreak;\n\n\t\t\t// Day\n\t\t\tcase \"D\":\n\n\t\t\t\t// number {l,3}.\n\t\t\t\tif ( length <= 3 ) {\n\n\t\t\t\t\t// Equivalent to /\\d{length,3}/\n\t\t\t\t\tnumeric = true;\n\t\t\t\t\ttokenRe = new RegExp( \"^(\" + digitsRe.source + \"){\" + length + \",3}\" );\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"W\":\n\t\t\tcase \"F\":\n\n\t\t\t\t// number l=1:{1}.\n\t\t\t\toneDigitIfLengthOne();\n\t\t\t\tbreak;\n\n\t\t\t// Week day\n\t\t\tcase \"e\":\n\t\t\tcase \"c\":\n\n\t\t\t\t// number l=1:{1}, l=2:{2}.\n\t\t\t\t// lookup for length >=3.\n\t\t\t\tif ( length <= 2 ) {\n\t\t\t\t\toneDigitIfLengthOne() || twoDigitsIfLengthTwo();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* falls through */\n\t\t\tcase \"E\":\n\t\t\t\tif ( length === 6 ) {\n\n\t\t\t\t\t// Note: if short day names are not explicitly specified, abbreviated day\n\t\t\t\t\t// names are used instead http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras\n\t\t\t\t\tlookup([\n\t\t\t\t\t\t\"gregorian/days\",\n\t\t\t\t\t\t[ chr === \"c\" ? \"stand-alone\" : \"format\" ],\n\t\t\t\t\t\t\"short\"\n\t\t\t\t\t]) || lookup([\n\t\t\t\t\t\t\"gregorian/days\",\n\t\t\t\t\t\t[ chr === \"c\" ? \"stand-alone\" : \"format\" ],\n\t\t\t\t\t\t\"abbreviated\"\n\t\t\t\t\t]);\n\t\t\t\t} else {\n\t\t\t\t\tlookup([\n\t\t\t\t\t\t\"gregorian/days\",\n\t\t\t\t\t\t[ chr === \"c\" ? \"stand-alone\" : \"format\" ],\n\t\t\t\t\t\twidths[ length < 3 ? 0 : length - 3 ]\n\t\t\t\t\t]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// Period (AM or PM)\n\t\t\tcase \"a\":\n\t\t\t\tlookup([\n\t\t\t\t\t\"gregorian/dayPeriods/format/wide\"\n\t\t\t\t]);\n\t\t\t\tbreak;\n\n\t\t\t// Week\n\t\t\tcase \"w\":\n\n\t\t\t\t// number l1:{1,2}, l2:{2}.\n\t\t\t\toneOrTwoDigitsIfLengthOne() || twoDigitsIfLengthTwo();\n\t\t\t\tbreak;\n\n\t\t\t// Day, Hour, Minute, or Second\n\t\t\tcase \"d\":\n\t\t\tcase \"h\":\n\t\t\tcase \"H\":\n\t\t\tcase \"K\":\n\t\t\tcase \"k\":\n\t\t\tcase \"j\":\n\t\t\tcase \"m\":\n\t\t\tcase \"s\":\n\n\t\t\t\t// number l1:{1,2}, l2:{2}.\n\t\t\t\t//\n\t\t\t\t// Lenient parsing:\n\t\t\t\t// - skeleton \"hms\" (i.e., one m) always includes mm for the pattern, i.e., it's\n\t\t\t\t//   impossible to use a different skeleton to parse non-zero-padded minutes,\n\t\t\t\t//   therefore parser accepts both zero-padded and non-zero-padded for m. Similar\n\t\t\t\t//   for seconds s.\n\t\t\t\t// - skeleton \"hms\" (i.e., one h) may include h or hh for the pattern, i.e., it's\n\t\t\t\t//   impossible to use a different skeleton to parser non-zero-padded hours for some\n\t\t\t\t//   locales, therefore parser accepts both zero-padded and non-zero-padded for h.\n\t\t\t\t//   Similar for d (in skeleton yMd).\n\t\t\t\toneOrTwoDigitsIfLengthOneOrTwo();\n\t\t\t\tbreak;\n\n\t\t\tcase \"S\":\n\n\t\t\t\t// number {l}.\n\n\t\t\t\t// Unicode equivalent to /\\d{length}/\n\t\t\t\tnumeric = true;\n\t\t\t\ttokenRe = new RegExp( \"^(\" + digitsRe.source + \"){\" + length + \"}\" );\n\t\t\t\tbreak;\n\n\t\t\tcase \"A\":\n\n\t\t\t\t// number {l+5}.\n\n\t\t\t\t// Unicode equivalent to /\\d{length+5}/\n\t\t\t\tnumeric = true;\n\t\t\t\ttokenRe = new RegExp( \"^(\" + digitsRe.source + \"){\" + ( length + 5 ) + \"}\" );\n\t\t\t\tbreak;\n\n\t\t\t// Zone\n\t\t\tcase \"v\":\n\t\t\tcase \"V\":\n\t\t\tcase \"z\":\n\t\t\t\tif ( tokenRe && tokenRe.test( value ) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( chr === \"V\" && length === 2 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* falls through */\n\t\t\tcase \"O\":\n\n\t\t\t\t// O: \"{gmtFormat}+H;{gmtFormat}-H\" or \"{gmtZeroFormat}\", eg. \"GMT-8\" or \"GMT\".\n\t\t\t\t// OOOO: \"{gmtFormat}{hourFormat}\" or \"{gmtZeroFormat}\", eg. \"GMT-08:00\" or \"GMT\".\n\t\t\t\tif ( value === properties[ \"timeZoneNames/gmtZeroFormat\" ] ) {\n\t\t\t\t\ttoken.value = 0;\n\t\t\t\t\ttokenRe = properties[ \"timeZoneNames/gmtZeroFormatRe\" ];\n\t\t\t\t} else {\n\t\t\t\t\taux = properties[ \"timeZoneNames/hourFormat\" ].some(function( hourFormatRe ) {\n\t\t\t\t\t\tif ( hourFormatParse( hourFormatRe, numberParser ) ) {\n\t\t\t\t\t\t\ttokenRe = hourFormatRe;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tif ( !aux ) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"X\":\n\n\t\t\t\t// Same as x*, except it uses \"Z\" for zero offset.\n\t\t\t\tif ( value === \"Z\" ) {\n\t\t\t\t\ttoken.value = 0;\n\t\t\t\t\ttokenRe = /^Z/;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t/* falls through */\n\t\t\tcase \"x\":\n\n\t\t\t\t// x: hourFormat(\"+HH[mm];-HH[mm]\")\n\t\t\t\t// xx: hourFormat(\"+HHmm;-HHmm\")\n\t\t\t\t// xxx: hourFormat(\"+HH:mm;-HH:mm\")\n\t\t\t\t// xxxx: hourFormat(\"+HHmm[ss];-HHmm[ss]\")\n\t\t\t\t// xxxxx: hourFormat(\"+HH:mm[:ss];-HH:mm[:ss]\")\n\t\t\t\taux = properties.x.some(function( hourFormatRe ) {\n\t\t\t\t\tif ( hourFormatParse( hourFormatRe ) ) {\n\t\t\t\t\t\ttokenRe = hourFormatRe;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif ( !aux ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase \"'\":\n\t\t\t\ttoken.type = \"literal\";\n\t\t\t\ttokenRe = new RegExp( \"^\" + regexpEscape( removeLiteralQuotes( current ) ) );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\ttoken.type = \"literal\";\n\t\t\t\ttokenRe = new RegExp( \"^\" + regexpEscape( current ) );\n\t\t}\n\n\t\tif ( !tokenRe ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Get lexeme and consume it.\n\t\tvalue = value.replace( tokenRe, function( lexeme ) {\n\t\t\ttoken.lexeme = lexeme;\n\t\t\tif ( numeric ) {\n\t\t\t\ttoken.value = numberParser( lexeme );\n\t\t\t}\n\t\t\treturn \"\";\n\t\t});\n\n\t\tif ( !token.lexeme ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( numeric && isNaN( token.value ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\ttokens.push( token );\n\t\treturn true;\n\t});\n\n\tif ( value !== \"\" ) {\n\t\tvalid = false;\n\t}\n\n\treturn valid ? tokens : [];\n};\n\n\n\n\nvar dateParserFn = function( numberParser, parseProperties, tokenizerProperties ) {\n\treturn function dateParser( value ) {\n\t\tvar tokens;\n\n\t\tvalidateParameterPresence( value, \"value\" );\n\t\tvalidateParameterTypeString( value, \"value\" );\n\n\t\ttokens = dateTokenizer( value, numberParser, tokenizerProperties );\n\t\treturn dateParse( value, tokens, parseProperties ) || null;\n\t};\n};\n\n\n\n\nvar dateToPartsFormatterFn = function( numberFormatters, properties ) {\n\treturn function dateToPartsFormatter( value ) {\n\t\tvalidateParameterPresence( value, \"value\" );\n\t\tvalidateParameterTypeDate( value, \"value\" );\n\n\t\treturn dateFormat( value, numberFormatters, properties );\n\t};\n\n};\n\n\n\n\nGlobalize._dateFormat = dateFormat;\nGlobalize._dateFormatterFn = dateFormatterFn;\nGlobalize._dateParser = dateParse;\nGlobalize._dateParserFn = dateParserFn;\nGlobalize._dateTokenizer = dateTokenizer;\nGlobalize._dateToPartsFormatterFn = dateToPartsFormatterFn;\nGlobalize._validateParameterTypeDate = validateParameterTypeDate;\n\nfunction optionsHasStyle( options ) {\n\treturn options.skeleton !== undefined ||\n\t\toptions.date !== undefined ||\n\t\toptions.time !== undefined ||\n\t\toptions.datetime !== undefined ||\n\t\toptions.raw !== undefined;\n}\n\nGlobalize.dateFormatter =\nGlobalize.prototype.dateFormatter = function( options ) {\n\toptions = options || {};\n\tif ( !optionsHasStyle( options ) ) {\n\t\toptions.skeleton = \"yMd\";\n\t}\n\treturn Globalize[ runtimeKey( \"dateFormatter\", this._locale, [ options ] ) ];\n};\n\nGlobalize.dateToPartsFormatter =\nGlobalize.prototype.dateToPartsFormatter = function( options ) {\n\toptions = options || {};\n\tif ( !optionsHasStyle( options ) ) {\n\t\toptions.skeleton = \"yMd\";\n\t}\n\treturn Globalize[ runtimeKey( \"dateToPartsFormatter\", this._locale, [ options ] ) ];\n};\n\nGlobalize.dateParser =\nGlobalize.prototype.dateParser = function( options ) {\n\toptions = options || {};\n\tif ( !optionsHasStyle( options ) ) {\n\t\toptions.skeleton = \"yMd\";\n\t}\n\treturn Globalize[ runtimeKey( \"dateParser\", this._locale, [ options ] ) ];\n};\n\nGlobalize.formatDate =\nGlobalize.prototype.formatDate = function( value, options ) {\n\tvalidateParameterPresence( value, \"value\" );\n\tvalidateParameterTypeDate( value, \"value\" );\n\n\treturn this.dateFormatter( options )( value );\n};\n\nGlobalize.formatDateToParts =\nGlobalize.prototype.formatDateToParts = function( value, options ) {\n\tvalidateParameterPresence( value, \"value\" );\n\tvalidateParameterTypeDate( value, \"value\" );\n\n\treturn this.dateToPartsFormatter( options )( value );\n};\n\nGlobalize.parseDate =\nGlobalize.prototype.parseDate = function( value, options ) {\n\tvalidateParameterPresence( value, \"value\" );\n\tvalidateParameterTypeString( value, \"value\" );\n\n\treturn this.dateParser( options )( value );\n};\n\nreturn Globalize;\n\n\n\n\n}));\n"]},"metadata":{},"sourceType":"script"}