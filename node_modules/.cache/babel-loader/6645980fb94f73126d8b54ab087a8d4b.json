{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) {\n    if (b.hasOwnProperty(p)) d[p] = b[p];\n  }\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = require('../Observable');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar ScalarObservable = function (_super) {\n  __extends(ScalarObservable, _super);\n\n  function ScalarObservable(value, scheduler) {\n    _super.call(this);\n\n    this.value = value;\n    this.scheduler = scheduler;\n    this._isScalar = true;\n\n    if (scheduler) {\n      this._isScalar = false;\n    }\n  }\n\n  ScalarObservable.create = function (value, scheduler) {\n    return new ScalarObservable(value, scheduler);\n  };\n\n  ScalarObservable.dispatch = function (state) {\n    var done = state.done,\n        value = state.value,\n        subscriber = state.subscriber;\n\n    if (done) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(value);\n\n    if (subscriber.closed) {\n      return;\n    }\n\n    state.done = true;\n    this.schedule(state);\n  };\n  /** @deprecated internal use only */\n\n\n  ScalarObservable.prototype._subscribe = function (subscriber) {\n    var value = this.value;\n    var scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(ScalarObservable.dispatch, 0, {\n        done: false,\n        value: value,\n        subscriber: subscriber\n      });\n    } else {\n      subscriber.next(value);\n\n      if (!subscriber.closed) {\n        subscriber.complete();\n      }\n    }\n  };\n\n  return ScalarObservable;\n}(Observable_1.Observable);\n\nexports.ScalarObservable = ScalarObservable;","map":{"version":3,"sources":["../../src/observable/ScalarObservable.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AACA,IAAA,YAAA,GAAA,OAAA,CAA2B,eAA3B,CAAA;AAIA;;;;AAIG;;;AACH,IAAA,gBAAA,GAAA,UAAA,MAAA,EAAA;AAAyC,EAAA,SAAA,CAAA,gBAAA,EAAA,MAAA,CAAA;;AAwBvC,WAAA,gBAAA,CAAmB,KAAnB,EAAqC,SAArC,EAA2D;AACzD,IAAA,MAAA,CAAA,IAAA,CAAA,IAAA;;AADiB,SAAA,KAAA,GAAA,KAAA;AAAkB,SAAA,SAAA,GAAA,SAAA;AAFrC,SAAA,SAAA,GAAqB,IAArB;;AAIE,QAAI,SAAJ,EAAe;AACb,WAAK,SAAL,GAAiB,KAAjB;AACD;AACF;;AA5BM,EAAA,gBAAA,CAAA,MAAA,GAAP,UAAiB,KAAjB,EAA2B,SAA3B,EAAiD;AAC/C,WAAO,IAAI,gBAAJ,CAAqB,KAArB,EAA4B,SAA5B,CAAP;AACD,GAFM;;AAIA,EAAA,gBAAA,CAAA,QAAA,GAAP,UAAgB,KAAhB,EAA0B;AAChB,QAAA,IAAA,GAAA,KAAA,CAAA,IAAA;AAAA,QAAM,KAAA,GAAA,KAAA,CAAA,KAAN;AAAA,QAAa,UAAA,GAAA,KAAA,CAAA,UAAb;;AAER,QAAI,IAAJ,EAAU;AACR,MAAA,UAAU,CAAC,QAAX;AACA;AACD;;AAED,IAAA,UAAU,CAAC,IAAX,CAAgB,KAAhB;;AACA,QAAI,UAAU,CAAC,MAAf,EAAuB;AACrB;AACD;;AAED,IAAA,KAAK,CAAC,IAAN,GAAa,IAAb;AACO,SAAM,QAAN,CAAe,KAAf;AACR,GAfM;AA0BP;;;AAAqC,EAAA,gBAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,UAAX,EAAoC;AACvE,QAAM,KAAK,GAAG,KAAK,KAAnB;AACA,QAAM,SAAS,GAAG,KAAK,SAAvB;;AAEA,QAAI,SAAJ,EAAe;AACb,aAAO,SAAS,CAAC,QAAV,CAAmB,gBAAgB,CAAC,QAApC,EAA8C,CAA9C,EAAiD;AACtD,QAAA,IAAI,EAAE,KADgD;AACzC,QAAA,KAAA,EAAA,KADyC;AAClC,QAAA,UAAA,EAAA;AADkC,OAAjD,CAAP;AAGD,KAJD,MAIO;AACL,MAAA,UAAU,CAAC,IAAX,CAAgB,KAAhB;;AACA,UAAI,CAAC,UAAU,CAAC,MAAhB,EAAwB;AACtB,QAAA,UAAU,CAAC,QAAX;AACD;AACF;AACF,GAdoC;;AAevC,SAAA,gBAAA;AAAC,CA9CD,CAAyC,YAAA,CAAA,UAAzC,CAAA;;AAAa,OAAA,CAAA,gBAAA,GAAgB,gBAAhB","sourcesContent":["import { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { TeardownLogic } from '../Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class ScalarObservable<T> extends Observable<T> {\n  static create<T>(value: T, scheduler?: IScheduler): ScalarObservable<T> {\n    return new ScalarObservable(value, scheduler);\n  }\n\n  static dispatch(state: any): void {\n    const { done, value, subscriber } = state;\n\n    if (done) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(value);\n    if (subscriber.closed) {\n      return;\n    }\n\n    state.done = true;\n    (<any> this).schedule(state);\n  }\n\n  _isScalar: boolean = true;\n\n  constructor(public value: T, private scheduler?: IScheduler) {\n    super();\n    if (scheduler) {\n      this._isScalar = false;\n    }\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n    const value = this.value;\n    const scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(ScalarObservable.dispatch, 0, {\n        done: false, value, subscriber\n      });\n    } else {\n      subscriber.next(value);\n      if (!subscriber.closed) {\n        subscriber.complete();\n      }\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}