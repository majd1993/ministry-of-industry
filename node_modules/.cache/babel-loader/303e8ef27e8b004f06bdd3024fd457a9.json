{"ast":null,"code":"\"use strict\"; //\n// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.\n//\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Exports_1 = require(\"../common/Exports\");\n\nvar PropertyCollection_1 = require(\"./PropertyCollection\");\n\nvar PropertyId_1 = require(\"./PropertyId\");\n/**\n * ConnectionMessage represents implementation specific messages sent to and received from\n * the speech service. These messages are provided for debugging purposes and should not\n * be used for production use cases with the Azure Cognitive Services Speech Service.\n * Messages sent to and received from the Speech Service are subject to change without\n * notice. This includes message contents, headers, payloads, ordering, etc.\n * Added in version 1.11.0.\n */\n\n\nvar ConnectionMessage =\n/** @class */\nfunction () {\n  function ConnectionMessage() {}\n\n  return ConnectionMessage;\n}();\n\nexports.ConnectionMessage = ConnectionMessage; // tslint:disable-next-line:max-classes-per-file\n\nvar ConnectionMessageImpl =\n/** @class */\nfunction () {\n  function ConnectionMessageImpl(message) {\n    var _this = this;\n\n    this.privConnectionMessage = message;\n    this.privProperties = new PropertyCollection_1.PropertyCollection();\n\n    if (!!this.privConnectionMessage.headers[\"X-ConnectionId\"]) {\n      this.privProperties.setProperty(PropertyId_1.PropertyId.Speech_SessionId, this.privConnectionMessage.headers[\"X-ConnectionId\"]);\n    }\n\n    Object.keys(this.privConnectionMessage.headers).forEach(function (header, index, array) {\n      _this.privProperties.setProperty(header, _this.privConnectionMessage.headers[header]);\n    });\n  }\n\n  Object.defineProperty(ConnectionMessageImpl.prototype, \"path\", {\n    /**\n     * The message path.\n     */\n    get: function get() {\n      return this.privConnectionMessage.headers[Object.keys(this.privConnectionMessage.headers).find(function (key) {\n        return key.toLowerCase() === \"path\".toLowerCase();\n      })];\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ConnectionMessageImpl.prototype, \"isTextMessage\", {\n    /**\n     * Checks to see if the ConnectionMessage is a text message.\n     * See also IsBinaryMessage().\n     */\n    get: function get() {\n      return this.privConnectionMessage.messageType === Exports_1.MessageType.Text;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ConnectionMessageImpl.prototype, \"isBinaryMessage\", {\n    /**\n     * Checks to see if the ConnectionMessage is a binary message.\n     * See also GetBinaryMessage().\n     */\n    get: function get() {\n      return this.privConnectionMessage.messageType === Exports_1.MessageType.Binary;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ConnectionMessageImpl.prototype, \"TextMessage\", {\n    /**\n     * Gets the text message payload. Typically the text message content-type is\n     * application/json. To determine other content-types use\n     * Properties.GetProperty(\"Content-Type\").\n     */\n    get: function get() {\n      return this.privConnectionMessage.textBody;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ConnectionMessageImpl.prototype, \"binaryMessage\", {\n    /**\n     * Gets the binary message payload.\n     */\n    get: function get() {\n      return this.privConnectionMessage.binaryBody;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ConnectionMessageImpl.prototype, \"properties\", {\n    /**\n     * A collection of properties and their values defined for this <see cref=\"ConnectionMessage\"/>.\n     * Message headers can be accessed via this collection (e.g. \"Content-Type\").\n     */\n    get: function get() {\n      return this.privProperties;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Returns a string that represents the connection message.\n   */\n\n  ConnectionMessageImpl.prototype.toString = function () {\n    return \"\";\n  };\n\n  return ConnectionMessageImpl;\n}();\n\nexports.ConnectionMessageImpl = ConnectionMessageImpl;","map":{"version":3,"sources":["src/sdk/ConnectionMessage.ts"],"names":[],"mappings":"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","sourcesContent":["//\r\n// Copyright (c) Microsoft. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.\r\n//\r\n\r\nimport {\r\n    ConnectionMessage as IntConnectionMessage,\r\n    MessageType\r\n} from \"../common/Exports\";\r\nimport {\r\n    PropertyCollection\r\n} from \"./PropertyCollection\";\r\nimport { PropertyId } from \"./PropertyId\";\r\n\r\n/**\r\n * ConnectionMessage represents implementation specific messages sent to and received from\r\n * the speech service. These messages are provided for debugging purposes and should not\r\n * be used for production use cases with the Azure Cognitive Services Speech Service.\r\n * Messages sent to and received from the Speech Service are subject to change without\r\n * notice. This includes message contents, headers, payloads, ordering, etc.\r\n * Added in version 1.11.0.\r\n */\r\nexport abstract class ConnectionMessage {\r\n    /**\r\n     * The message path.\r\n     */\r\n    public abstract get path(): string;\r\n\r\n    /**\r\n     * Checks to see if the ConnectionMessage is a text message.\r\n     * See also IsBinaryMessage().\r\n     */\r\n    public abstract get isTextMessage(): boolean;\r\n\r\n    /**\r\n     * Checks to see if the ConnectionMessage is a binary message.\r\n     * See also GetBinaryMessage().\r\n     */\r\n    public abstract get isBinaryMessage(): boolean;\r\n\r\n    /**\r\n     * Gets the text message payload. Typically the text message content-type is\r\n     * application/json. To determine other content-types use\r\n     * Properties.GetProperty(\"Content-Type\").\r\n     */\r\n    public abstract get TextMessage(): string;\r\n\r\n    /**\r\n     * Gets the binary message payload.\r\n     */\r\n    public abstract get binaryMessage(): ArrayBuffer;\r\n\r\n    /**\r\n     * A collection of properties and their values defined for this <see cref=\"ConnectionMessage\"/>.\r\n     * Message headers can be accessed via this collection (e.g. \"Content-Type\").\r\n     */\r\n    public abstract get properties(): PropertyCollection;\r\n\r\n    /**\r\n     * Returns a string that represents the connection message.\r\n     */\r\n    public abstract toString(): string;\r\n}\r\n\r\n// tslint:disable-next-line:max-classes-per-file\r\nexport class ConnectionMessageImpl {\r\n\r\n    private privConnectionMessage: IntConnectionMessage;\r\n    private privProperties: PropertyCollection;\r\n\r\n    constructor(message: IntConnectionMessage) {\r\n        this.privConnectionMessage = message;\r\n        this.privProperties = new PropertyCollection();\r\n        if (!!this.privConnectionMessage.headers[\"X-ConnectionId\"]) {\r\n            this.privProperties.setProperty(PropertyId.Speech_SessionId, this.privConnectionMessage.headers[\"X-ConnectionId\"]);\r\n        }\r\n\r\n        Object.keys(this.privConnectionMessage.headers).forEach((header: string, index: number, array: string[]): void => {\r\n            this.privProperties.setProperty(header, this.privConnectionMessage.headers[header]);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The message path.\r\n     */\r\n    public get path(): string {\r\n        return this.privConnectionMessage.headers[Object.keys(this.privConnectionMessage.headers).find((key: string) => key.toLowerCase() === \"path\".toLowerCase())];\r\n    }\r\n\r\n    /**\r\n     * Checks to see if the ConnectionMessage is a text message.\r\n     * See also IsBinaryMessage().\r\n     */\r\n    public get isTextMessage(): boolean {\r\n        return this.privConnectionMessage.messageType === MessageType.Text;\r\n    }\r\n\r\n    /**\r\n     * Checks to see if the ConnectionMessage is a binary message.\r\n     * See also GetBinaryMessage().\r\n     */\r\n    public get isBinaryMessage(): boolean {\r\n        return this.privConnectionMessage.messageType === MessageType.Binary;\r\n    }\r\n\r\n    /**\r\n     * Gets the text message payload. Typically the text message content-type is\r\n     * application/json. To determine other content-types use\r\n     * Properties.GetProperty(\"Content-Type\").\r\n     */\r\n    public get TextMessage(): string {\r\n        return this.privConnectionMessage.textBody;\r\n    }\r\n\r\n    /**\r\n     * Gets the binary message payload.\r\n     */\r\n    public get binaryMessage(): ArrayBuffer {\r\n        return this.privConnectionMessage.binaryBody;\r\n    }\r\n\r\n    /**\r\n     * A collection of properties and their values defined for this <see cref=\"ConnectionMessage\"/>.\r\n     * Message headers can be accessed via this collection (e.g. \"Content-Type\").\r\n     */\r\n    public get properties(): PropertyCollection {\r\n        return this.privProperties;\r\n    }\r\n\r\n    /**\r\n     * Returns a string that represents the connection message.\r\n     */\r\n    public toString(): string {\r\n        return \"\";\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}