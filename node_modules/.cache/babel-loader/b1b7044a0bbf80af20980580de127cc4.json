{"ast":null,"code":"'use strict';\n\nvar whitespace = require('is-whitespace-character');\n\nvar locate = require('../locate/link');\n\nvar normalize = require('../util/normalize');\n\nmodule.exports = reference;\nreference.locator = locate;\nvar link = 'link';\nvar image = 'image';\nvar footnote = 'footnote';\nvar shortcut = 'shortcut';\nvar collapsed = 'collapsed';\nvar full = 'full';\nvar space = ' ';\nvar exclamationMark = '!';\nvar leftSquareBracket = '[';\nvar backslash = '\\\\';\nvar rightSquareBracket = ']';\nvar caret = '^';\n\nfunction reference(eat, value, silent) {\n  var self = this;\n  var commonmark = self.options.commonmark;\n  var character = value.charAt(0);\n  var index = 0;\n  var length = value.length;\n  var subvalue = '';\n  var intro = '';\n  var type = link;\n  var referenceType = shortcut;\n  var content;\n  var identifier;\n  var now;\n  var node;\n  var exit;\n  var queue;\n  var bracketed;\n  var depth; // Check whether we’re eating an image.\n\n  if (character === exclamationMark) {\n    type = image;\n    intro = character;\n    character = value.charAt(++index);\n  }\n\n  if (character !== leftSquareBracket) {\n    return;\n  }\n\n  index++;\n  intro += character;\n  queue = ''; // Check whether we’re eating a footnote.\n\n  if (self.options.footnotes && value.charAt(index) === caret) {\n    // Exit if `![^` is found, so the `!` will be seen as text after this,\n    // and we’ll enter this function again when `[^` is found.\n    if (type === image) {\n      return;\n    }\n\n    intro += caret;\n    index++;\n    type = footnote;\n  } // Eat the text.\n\n\n  depth = 0;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character === leftSquareBracket) {\n      bracketed = true;\n      depth++;\n    } else if (character === rightSquareBracket) {\n      if (!depth) {\n        break;\n      }\n\n      depth--;\n    }\n\n    if (character === backslash) {\n      queue += backslash;\n      character = value.charAt(++index);\n    }\n\n    queue += character;\n    index++;\n  }\n\n  subvalue = queue;\n  content = queue;\n  character = value.charAt(index);\n\n  if (character !== rightSquareBracket) {\n    return;\n  }\n\n  index++;\n  subvalue += character;\n  queue = '';\n\n  if (!commonmark) {\n    // The original markdown syntax definition explicitly allows for whitespace\n    // between the link text and link label; commonmark departs from this, in\n    // part to improve support for shortcut reference links\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (!whitespace(character)) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n  }\n\n  character = value.charAt(index); // Inline footnotes cannot have an identifier.\n\n  if (type !== footnote && character === leftSquareBracket) {\n    identifier = '';\n    queue += character;\n    index++;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character === leftSquareBracket || character === rightSquareBracket) {\n        break;\n      }\n\n      if (character === backslash) {\n        identifier += backslash;\n        character = value.charAt(++index);\n      }\n\n      identifier += character;\n      index++;\n    }\n\n    character = value.charAt(index);\n\n    if (character === rightSquareBracket) {\n      referenceType = identifier ? full : collapsed;\n      queue += identifier + character;\n      index++;\n    } else {\n      identifier = '';\n    }\n\n    subvalue += queue;\n    queue = '';\n  } else {\n    if (!content) {\n      return;\n    }\n\n    identifier = content;\n  } // Brackets cannot be inside the identifier.\n\n\n  if (referenceType !== full && bracketed) {\n    return;\n  }\n\n  subvalue = intro + subvalue;\n\n  if (type === link && self.inLink) {\n    return null;\n  }\n  /* istanbul ignore if - never used (yet) */\n\n\n  if (silent) {\n    return true;\n  }\n\n  if (type === footnote && content.indexOf(space) !== -1) {\n    return eat(subvalue)({\n      type: footnote,\n      children: this.tokenizeInline(content, eat.now())\n    });\n  }\n\n  now = eat.now();\n  now.column += intro.length;\n  now.offset += intro.length;\n  identifier = referenceType === full ? identifier : content;\n  node = {\n    type: type + 'Reference',\n    identifier: normalize(identifier),\n    label: identifier\n  };\n\n  if (type === link || type === image) {\n    node.referenceType = referenceType;\n  }\n\n  if (type === link) {\n    exit = self.enterLink();\n    node.children = self.tokenizeInline(content, now);\n    exit();\n  } else if (type === image) {\n    node.alt = self.decode.raw(self.unescape(content), now) || null;\n  }\n\n  return eat(subvalue)(node);\n}","map":{"version":3,"sources":["/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/remark-parse/lib/tokenize/reference.js"],"names":["whitespace","require","locate","normalize","module","exports","reference","locator","link","image","footnote","shortcut","collapsed","full","space","exclamationMark","leftSquareBracket","backslash","rightSquareBracket","caret","eat","value","silent","self","commonmark","options","character","charAt","index","length","subvalue","intro","type","referenceType","content","identifier","now","node","exit","queue","bracketed","depth","footnotes","inLink","indexOf","children","tokenizeInline","column","offset","label","enterLink","alt","decode","raw","unescape"],"mappings":"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","sourcesContent":["'use strict'\n\nvar whitespace = require('is-whitespace-character')\nvar locate = require('../locate/link')\nvar normalize = require('../util/normalize')\n\nmodule.exports = reference\nreference.locator = locate\n\nvar link = 'link'\nvar image = 'image'\nvar footnote = 'footnote'\nvar shortcut = 'shortcut'\nvar collapsed = 'collapsed'\nvar full = 'full'\nvar space = ' '\nvar exclamationMark = '!'\nvar leftSquareBracket = '['\nvar backslash = '\\\\'\nvar rightSquareBracket = ']'\nvar caret = '^'\n\nfunction reference(eat, value, silent) {\n  var self = this\n  var commonmark = self.options.commonmark\n  var character = value.charAt(0)\n  var index = 0\n  var length = value.length\n  var subvalue = ''\n  var intro = ''\n  var type = link\n  var referenceType = shortcut\n  var content\n  var identifier\n  var now\n  var node\n  var exit\n  var queue\n  var bracketed\n  var depth\n\n  // Check whether we’re eating an image.\n  if (character === exclamationMark) {\n    type = image\n    intro = character\n    character = value.charAt(++index)\n  }\n\n  if (character !== leftSquareBracket) {\n    return\n  }\n\n  index++\n  intro += character\n  queue = ''\n\n  // Check whether we’re eating a footnote.\n  if (self.options.footnotes && value.charAt(index) === caret) {\n    // Exit if `![^` is found, so the `!` will be seen as text after this,\n    // and we’ll enter this function again when `[^` is found.\n    if (type === image) {\n      return\n    }\n\n    intro += caret\n    index++\n    type = footnote\n  }\n\n  // Eat the text.\n  depth = 0\n\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (character === leftSquareBracket) {\n      bracketed = true\n      depth++\n    } else if (character === rightSquareBracket) {\n      if (!depth) {\n        break\n      }\n\n      depth--\n    }\n\n    if (character === backslash) {\n      queue += backslash\n      character = value.charAt(++index)\n    }\n\n    queue += character\n    index++\n  }\n\n  subvalue = queue\n  content = queue\n  character = value.charAt(index)\n\n  if (character !== rightSquareBracket) {\n    return\n  }\n\n  index++\n  subvalue += character\n  queue = ''\n\n  if (!commonmark) {\n    // The original markdown syntax definition explicitly allows for whitespace\n    // between the link text and link label; commonmark departs from this, in\n    // part to improve support for shortcut reference links\n    while (index < length) {\n      character = value.charAt(index)\n\n      if (!whitespace(character)) {\n        break\n      }\n\n      queue += character\n      index++\n    }\n  }\n\n  character = value.charAt(index)\n\n  // Inline footnotes cannot have an identifier.\n  if (type !== footnote && character === leftSquareBracket) {\n    identifier = ''\n    queue += character\n    index++\n\n    while (index < length) {\n      character = value.charAt(index)\n\n      if (character === leftSquareBracket || character === rightSquareBracket) {\n        break\n      }\n\n      if (character === backslash) {\n        identifier += backslash\n        character = value.charAt(++index)\n      }\n\n      identifier += character\n      index++\n    }\n\n    character = value.charAt(index)\n\n    if (character === rightSquareBracket) {\n      referenceType = identifier ? full : collapsed\n      queue += identifier + character\n      index++\n    } else {\n      identifier = ''\n    }\n\n    subvalue += queue\n    queue = ''\n  } else {\n    if (!content) {\n      return\n    }\n\n    identifier = content\n  }\n\n  // Brackets cannot be inside the identifier.\n  if (referenceType !== full && bracketed) {\n    return\n  }\n\n  subvalue = intro + subvalue\n\n  if (type === link && self.inLink) {\n    return null\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true\n  }\n\n  if (type === footnote && content.indexOf(space) !== -1) {\n    return eat(subvalue)({\n      type: footnote,\n      children: this.tokenizeInline(content, eat.now())\n    })\n  }\n\n  now = eat.now()\n  now.column += intro.length\n  now.offset += intro.length\n  identifier = referenceType === full ? identifier : content\n\n  node = {\n    type: type + 'Reference',\n    identifier: normalize(identifier),\n    label: identifier\n  }\n\n  if (type === link || type === image) {\n    node.referenceType = referenceType\n  }\n\n  if (type === link) {\n    exit = self.enterLink()\n    node.children = self.tokenizeInline(content, now)\n    exit()\n  } else if (type === image) {\n    node.alt = self.decode.raw(self.unescape(content), now) || null\n  }\n\n  return eat(subvalue)(node)\n}\n"]},"metadata":{},"sourceType":"script"}