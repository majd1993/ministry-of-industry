{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _memoizeOne = require('memoize-one');\n\nvar _memoizeOne2 = _interopRequireDefault(_memoizeOne);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _Context = require('./Context');\n\nvar _Context2 = _interopRequireDefault(_Context);\n\nvar _prefix = require('./prefix');\n\nvar _prefix2 = _interopRequireDefault(_prefix);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction abortable(recognition) {\n  return !!recognition.abort;\n}\n\nfunction chainListener() {\n  for (var _len = arguments.length, listeners = Array(_len), _key = 0; _key < _len; _key++) {\n    listeners[_key] = arguments[_key];\n  }\n\n  return function () {\n    var _this = this,\n        _arguments = arguments;\n\n    listeners.forEach(function (listener) {\n      return listener.apply(_this, _arguments);\n    });\n  };\n}\n\nvar Composer = function (_React$Component) {\n  _inherits(Composer, _React$Component);\n\n  function Composer(props) {\n    _classCallCheck(this, Composer);\n\n    var _this2 = _possibleConstructorReturn(this, (Composer.__proto__ || Object.getPrototypeOf(Composer)).call(this, props));\n\n    _this2.createGrammarList = (0, _memoizeOne2.default)(function (speechGrammarList, grammar) {\n      var grammarList = new speechGrammarList();\n      grammar && grammarList.addFromString(grammar, 1);\n      return grammarList;\n    });\n    _this2.createRecognition = (0, _memoizeOne2.default)(function (speechRecognition) {\n      return speechRecognition && new speechRecognition();\n    });\n    _this2.handleAudioEnd = _this2.handleAudioEnd.bind(_this2);\n    _this2.handleAudioStart = _this2.handleAudioStart.bind(_this2);\n    _this2.handleEnd = _this2.handleEnd.bind(_this2);\n    _this2.handleError = _this2.handleError.bind(_this2);\n    _this2.handleRawEvent = _this2.handleRawEvent.bind(_this2);\n    _this2.handleResult = _this2.handleResult.bind(_this2);\n    _this2.handleStart = _this2.handleStart.bind(_this2);\n    _this2.state = {\n      readyState: 0,\n      supported: !!props.speechRecognition\n    };\n    return _this2;\n  }\n\n  _createClass(Composer, [{\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(nextProps) {\n      var recognition = this.recognition;\n      var nextState = void 0;\n\n      if (nextProps.speechRecognition !== this.props.speechRecognition) {\n        if (recognition) {\n          if (abortable(recognition)) {\n            recognition.abort();\n          } else {\n            throw new Error('Cannot change \"speechRecognition\" prop while the current one is ongoing and is not abortable.');\n          }\n        }\n\n        recognition = this.recognition = null;\n        nextState = _extends({}, nextState, {\n          supported: !!nextProps.speechRecognition\n        });\n      }\n\n      if (nextProps.started !== this.props.started) {\n        if (nextProps.started) {\n          this.start(nextProps);\n          nextState = _extends({}, nextState, {\n            abortable: abortable(this.recognition)\n          });\n        } else {\n          if (recognition) {\n            if (abortable(recognition)) {\n              recognition.abort();\n            } else {\n              throw new Error('Cannot stop recognition while the current one is ongoing and is not abortable.');\n            }\n          }\n        }\n      }\n\n      nextState && this.setState(function () {\n        return nextState;\n      });\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      var recognition = this.recognition;\n\n      if (recognition) {\n        if (abortable(recognition)) {\n          recognition.abort();\n        } else {\n          console.warn('react-dictate-button: Component is unmounted but recognition is still ongoing because it is not abortable.');\n        }\n      }\n    }\n  }, {\n    key: 'handleAudioEnd',\n    value: function handleAudioEnd() {\n      this.setState(function () {\n        return {\n          readyState: 3\n        };\n      });\n    }\n  }, {\n    key: 'handleAudioStart',\n    value: function handleAudioStart() {\n      this.setState(function () {\n        return {\n          readyState: 2\n        };\n      }); // Web Speech API does not emit \"result\" when nothing is heard, and Chrome does not emit \"nomatch\" event.\n      // Because we emitted onProgress, we should emit \"dictate\" if not error, so they works in pair.\n\n      this.emitDictateOnEnd = true;\n      this.props.onProgress && this.props.onProgress({\n        abortable: abortable(this.recognition)\n      });\n    }\n  }, {\n    key: 'handleEnd',\n    value: function handleEnd() {\n      this.recognition = null;\n\n      if (this.emitDictateOnEnd) {\n        this.props.onDictate && this.props.onDictate({});\n      }\n\n      this.setState(function () {\n        return {\n          readyState: 0\n        };\n      });\n    }\n  }, {\n    key: 'handleError',\n    value: function handleError(event) {\n      this.setState(function () {\n        return _extends({\n          readyState: 0\n        }, event.error === 'not-allowed' && {\n          supported: false\n        });\n      }); // Error out, no need to emit \"dictate\"\n\n      this.emitDictateOnEnd = false;\n      this.recognition = null;\n      this.props.onError && this.props.onError(event);\n    }\n  }, {\n    key: 'handleRawEvent',\n    value: function handleRawEvent(event) {\n      this.props.onRawEvent && this.props.onRawEvent(event);\n    }\n  }, {\n    key: 'handleResult',\n    value: function handleResult(event) {\n      var props = this.props;\n      var rawResults = event.results;\n\n      if (rawResults.length) {\n        var results = [].map.call(rawResults, function (alts) {\n          var firstAlt = alts[0];\n          return {\n            confidence: firstAlt.confidence,\n            transcript: firstAlt.transcript\n          };\n        });\n        var first = rawResults[0];\n\n        if (first.isFinal) {\n          this.emitDictateOnEnd = false;\n          this.recognition = null;\n          props.onDictate && props.onDictate({\n            result: results[0]\n          });\n        } else {\n          props.onProgress && props.onProgress({\n            abortable: abortable(this.recognition),\n            results: results\n          });\n        }\n      }\n    }\n  }, {\n    key: 'handleStart',\n    value: function handleStart() {\n      this.setState(function () {\n        return {\n          readyState: 1\n        };\n      });\n    }\n  }, {\n    key: 'start',\n    value: function start(props) {\n      if (this.recognition) {\n        if (abortable(this.recognition)) {\n          this.recognition.abort();\n        } else {\n          throw new Error('Cannot start a new recognition while the current one is ongoing and is not abortable.');\n        }\n      }\n\n      if (!this.state.supported) {\n        throw new Error('Speech recognition is not supported');\n      }\n\n      var recognition = this.recognition = this.createRecognition(props.speechRecognition);\n      recognition.grammars = this.createGrammarList(props.speechGrammarList, props.grammar);\n      recognition.lang = props.lang;\n      recognition.interimResults = true;\n      recognition.onaudioend = chainListener(this.handleAudioEnd, this.handleRawEvent);\n      recognition.onaudiostart = chainListener(this.handleAudioStart, this.handleRawEvent);\n      recognition.onend = chainListener(this.handleEnd, this.handleRawEvent);\n      recognition.onerror = chainListener(this.handleError, this.handleRawEvent);\n      recognition.onnomatch = this.handleRawEvent;\n      recognition.onresult = chainListener(this.handleResult, this.handleRawEvent);\n      recognition.onsoundend = this.handleRawEvent;\n      recognition.onsoundstart = this.handleRawEvent;\n      recognition.onspeechend = this.handleRawEvent;\n      recognition.onspeechstart = this.handleRawEvent;\n      recognition.onstart = chainListener(this.handleStart, this.handleRawEvent);\n      props.extra && Object.keys(props.extra).forEach(function (key) {\n        recognition[key] = props.extra[key];\n      });\n      recognition.start();\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var props = this.props,\n          state = this.state;\n      var children = props.children;\n      return _react2.default.createElement(_Context2.default.Provider, {\n        value: state\n      }, _react2.default.createElement(_Context2.default.Consumer, null, function (context) {\n        return typeof children === 'function' ? children(context) : children;\n      }));\n    }\n  }]);\n\n  return Composer;\n}(_react2.default.Component);\n\nexports.default = Composer;\nComposer.defaultProps = {\n  speechGrammarList: (0, _prefix2.default)('SpeechGrammarList'),\n  speechRecognition: (0, _prefix2.default)('SpeechRecognition')\n};\nComposer.propTypes = {\n  extra: _propTypes2.default.any,\n  lang: _propTypes2.default.string,\n  onDictate: _propTypes2.default.func,\n  onError: _propTypes2.default.func,\n  onProgress: _propTypes2.default.func,\n  onRawEvent: _propTypes2.default.func,\n  speechGrammarList: _propTypes2.default.any,\n  speechRecognition: _propTypes2.default.any\n};","map":{"version":3,"sources":["../src/Composer.js"],"names":["recognition","listeners","listener","Composer","React","Component","grammarList","grammar","speechRecognition","readyState","supported","props","nextProps","nextState","abortable","console","event","rawResults","results","firstAlt","alts","confidence","transcript","first","result","chainListener","state","children","speechGrammarList","extra","PropTypes","lang","onDictate","onError","onProgress","onRawEvent","any"],"mappings":"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","sourcesContent":["import memoize from 'memoize-one';\nimport PropTypes from 'prop-types';\nimport React from 'react';\n\nimport Context from './Context';\nimport prefix from './prefix';\n\nfunction abortable(recognition) {\n  return !!recognition.abort;\n}\n\nfunction chainListener(...listeners) {\n  return function () {\n    listeners.forEach(listener => listener.apply(this, arguments))\n  };\n}\n\nexport default class Composer extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.createGrammarList = memoize((speechGrammarList, grammar) => {\n      const grammarList = new speechGrammarList();\n\n      grammar && grammarList.addFromString(grammar, 1);\n\n      return grammarList;\n    });\n\n    this.createRecognition = memoize(speechRecognition => speechRecognition && new speechRecognition());\n\n    this.handleAudioEnd = this.handleAudioEnd.bind(this);\n    this.handleAudioStart = this.handleAudioStart.bind(this);\n    this.handleEnd = this.handleEnd.bind(this);\n    this.handleError = this.handleError.bind(this);\n    this.handleRawEvent = this.handleRawEvent.bind(this);\n    this.handleResult = this.handleResult.bind(this);\n    this.handleStart = this.handleStart.bind(this);\n\n    this.state = {\n      readyState: 0,\n      supported: !!props.speechRecognition\n    };\n  }\n\n  componentWillReceiveProps(nextProps) {\n    let { recognition } = this;\n    let nextState;\n\n    if (nextProps.speechRecognition !== this.props.speechRecognition) {\n      if (recognition) {\n        if (abortable(recognition)) {\n          recognition.abort();\n        } else {\n          throw new Error('Cannot change \"speechRecognition\" prop while the current one is ongoing and is not abortable.');\n        }\n      }\n\n      recognition = this.recognition = null;\n\n      nextState = { ...nextState, supported: !!nextProps.speechRecognition };\n    }\n\n    if (nextProps.started !== this.props.started) {\n      if (nextProps.started) {\n        this.start(nextProps);\n\n        nextState = { ...nextState, abortable: abortable(this.recognition) };\n      } else {\n        if (recognition) {\n          if (abortable(recognition)) {\n            recognition.abort();\n          } else {\n            throw new Error('Cannot stop recognition while the current one is ongoing and is not abortable.');\n          }\n        }\n      }\n    }\n\n    nextState && this.setState(() => nextState);\n  }\n\n  componentWillUnmount() {\n    const { recognition } = this;\n\n    if (recognition) {\n      if (abortable(recognition)) {\n        recognition.abort();\n      } else {\n        console.warn('react-dictate-button: Component is unmounted but recognition is still ongoing because it is not abortable.');\n      }\n    }\n  }\n\n  handleAudioEnd() {\n    this.setState(() => ({ readyState: 3 }));\n  }\n\n  handleAudioStart() {\n    this.setState(() => ({ readyState: 2 }));\n\n    // Web Speech API does not emit \"result\" when nothing is heard, and Chrome does not emit \"nomatch\" event.\n    // Because we emitted onProgress, we should emit \"dictate\" if not error, so they works in pair.\n    this.emitDictateOnEnd = true;\n    this.props.onProgress && this.props.onProgress({ abortable: abortable(this.recognition) });\n  }\n\n  handleEnd() {\n    this.recognition = null;\n\n    if (this.emitDictateOnEnd) {\n      this.props.onDictate && this.props.onDictate({});\n    }\n\n    this.setState(() => ({ readyState: 0 }));\n  }\n\n  handleError(event) {\n    this.setState(() => ({\n      readyState: 0,\n      ...(event.error === 'not-allowed' && { supported: false })\n    }));\n\n    // Error out, no need to emit \"dictate\"\n    this.emitDictateOnEnd = false;\n    this.recognition = null;\n    this.props.onError && this.props.onError(event);\n  }\n\n  handleRawEvent(event) {\n    this.props.onRawEvent && this.props.onRawEvent(event);\n  }\n\n  handleResult(event) {\n    const { props } = this;\n    const { results: rawResults } = event;\n\n    if (rawResults.length) {\n      const results = [].map.call(rawResults, alts => {\n        const firstAlt = alts[0];\n\n        return {\n          confidence: firstAlt.confidence,\n          transcript: firstAlt.transcript\n        };\n      });\n\n      const first = rawResults[0];\n\n      if (first.isFinal) {\n        this.emitDictateOnEnd = false;\n        this.recognition = null;\n        props.onDictate && props.onDictate({ result: results[0] });\n      } else {\n        props.onProgress && props.onProgress({ abortable: abortable(this.recognition), results });\n      }\n    }\n  }\n\n  handleStart() {\n    this.setState(() => ({ readyState: 1 }));\n  }\n\n  start(props) {\n    if (this.recognition) {\n      if (abortable(this.recognition)) {\n        this.recognition.abort();\n      } else {\n        throw new Error('Cannot start a new recognition while the current one is ongoing and is not abortable.');\n      }\n    }\n\n    if (!this.state.supported) {\n      throw new Error('Speech recognition is not supported');\n    }\n\n    const recognition = this.recognition = this.createRecognition(props.speechRecognition);\n\n    recognition.grammars = this.createGrammarList(props.speechGrammarList, props.grammar);\n    recognition.lang = props.lang;\n    recognition.interimResults = true;\n    recognition.onaudioend = chainListener(this.handleAudioEnd, this.handleRawEvent);\n    recognition.onaudiostart = chainListener(this.handleAudioStart, this.handleRawEvent);\n    recognition.onend = chainListener(this.handleEnd, this.handleRawEvent);\n    recognition.onerror = chainListener(this.handleError, this.handleRawEvent);\n    recognition.onnomatch = this.handleRawEvent;\n    recognition.onresult = chainListener(this.handleResult, this.handleRawEvent);\n    recognition.onsoundend = this.handleRawEvent;\n    recognition.onsoundstart = this.handleRawEvent;\n    recognition.onspeechend = this.handleRawEvent;\n    recognition.onspeechstart = this.handleRawEvent;\n    recognition.onstart = chainListener(this.handleStart, this.handleRawEvent);\n\n    props.extra && Object.keys(props.extra).forEach(key => {\n      recognition[key] = props.extra[key];\n    });\n\n    recognition.start();\n  }\n\n  render() {\n    const { props, state } = this;\n    const { children } = props;\n\n    return (\n      <Context.Provider value={ state }>\n        <Context.Consumer>\n          { context => typeof children === 'function' ? children(context) : children }\n        </Context.Consumer>\n      </Context.Provider>\n    );\n  }\n}\n\nComposer.defaultProps = {\n  speechGrammarList: prefix('SpeechGrammarList'),\n  speechRecognition: prefix('SpeechRecognition')\n};\n\nComposer.propTypes = {\n  extra: PropTypes.any,\n  lang: PropTypes.string,\n  onDictate: PropTypes.func,\n  onError: PropTypes.func,\n  onProgress: PropTypes.func,\n  onRawEvent: PropTypes.func,\n  speechGrammarList: PropTypes.any,\n  speechRecognition: PropTypes.any\n};\n"]},"metadata":{},"sourceType":"script"}