{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Exports_1 = require(\"../common.speech/Exports\");\n\nvar Exports_2 = require(\"../common/Exports\");\n\nvar AudioStreamFormat_1 = require(\"../sdk/Audio/AudioStreamFormat\");\n\nvar FileAudioSource =\n/** @class */\nfunction () {\n  function FileAudioSource(file, audioSourceId) {\n    var _this = this;\n\n    this.privStreams = {};\n\n    this.turnOn = function () {\n      if (typeof FileReader === \"undefined\") {\n        var errorMsg = \"Browser does not support FileReader.\";\n\n        _this.onEvent(new Exports_2.AudioSourceErrorEvent(errorMsg, \"\")); // initialization error - no streamid at this point\n\n\n        return Exports_2.PromiseHelper.fromError(errorMsg);\n      } else if (_this.privFile.name.lastIndexOf(\".wav\") !== _this.privFile.name.length - 4) {\n        var errorMsg = _this.privFile.name + \" is not supported. Only WAVE files are allowed at the moment.\";\n\n        _this.onEvent(new Exports_2.AudioSourceErrorEvent(errorMsg, \"\"));\n\n        return Exports_2.PromiseHelper.fromError(errorMsg);\n      }\n\n      _this.onEvent(new Exports_2.AudioSourceInitializingEvent(_this.privId)); // no stream id\n\n\n      _this.onEvent(new Exports_2.AudioSourceReadyEvent(_this.privId));\n\n      return Exports_2.PromiseHelper.fromResult(true);\n    };\n\n    this.id = function () {\n      return _this.privId;\n    };\n\n    this.attach = function (audioNodeId) {\n      _this.onEvent(new Exports_2.AudioStreamNodeAttachingEvent(_this.privId, audioNodeId));\n\n      return _this.upload(audioNodeId).onSuccessContinueWith(function (stream) {\n        _this.onEvent(new Exports_2.AudioStreamNodeAttachedEvent(_this.privId, audioNodeId));\n\n        return {\n          detach: function detach() {\n            stream.readEnded();\n            delete _this.privStreams[audioNodeId];\n\n            _this.onEvent(new Exports_2.AudioStreamNodeDetachedEvent(_this.privId, audioNodeId));\n\n            _this.turnOff();\n          },\n          id: function id() {\n            return audioNodeId;\n          },\n          read: function read() {\n            return stream.read();\n          }\n        };\n      });\n    };\n\n    this.detach = function (audioNodeId) {\n      if (audioNodeId && _this.privStreams[audioNodeId]) {\n        _this.privStreams[audioNodeId].close();\n\n        delete _this.privStreams[audioNodeId];\n\n        _this.onEvent(new Exports_2.AudioStreamNodeDetachedEvent(_this.privId, audioNodeId));\n      }\n    };\n\n    this.turnOff = function () {\n      for (var streamId in _this.privStreams) {\n        if (streamId) {\n          var stream = _this.privStreams[streamId];\n\n          if (stream && !stream.isClosed) {\n            stream.close();\n          }\n        }\n      }\n\n      _this.onEvent(new Exports_2.AudioSourceOffEvent(_this.privId)); // no stream now\n\n\n      return Exports_2.PromiseHelper.fromResult(true);\n    };\n\n    this.readHeader = function () {\n      // Read the wave header.\n      var header = _this.privFile.slice(0, 44);\n\n      var headerReader = new FileReader();\n      var headerResult = new Exports_2.Deferred();\n\n      var processHeader = function processHeader(event) {\n        var header = event.target.result;\n        var view = new DataView(header); // RIFF 4 bytes.\n\n        var riff = String.fromCharCode(view.getUint8(0), view.getUint8(1), view.getUint8(2), view.getUint8(3));\n\n        if (\"RIFF\" !== riff) {\n          headerResult.reject(\"Invalid WAV header in file, RIFF was not found\");\n        } // length, 4 bytes\n        // RIFF Type & fmt 8 bytes\n\n\n        var type = String.fromCharCode(view.getUint8(8), view.getUint8(9), view.getUint8(10), view.getUint8(11), view.getUint8(12), view.getUint8(13), view.getUint8(14));\n\n        if (\"WAVEfmt\" !== type) {\n          headerResult.reject(\"Invalid WAV header in file, WAVEfmt was not found\");\n        }\n\n        var channelCount = view.getUint16(22, true);\n        var sampleRate = view.getUint32(24, true);\n        var bitsPerSample = view.getUint16(34, true);\n        headerResult.resolve(AudioStreamFormat_1.AudioStreamFormat.getWaveFormatPCM(sampleRate, bitsPerSample, channelCount));\n      };\n\n      headerReader.onload = processHeader;\n      headerReader.readAsArrayBuffer(header);\n      return headerResult.promise();\n    };\n\n    this.upload = function (audioNodeId) {\n      return _this.turnOn().onSuccessContinueWithPromise(function (_) {\n        return _this.privAudioFormatPromise.onSuccessContinueWith(function (format) {\n          var fileStream = new Exports_2.ChunkedArrayBufferStream(3200);\n          var reader = new FileReader();\n          var stream = new Exports_2.ChunkedArrayBufferStream(format.avgBytesPerSec / 10, audioNodeId);\n          _this.privStreams[audioNodeId] = stream;\n\n          var processFile = function processFile(event) {\n            if (stream.isClosed) {\n              return; // output stream was closed (somebody called TurnOff). We're done here.\n            }\n\n            stream.writeStreamChunk({\n              buffer: reader.result,\n              isEnd: false,\n              timeReceived: Date.now()\n            });\n            stream.close();\n          };\n\n          reader.onload = processFile;\n\n          reader.onerror = function (event) {\n            var errorMsg = \"Error occurred while processing '\" + _this.privFile.name + \"'. \" + event;\n\n            _this.onEvent(new Exports_2.AudioStreamNodeErrorEvent(_this.privId, audioNodeId, errorMsg));\n\n            throw new Error(errorMsg);\n          };\n\n          var chunk = _this.privFile.slice(44);\n\n          reader.readAsArrayBuffer(chunk);\n          return stream;\n        });\n      });\n    };\n\n    this.onEvent = function (event) {\n      _this.privEvents.onEvent(event);\n\n      Exports_2.Events.instance.onEvent(event);\n    };\n\n    this.privId = audioSourceId ? audioSourceId : Exports_2.createNoDashGuid();\n    this.privEvents = new Exports_2.EventSource();\n    this.privFile = file; // Read the header.\n\n    this.privAudioFormatPromise = this.readHeader();\n  }\n\n  Object.defineProperty(FileAudioSource.prototype, \"format\", {\n    get: function get() {\n      return this.privAudioFormatPromise;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FileAudioSource.prototype, \"blob\", {\n    get: function get() {\n      return Exports_2.PromiseHelper.fromResult(this.privFile);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FileAudioSource.prototype, \"events\", {\n    get: function get() {\n      return this.privEvents;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FileAudioSource.prototype, \"deviceInfo\", {\n    get: function get() {\n      return this.privAudioFormatPromise.onSuccessContinueWithPromise(function (result) {\n        return Exports_2.PromiseHelper.fromResult({\n          bitspersample: result.bitsPerSample,\n          channelcount: result.channels,\n          connectivity: Exports_1.connectivity.Unknown,\n          manufacturer: \"Speech SDK\",\n          model: \"File\",\n          samplerate: result.samplesPerSec,\n          type: Exports_1.type.File\n        });\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return FileAudioSource;\n}();\n\nexports.FileAudioSource = FileAudioSource;","map":{"version":3,"sources":["src/common.browser/FileAudioSource.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    connectivity,\r\n    ISpeechConfigAudioDevice,\r\n    type,\r\n} from \"../common.speech/Exports\";\r\nimport {\r\n    AudioSourceErrorEvent,\r\n    AudioSourceEvent,\r\n    AudioSourceInitializingEvent,\r\n    AudioSourceOffEvent,\r\n    AudioSourceReadyEvent,\r\n    AudioStreamNodeAttachedEvent,\r\n    AudioStreamNodeAttachingEvent,\r\n    AudioStreamNodeDetachedEvent,\r\n    AudioStreamNodeErrorEvent,\r\n    ChunkedArrayBufferStream,\r\n    createNoDashGuid,\r\n    Deferred,\r\n    Events,\r\n    EventSource,\r\n    IAudioSource,\r\n    IAudioStreamNode,\r\n    IStringDictionary,\r\n    Promise,\r\n    PromiseHelper,\r\n    Stream,\r\n} from \"../common/Exports\";\r\nimport { AudioStreamFormat, AudioStreamFormatImpl } from \"../sdk/Audio/AudioStreamFormat\";\r\n\r\nexport class FileAudioSource implements IAudioSource {\r\n\r\n    private privAudioFormatPromise: Promise<AudioStreamFormatImpl>;\r\n\r\n    private privStreams: IStringDictionary<Stream<ArrayBuffer>> = {};\r\n\r\n    private privId: string;\r\n\r\n    private privEvents: EventSource<AudioSourceEvent>;\r\n\r\n    private privFile: File;\r\n\r\n    public constructor(file: File, audioSourceId?: string) {\r\n        this.privId = audioSourceId ? audioSourceId : createNoDashGuid();\r\n        this.privEvents = new EventSource<AudioSourceEvent>();\r\n        this.privFile = file;\r\n\r\n        // Read the header.\r\n        this.privAudioFormatPromise = this.readHeader();\r\n    }\r\n\r\n    public get format(): Promise<AudioStreamFormatImpl> {\r\n        return this.privAudioFormatPromise;\r\n    }\r\n\r\n    public get blob(): Promise<Blob | Buffer> {\r\n        return PromiseHelper.fromResult(this.privFile);\r\n    }\r\n\r\n    public turnOn = (): Promise<boolean> => {\r\n        if (typeof FileReader === \"undefined\") {\r\n            const errorMsg = \"Browser does not support FileReader.\";\r\n            this.onEvent(new AudioSourceErrorEvent(errorMsg, \"\")); // initialization error - no streamid at this point\r\n            return PromiseHelper.fromError<boolean>(errorMsg);\r\n        } else if (this.privFile.name.lastIndexOf(\".wav\") !== this.privFile.name.length - 4) {\r\n            const errorMsg = this.privFile.name + \" is not supported. Only WAVE files are allowed at the moment.\";\r\n            this.onEvent(new AudioSourceErrorEvent(errorMsg, \"\"));\r\n            return PromiseHelper.fromError<boolean>(errorMsg);\r\n        }\r\n\r\n        this.onEvent(new AudioSourceInitializingEvent(this.privId)); // no stream id\r\n        this.onEvent(new AudioSourceReadyEvent(this.privId));\r\n        return PromiseHelper.fromResult(true);\r\n    }\r\n\r\n    public id = (): string => {\r\n        return this.privId;\r\n    }\r\n\r\n    public attach = (audioNodeId: string): Promise<IAudioStreamNode> => {\r\n        this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\r\n\r\n        return this.upload(audioNodeId).onSuccessContinueWith<IAudioStreamNode>(\r\n            (stream: Stream<ArrayBuffer>) => {\r\n                this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\r\n                return {\r\n                    detach: () => {\r\n                        stream.readEnded();\r\n                        delete this.privStreams[audioNodeId];\r\n                        this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\r\n                        this.turnOff();\r\n                    },\r\n                    id: () => {\r\n                        return audioNodeId;\r\n                    },\r\n                    read: () => {\r\n                        return stream.read();\r\n                    },\r\n                };\r\n            });\r\n    }\r\n\r\n    public detach = (audioNodeId: string): void => {\r\n        if (audioNodeId && this.privStreams[audioNodeId]) {\r\n            this.privStreams[audioNodeId].close();\r\n            delete this.privStreams[audioNodeId];\r\n            this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\r\n        }\r\n    }\r\n\r\n    public turnOff = (): Promise<boolean> => {\r\n        for (const streamId in this.privStreams) {\r\n            if (streamId) {\r\n                const stream = this.privStreams[streamId];\r\n                if (stream && !stream.isClosed) {\r\n                    stream.close();\r\n                }\r\n            }\r\n        }\r\n\r\n        this.onEvent(new AudioSourceOffEvent(this.privId)); // no stream now\r\n        return PromiseHelper.fromResult(true);\r\n    }\r\n\r\n    public get events(): EventSource<AudioSourceEvent> {\r\n        return this.privEvents;\r\n    }\r\n\r\n    public get deviceInfo(): Promise<ISpeechConfigAudioDevice> {\r\n        return this.privAudioFormatPromise.onSuccessContinueWithPromise<ISpeechConfigAudioDevice>((result: AudioStreamFormatImpl) => {\r\n            return PromiseHelper.fromResult({\r\n                bitspersample: result.bitsPerSample,\r\n                channelcount: result.channels,\r\n                connectivity: connectivity.Unknown,\r\n                manufacturer: \"Speech SDK\",\r\n                model: \"File\",\r\n                samplerate: result.samplesPerSec,\r\n                type: type.File,\r\n            });\r\n        });\r\n    }\r\n\r\n    private readHeader = (): Promise<AudioStreamFormatImpl> => {\r\n        // Read the wave header.\r\n        const header: Blob = this.privFile.slice(0, 44);\r\n        const headerReader: FileReader = new FileReader();\r\n\r\n        const headerResult: Deferred<AudioStreamFormatImpl> = new Deferred<AudioStreamFormatImpl>();\r\n\r\n        const processHeader = (event: Event): void => {\r\n            const header: ArrayBuffer = (event.target as FileReader).result as ArrayBuffer;\r\n\r\n            const view: DataView = new DataView(header);\r\n\r\n            // RIFF 4 bytes.\r\n            const riff: string = String.fromCharCode(view.getUint8(0), view.getUint8(1), view.getUint8(2), view.getUint8(3));\r\n            if (\"RIFF\" !== riff) {\r\n                headerResult.reject(\"Invalid WAV header in file, RIFF was not found\");\r\n            }\r\n\r\n            // length, 4 bytes\r\n            // RIFF Type & fmt 8 bytes\r\n            const type: string = String.fromCharCode(\r\n                view.getUint8(8),\r\n                view.getUint8(9),\r\n                view.getUint8(10),\r\n                view.getUint8(11),\r\n                view.getUint8(12),\r\n                view.getUint8(13),\r\n                view.getUint8(14));\r\n            if (\"WAVEfmt\" !== type) {\r\n                headerResult.reject(\"Invalid WAV header in file, WAVEfmt was not found\");\r\n            }\r\n\r\n            const channelCount: number = view.getUint16(22, true);\r\n            const sampleRate: number = view.getUint32(24, true);\r\n            const bitsPerSample: number = view.getUint16(34, true);\r\n\r\n            headerResult.resolve(AudioStreamFormat.getWaveFormatPCM(sampleRate, bitsPerSample, channelCount) as AudioStreamFormatImpl);\r\n\r\n        };\r\n\r\n        headerReader.onload = processHeader;\r\n        headerReader.readAsArrayBuffer(header);\r\n        return headerResult.promise();\r\n    }\r\n\r\n    private upload = (audioNodeId: string): Promise<Stream<ArrayBuffer>> => {\r\n        return this.turnOn()\r\n            .onSuccessContinueWithPromise<Stream<ArrayBuffer>>((_: boolean) => {\r\n                return this.privAudioFormatPromise.onSuccessContinueWith<Stream<ArrayBuffer>>((format: AudioStreamFormatImpl) => {\r\n                    const fileStream: ChunkedArrayBufferStream = new ChunkedArrayBufferStream(3200);\r\n\r\n                    const reader: FileReader = new FileReader();\r\n\r\n                    const stream = new ChunkedArrayBufferStream(format.avgBytesPerSec / 10, audioNodeId);\r\n\r\n                    this.privStreams[audioNodeId] = stream;\r\n\r\n                    const processFile = (event: Event): void => {\r\n                        if (stream.isClosed) {\r\n                            return; // output stream was closed (somebody called TurnOff). We're done here.\r\n                        }\r\n\r\n                        stream.writeStreamChunk({\r\n                            buffer: reader.result as ArrayBuffer,\r\n                            isEnd: false,\r\n                            timeReceived: Date.now(),\r\n                        });\r\n                        stream.close();\r\n                    };\r\n\r\n                    reader.onload = processFile;\r\n\r\n                    reader.onerror = (event: ProgressEvent) => {\r\n                        const errorMsg = `Error occurred while processing '${this.privFile.name}'. ${event}`;\r\n                        this.onEvent(new AudioStreamNodeErrorEvent(this.privId, audioNodeId, errorMsg));\r\n                        throw new Error(errorMsg);\r\n                    };\r\n\r\n                    const chunk = this.privFile.slice(44);\r\n                    reader.readAsArrayBuffer(chunk);\r\n\r\n                    return stream;\r\n                });\r\n            });\r\n\r\n    }\r\n\r\n    private onEvent = (event: AudioSourceEvent): void => {\r\n        this.privEvents.onEvent(event);\r\n        Events.instance.onEvent(event);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}