{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = fetchVoices;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _SpeechSynthesisVoice = _interopRequireDefault(require(\"./SpeechSynthesisVoice\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction fetchVoices(_x) {\n  return _fetchVoices.apply(this, arguments);\n}\n\nfunction _fetchVoices() {\n  _fetchVoices = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(_ref) {\n    var authorizationToken, region, speechSynthesisHostname, subscriptionKey, hostname, res, voices;\n    return _regenerator.default.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            authorizationToken = _ref.authorizationToken, region = _ref.region, speechSynthesisHostname = _ref.speechSynthesisHostname, subscriptionKey = _ref.subscriptionKey; // Although encodeURI on a hostname doesn't work as expected for hostname, at least, it will fail peacefully.\n\n            hostname = speechSynthesisHostname || \"\".concat(encodeURI(region), \".tts.speech.microsoft.com\");\n            _context.next = 4;\n            return fetch(\"https://\".concat(hostname, \"/cognitiveservices/voices/list\"), {\n              headers: _objectSpread({\n                'content-type': 'application/json'\n              }, authorizationToken ? {\n                authorization: \"Bearer \".concat(authorizationToken)\n              } : {\n                'Ocp-Apim-Subscription-Key': subscriptionKey\n              })\n            });\n\n          case 4:\n            res = _context.sent;\n\n            if (res.ok) {\n              _context.next = 7;\n              break;\n            }\n\n            throw new Error('Failed to fetch voices');\n\n          case 7:\n            _context.next = 9;\n            return res.json();\n\n          case 9:\n            voices = _context.sent;\n            return _context.abrupt(\"return\", voices.map(function (_ref2) {\n              var gender = _ref2.Gender,\n                  lang = _ref2.Locale,\n                  voiceURI = _ref2.Name;\n              return new _SpeechSynthesisVoice.default({\n                gender: gender,\n                lang: lang,\n                voiceURI: voiceURI\n              });\n            }).sort(function (_ref3, _ref4) {\n              var x = _ref3.name;\n              var y = _ref4.name;\n              return x > y ? 1 : x < y ? -1 : 0;\n            }));\n\n          case 11:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _fetchVoices.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../src/SpeechServices/TextToSpeech/fetchVoices.js"],"names":["fetchVoices","authorizationToken","region","speechSynthesisHostname","subscriptionKey","hostname","encodeURI","res","fetch","headers","authorization","voices","gender","lang","voiceURI","SpeechSynthesisVoice","x","y"],"mappings":";;;;;;;;;;;;;;;AAEA,IAAA,qBAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,wBAAA,CAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SAE8BA,W;;;;;yFAAf,SAAA,OAAA,CAAA,IAAA,EAAA;AAAA,QAAA,kBAAA,EAAA,MAAA,EAAA,uBAAA,EAAA,eAAA,EAAA,QAAA,EAAA,GAAA,EAAA,MAAA;AAAA,WAAA,YAAA,CAAA,OAAA,CAAA,IAAA,CAAA,SAAA,QAAA,CAAA,QAAA,EAAA;AAAA,aAAA,CAAA,EAAA;AAAA,gBAAA,QAAA,CAAA,IAAA,GAAA,QAAA,CAAA,IAAA;AAAA,eAAA,CAAA;AAA6BC,YAAAA,kBAA7B,GAAA,IAAA,CAAA,kBAA6BA,EAAoBC,MAAjD,GAAA,IAAA,CAAA,MAA6BD,EAA4BE,uBAAzD,GAAA,IAAA,CAAA,uBAA6BF,EAAqDG,eAAlF,GAAA,IAAA,CAAA,eAA6BH,CAA7B,CACb;;AACMI,YAAAA,QAFO,GAEIF,uBAAuB,IAAA,GAAA,MAAA,CAAQG,SAAS,CAAjB,MAAiB,CAAjB,EAF3B,2BAE2B,CAAlCD;AAFO,YAAA,QAAA,CAAA,IAAA,GAAA,CAAA;AAAA,mBAGKG,KAAK,CAAA,WAAA,MAAA,CAAA,QAAA,EAAA,gCAAA,CAAA,EAAwD;AAC7EC,cAAAA,OAAO,EAAA,aAAA,CAAA;AACL,gCAAgB;AADX,eAAA,EAEDR,kBAAkB,GAClB;AACES,gBAAAA,aAAa,EAAA,UAAA,MAAA,CAAA,kBAAA;AADf,eADkB,GAIlB;AACE,6CAA6BN;AAD/B,eANC;AADsE,aAAxD,CAHV;;AAAA,eAAA,CAAA;AAGPG,YAAAA,GAHO,GAAA,QAAA,CAAA,IAGPA;;AAHO,gBAgBRA,GAAG,CAhBK,EAAA,EAAA;AAAA,cAAA,QAAA,CAAA,IAAA,GAAA,CAAA;AAAA;AAAA;;AAAA,kBAiBL,IAAA,KAAA,CAjBK,wBAiBL,CAjBK;;AAAA,eAAA,CAAA;AAAA,YAAA,QAAA,CAAA,IAAA,GAAA,CAAA;AAAA,mBAoBQA,GAAG,CApBX,IAoBQA,EApBR;;AAAA,eAAA,CAAA;AAoBPI,YAAAA,MApBO,GAAA,QAAA,CAAA,IAoBPA;AApBO,mBAAA,QAAA,CAAA,MAAA,CAAA,QAAA,EAsBN,MAAM,CAAN,GAAA,CACA,UAAA,KAAA,EAAA;AAAA,kBAAWC,MAAX,GAAA,KAAA,CAAA,MAAA;AAAA,kBAA2BC,IAA3B,GAAA,KAAA,CAAA,MAAA;AAAA,kBAAuCC,QAAvC,GAAA,KAAA,CAAA,IAAA;AAAA,qBAAsD,IAAIC,qBAAAA,CAAJ,OAAA,CAAyB;AAAEH,gBAAAA,MAAM,EAAR,MAAA;AAAUC,gBAAAA,IAAI,EAAd,IAAA;AAAgBC,gBAAAA,QAAQ,EAARA;AAAhB,eAAzB,CAAtD;AADA,aAAA,EAAA,IAAA,CAEC,UAAA,KAAA,EAAA,KAAA,EAAA;AAAA,kBAASE,CAAT,GAAA,KAAA,CAAA,IAAA;AAAA,kBAAsBC,CAAtB,GAAA,KAAA,CAAA,IAAA;AAAA,qBAA+BD,CAAC,GAADA,CAAAA,GAAAA,CAAAA,GAAYA,CAAC,GAADA,CAAAA,GAAQ,CAARA,CAAAA,GAA3C,CAAA;AAxBK,aAsBN,CAtBM,CAAA;;AAAA,eAAA,EAAA;AAAA,eAAA,KAAA;AAAA,mBAAA,QAAA,CAAA,IAAA,EAAA;AAAA;AAAA;AAAA,KAAA,EAAA,OAAA,CAAA","sourcesContent":["/* eslint no-magic-numbers: [\"error\", { \"ignore\": [0, 1, -1] }] */\n\nimport SpeechSynthesisVoice from './SpeechSynthesisVoice';\n\nexport default async function fetchVoices({ authorizationToken, region, speechSynthesisHostname, subscriptionKey }) {\n  // Although encodeURI on a hostname doesn't work as expected for hostname, at least, it will fail peacefully.\n  const hostname = speechSynthesisHostname || `${ encodeURI(region) }.tts.speech.microsoft.com`;\n  const res = await fetch(`https://${ hostname }/cognitiveservices/voices/list`, {\n    headers: {\n      'content-type': 'application/json',\n      ...(authorizationToken\n        ? {\n            authorization: `Bearer ${ authorizationToken }`\n          }\n        : {\n            'Ocp-Apim-Subscription-Key': subscriptionKey\n          })\n    }\n  });\n\n  if (!res.ok) {\n    throw new Error('Failed to fetch voices');\n  }\n\n  const voices = await res.json();\n\n  return voices\n    .map(({ Gender: gender, Locale: lang, Name: voiceURI }) => new SpeechSynthesisVoice({ gender, lang, voiceURI }))\n    .sort(({ name: x }, { name: y }) => (x > y ? 1 : x < y ? -1 : 0));\n}\n"]},"metadata":{},"sourceType":"script"}