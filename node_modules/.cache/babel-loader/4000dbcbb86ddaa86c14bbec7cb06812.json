{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _createCustomEvent = _interopRequireDefault(require(\"./createCustomEvent\"));\n\nvar _createDeferred = _interopRequireDefault(require(\"./createDeferred\"));\n\nvar _createErrorEvent = _interopRequireDefault(require(\"./createErrorEvent\"));\n\nfunction speakUtterance(ponyfill, utterance, startCallback) {\n  var speechSynthesis, startDeferred, errorDeferred, endDeferred, startEvent, finishedSpeaking, endPromise, endEvent;\n  return _regenerator[\"default\"].async(function speakUtterance$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          speechSynthesis = ponyfill.speechSynthesis;\n          startDeferred = (0, _createDeferred[\"default\"])();\n          errorDeferred = (0, _createDeferred[\"default\"])();\n          endDeferred = (0, _createDeferred[\"default\"])();\n          utterance.addEventListener('end', endDeferred.resolve);\n          utterance.addEventListener('error', errorDeferred.resolve);\n          utterance.addEventListener('start', startDeferred.resolve); // if (speechSynthesis.speaking) {\n          //   console.warn(`ASSERTION: speechSynthesis.speaking should not be truthy before we call speak`);\n          // }\n\n          speechSynthesis.speak(utterance);\n          _context2.next = 10;\n          return _regenerator[\"default\"].awrap(Promise.race([errorDeferred.promise, startDeferred.promise]));\n\n        case 10:\n          startEvent = _context2.sent;\n\n          if (!(startEvent.type === 'error')) {\n            _context2.next = 13;\n            break;\n          }\n\n          throw startEvent.error;\n\n        case 13:\n          endPromise = Promise.race([errorDeferred.promise, endDeferred.promise]);\n          startCallback && startCallback(function _callee() {\n            return _regenerator[\"default\"].async(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    if (finishedSpeaking) {\n                      _context.next = 4;\n                      break;\n                    }\n\n                    speechSynthesis.cancel();\n                    _context.next = 4;\n                    return _regenerator[\"default\"].awrap(endPromise);\n\n                  case 4:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            });\n          });\n          _context2.next = 17;\n          return _regenerator[\"default\"].awrap(endPromise);\n\n        case 17:\n          endEvent = _context2.sent;\n          finishedSpeaking = true; // if (speechSynthesis.speaking) {\n          //   console.warn(`ASSERTION: speechSynthesis.speaking should not be truthy after speak is stopped`);\n          // }\n          // console.debug(`ENDED: ${ utterance.text }`);\n\n          if (!(endEvent.type === 'error')) {\n            _context2.next = 21;\n            break;\n          }\n\n          throw endEvent.error;\n\n        case 21:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  });\n}\n\nvar QueuedUtterance = /*#__PURE__*/function () {\n  function QueuedUtterance(ponyfill, utterance, _ref) {\n    var onEnd = _ref.onEnd,\n        onError = _ref.onError,\n        onStart = _ref.onStart;\n    (0, _classCallCheck2[\"default\"])(this, QueuedUtterance);\n    this._cancelled = false;\n    this._deferred = (0, _createDeferred[\"default\"])();\n    this._onEnd = onEnd;\n    this._onError = onError;\n    this._onStart = onStart;\n    this._ponyfill = ponyfill;\n    this._speaking = false;\n    this._utterance = utterance;\n    this.promise = this._deferred.promise;\n  }\n\n  (0, _createClass2[\"default\"])(QueuedUtterance, [{\n    key: \"cancel\",\n    value: function cancel() {\n      return _regenerator[\"default\"].async(function cancel$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              this._cancelled = true;\n              _context3.t0 = this._cancel;\n\n              if (!_context3.t0) {\n                _context3.next = 5;\n                break;\n              }\n\n              _context3.next = 5;\n              return _regenerator[\"default\"].awrap(this._cancel());\n\n            case 5:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, null, this);\n    }\n  }, {\n    key: \"speak\",\n    value: function speak() {\n      var _this = this;\n\n      if (this._speaking) {\n        console.warn(\"ASSERTION: QueuedUtterance is already speaking or has spoken.\");\n      }\n\n      this._speaking = true;\n      (function _callee2() {\n        return _regenerator[\"default\"].async(function _callee2$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!_this._cancelled) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                throw new Error('cancelled');\n\n              case 2:\n                _context4.next = 4;\n                return _regenerator[\"default\"].awrap(speakUtterance(_this._ponyfill, _this._utterance, function (cancel) {\n                  if (_this._cancelled) {\n                    cancel();\n                    throw new Error('cancelled');\n                  } else {\n                    _this._cancel = cancel;\n                    _this._onStart && _this._onStart((0, _createCustomEvent[\"default\"])('start'));\n                  }\n                }));\n\n              case 4:\n                if (!_this._cancelled) {\n                  _context4.next = 6;\n                  break;\n                }\n\n                throw new Error('cancelled');\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        });\n      })().then(function () {\n        _this._onEnd && _this._onEnd((0, _createCustomEvent[\"default\"])('end'));\n\n        _this._deferred.resolve();\n      }, function (error) {\n        _this._onError && _this._onError((0, _createErrorEvent[\"default\"])(error));\n\n        _this._deferred.reject(error);\n      });\n      return this.promise;\n    }\n  }]);\n  return QueuedUtterance;\n}();\n\nexports[\"default\"] = QueuedUtterance;","map":{"version":3,"sources":["../src/QueuedUtterance.js"],"names":["speechSynthesis","ponyfill","startDeferred","errorDeferred","endDeferred","utterance","startEvent","Promise","endPromise","startCallback","endEvent","finishedSpeaking","QueuedUtterance","onEnd","onError","onStart","_cancel","console","speakUtterance","cancel"],"mappings":"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","sourcesContent":["import createCustomEvent from './createCustomEvent';\nimport createDeferred from './createDeferred';\nimport createErrorEvent from './createErrorEvent';\n\nasync function speakUtterance(ponyfill, utterance, startCallback) {\n  const { speechSynthesis } = ponyfill;\n\n  const startDeferred = createDeferred();\n  const errorDeferred = createDeferred();\n  const endDeferred = createDeferred();\n\n  utterance.addEventListener('end', endDeferred.resolve);\n  utterance.addEventListener('error', errorDeferred.resolve);\n  utterance.addEventListener('start', startDeferred.resolve);\n\n  // if (speechSynthesis.speaking) {\n  //   console.warn(`ASSERTION: speechSynthesis.speaking should not be truthy before we call speak`);\n  // }\n\n  speechSynthesis.speak(utterance);\n\n  const startEvent = await Promise.race([\n    errorDeferred.promise,\n    startDeferred.promise\n  ]);\n\n  if (startEvent.type === 'error') {\n    throw startEvent.error;\n  }\n\n  let finishedSpeaking;\n  const endPromise = Promise.race([\n    errorDeferred.promise,\n    endDeferred.promise\n  ]);\n\n  startCallback && startCallback(async () => {\n    if (!finishedSpeaking) {\n      speechSynthesis.cancel();\n      await endPromise;\n    }\n  });\n\n  const endEvent = await endPromise;\n\n  finishedSpeaking = true;\n\n  // if (speechSynthesis.speaking) {\n  //   console.warn(`ASSERTION: speechSynthesis.speaking should not be truthy after speak is stopped`);\n  // }\n\n  // console.debug(`ENDED: ${ utterance.text }`);\n\n  if (endEvent.type === 'error') {\n    throw endEvent.error;\n  }\n}\n\nexport default class QueuedUtterance {\n  constructor(ponyfill, utterance, { onEnd, onError, onStart }) {\n    this._cancelled = false;\n    this._deferred = createDeferred();\n    this._onEnd = onEnd;\n    this._onError = onError;\n    this._onStart = onStart;\n    this._ponyfill = ponyfill;\n    this._speaking = false;\n    this._utterance = utterance;\n\n    this.promise = this._deferred.promise;\n  }\n\n  async cancel() {\n    this._cancelled = true;\n    this._cancel && await this._cancel();\n  }\n\n  speak() {\n    if (this._speaking) {\n      console.warn(`ASSERTION: QueuedUtterance is already speaking or has spoken.`);\n    }\n\n    this._speaking = true;\n\n    (async () => {\n      if (this._cancelled) {\n        throw new Error('cancelled');\n      }\n\n      await speakUtterance(this._ponyfill, this._utterance, cancel => {\n        if (this._cancelled) {\n          cancel();\n\n          throw new Error('cancelled');\n        } else {\n          this._cancel = cancel;\n          this._onStart && this._onStart(createCustomEvent('start'));\n        }\n      });\n\n      if (this._cancelled) {\n        throw new Error('cancelled');\n      }\n    })().then(() => {\n      this._onEnd && this._onEnd(createCustomEvent('end'));\n      this._deferred.resolve();\n    }, error => {\n      this._onError && this._onError(createErrorEvent(error));\n      this._deferred.reject(error);\n    });\n\n    return this.promise;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}