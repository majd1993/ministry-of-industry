{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.object.to-string\");\n\nrequire(\"core-js/modules/es.promise\");\n\nrequire(\"core-js/modules/es.promise.finally\");\n\nrequire(\"core-js/modules/es.string.iterator\");\n\nrequire(\"core-js/modules/esnext.aggregate-error\");\n\nrequire(\"core-js/modules/esnext.promise.all-settled\");\n\nrequire(\"core-js/modules/esnext.promise.any\");\n\nrequire(\"core-js/modules/esnext.promise.try\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"DirectLineStreaming\", {\n  enumerable: true,\n  get: function get() {\n    return _directLineStreaming.DirectLineStreaming;\n  }\n});\nexports.DirectLine = exports.ConnectionStatus = void 0;\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nrequire(\"url-search-params-polyfill\");\n\nvar _BehaviorSubject = require(\"rxjs/BehaviorSubject\");\n\nvar _Observable = require(\"rxjs/Observable\");\n\nvar _async = require(\"rxjs/scheduler/async\");\n\nrequire(\"rxjs/add/operator/catch\");\n\nrequire(\"rxjs/add/operator/combineLatest\");\n\nrequire(\"rxjs/add/operator/count\");\n\nrequire(\"rxjs/add/operator/delay\");\n\nrequire(\"rxjs/add/operator/do\");\n\nrequire(\"rxjs/add/operator/filter\");\n\nrequire(\"rxjs/add/operator/map\");\n\nrequire(\"rxjs/add/operator/mergeMap\");\n\nrequire(\"rxjs/add/operator/concatMap\");\n\nrequire(\"rxjs/add/operator/retryWhen\");\n\nrequire(\"rxjs/add/operator/share\");\n\nrequire(\"rxjs/add/operator/take\");\n\nrequire(\"rxjs/add/observable/dom/ajax\");\n\nrequire(\"rxjs/add/observable/empty\");\n\nrequire(\"rxjs/add/observable/from\");\n\nrequire(\"rxjs/add/observable/interval\");\n\nrequire(\"rxjs/add/observable/of\");\n\nrequire(\"rxjs/add/observable/throw\");\n\nvar _dedupeFilenames = _interopRequireDefault(require(\"./dedupeFilenames\"));\n\nvar _directLineStreaming = require(\"./directLineStreaming\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar DIRECT_LINE_VERSION = 'DirectLine/3.0'; // These types are specific to this client library, not to Direct Line 3.0\n\nvar ConnectionStatus;\nexports.ConnectionStatus = ConnectionStatus;\n\n(function (ConnectionStatus) {\n  ConnectionStatus[ConnectionStatus[\"Uninitialized\"] = 0] = \"Uninitialized\";\n  ConnectionStatus[ConnectionStatus[\"Connecting\"] = 1] = \"Connecting\";\n  ConnectionStatus[ConnectionStatus[\"Online\"] = 2] = \"Online\";\n  ConnectionStatus[ConnectionStatus[\"ExpiredToken\"] = 3] = \"ExpiredToken\";\n  ConnectionStatus[ConnectionStatus[\"FailedToConnect\"] = 4] = \"FailedToConnect\";\n  ConnectionStatus[ConnectionStatus[\"Ended\"] = 5] = \"Ended\";\n})(ConnectionStatus || (exports.ConnectionStatus = ConnectionStatus = {}));\n\nvar wrapAjaxWithRetry = function wrapAjaxWithRetry(source, scheduler) {\n  var notImplemented = function notImplemented() {\n    throw new Error('not implemented');\n  };\n\n  var inner = function inner(response$) {\n    return response$[\"catch\"](function (err) {\n      if (err.status === 429) {\n        var retryAfterValue = err.xhr.getResponseHeader('Retry-After');\n        var retryAfter = Number(retryAfterValue);\n\n        if (!isNaN(retryAfter)) {\n          return _Observable.Observable.timer(retryAfter, scheduler).flatMap(function (_) {\n            return _Observable.Observable[\"throw\"](err, scheduler);\n          });\n        }\n      }\n\n      return _Observable.Observable[\"throw\"](err, scheduler);\n    });\n  };\n\n  var outer = function outer(urlOrRequest) {\n    return inner(source(urlOrRequest));\n  };\n\n  return Object.assign(outer, {\n    get: function get(url, headers) {\n      return notImplemented();\n    },\n    post: function post(url, body, headers) {\n      return notImplemented();\n    },\n    put: function put(url, body, headers) {\n      return notImplemented();\n    },\n    patch: function patch(url, body, headers) {\n      return notImplemented();\n    },\n    \"delete\": function _delete(url, headers) {\n      return notImplemented();\n    },\n    getJSON: function getJSON(url, headers) {\n      return notImplemented();\n    }\n  });\n};\n\nvar makeServices = function makeServices(services) {\n  var scheduler = services.scheduler || _async.async;\n  return {\n    scheduler: scheduler,\n    ajax: wrapAjaxWithRetry(services.ajax || _Observable.Observable.ajax, scheduler),\n    WebSocket: services.WebSocket || WebSocket,\n    random: services.random || Math.random\n  };\n};\n\nvar lifetimeRefreshToken = 30 * 60 * 1000;\nvar intervalRefreshToken = lifetimeRefreshToken / 2;\nvar POLLING_INTERVAL_LOWER_BOUND = 200; //ms\n\nvar errorExpiredToken = new Error(\"expired token\");\nvar errorConversationEnded = new Error(\"conversation ended\");\nvar errorFailedToConnect = new Error(\"failed to connect\");\nvar konsole = {\n  log: function log(message) {\n    var _console;\n\n    for (var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      optionalParams[_key - 1] = arguments[_key];\n    }\n\n    if (typeof window !== 'undefined' && window[\"botchatDebug\"] && message) (_console = console).log.apply(_console, [message].concat(optionalParams));\n  }\n};\n\nvar DirectLine = /*#__PURE__*/function () {\n  //ms\n  function DirectLine(options) {\n    (0, _classCallCheck2[\"default\"])(this, DirectLine);\n    (0, _defineProperty2[\"default\"])(this, \"connectionStatus$\", new _BehaviorSubject.BehaviorSubject(ConnectionStatus.Uninitialized));\n    (0, _defineProperty2[\"default\"])(this, \"activity$\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"domain\", \"https://directline.botframework.com/v3/directline\");\n    (0, _defineProperty2[\"default\"])(this, \"webSocket\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"conversationId\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"expiredTokenExhaustion\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"secret\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"token\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"watermark\", '');\n    (0, _defineProperty2[\"default\"])(this, \"streamUrl\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"_botAgent\", '');\n    (0, _defineProperty2[\"default\"])(this, \"services\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"_userAgent\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"referenceGrammarId\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"timeout\", 20 * 1000);\n    (0, _defineProperty2[\"default\"])(this, \"retries\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"localeOnStartConversation\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"pollingInterval\", 1000);\n    (0, _defineProperty2[\"default\"])(this, \"tokenRefreshSubscription\", void 0);\n    this.secret = options.secret;\n    this.token = options.secret || options.token;\n    this.webSocket = (options.webSocket === undefined ? true : options.webSocket) && typeof WebSocket !== 'undefined' && WebSocket !== undefined;\n\n    if (options.conversationStartProperties && options.conversationStartProperties.locale) {\n      if (Object.prototype.toString.call(options.conversationStartProperties.locale) === '[object String]') {\n        this.localeOnStartConversation = options.conversationStartProperties.locale;\n      } else {\n        console.warn('DirectLineJS: conversationStartProperties.locale was ignored: the locale name may be a BCP 47 language tag');\n      }\n    }\n\n    if (options.domain) {\n      this.domain = options.domain;\n    }\n\n    if (options.conversationId) {\n      this.conversationId = options.conversationId;\n    }\n\n    if (options.watermark) {\n      this.watermark = options.watermark;\n    }\n\n    if (options.streamUrl) {\n      if (options.token && options.conversationId) {\n        this.streamUrl = options.streamUrl;\n      } else {\n        console.warn('DirectLineJS: streamUrl was ignored: you need to provide a token and a conversationid');\n      }\n    }\n\n    if (options.timeout !== undefined) {\n      this.timeout = options.timeout;\n    }\n\n    this.retries = (lifetimeRefreshToken - intervalRefreshToken) / this.timeout;\n    this._botAgent = this.getBotAgent(options.botAgent);\n    this.services = makeServices(options);\n    var parsedPollingInterval = ~~options.pollingInterval;\n\n    if (parsedPollingInterval < POLLING_INTERVAL_LOWER_BOUND) {\n      if (typeof options.pollingInterval !== 'undefined') {\n        console.warn(\"DirectLineJS: provided pollingInterval (\".concat(options.pollingInterval, \") is under lower bound (200ms), using default of 1000ms\"));\n      }\n    } else {\n      this.pollingInterval = parsedPollingInterval;\n    }\n\n    this.expiredTokenExhaustion = this.setConnectionStatusFallback(ConnectionStatus.ExpiredToken, ConnectionStatus.FailedToConnect, 5);\n    this.activity$ = (this.webSocket ? this.webSocketActivity$() : this.pollingGetActivity$()).share();\n  } // Every time we're about to make a Direct Line REST call, we call this first to see check the current connection status.\n  // Either throws an error (indicating an error state) or emits a null, indicating a (presumably) healthy connection\n\n\n  (0, _createClass2[\"default\"])(DirectLine, [{\n    key: \"checkConnection\",\n    value: function checkConnection() {\n      var _this = this;\n\n      var once = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var obs = this.connectionStatus$.flatMap(function (connectionStatus) {\n        if (connectionStatus === ConnectionStatus.Uninitialized) {\n          _this.connectionStatus$.next(ConnectionStatus.Connecting); //if token and streamUrl are defined it means reconnect has already been done. Skipping it.\n\n\n          if (_this.token && _this.streamUrl) {\n            _this.connectionStatus$.next(ConnectionStatus.Online);\n\n            return _Observable.Observable.of(connectionStatus, _this.services.scheduler);\n          } else {\n            return _this.startConversation()[\"do\"](function (conversation) {\n              _this.conversationId = conversation.conversationId;\n              _this.token = _this.secret || conversation.token;\n              _this.streamUrl = conversation.streamUrl;\n              _this.referenceGrammarId = conversation.referenceGrammarId;\n              if (!_this.secret) _this.refreshTokenLoop();\n\n              _this.connectionStatus$.next(ConnectionStatus.Online);\n            }, function (error) {\n              _this.connectionStatus$.next(ConnectionStatus.FailedToConnect);\n            }).map(function (_) {\n              return connectionStatus;\n            });\n          }\n        } else {\n          return _Observable.Observable.of(connectionStatus, _this.services.scheduler);\n        }\n      }).filter(function (connectionStatus) {\n        return connectionStatus != ConnectionStatus.Uninitialized && connectionStatus != ConnectionStatus.Connecting;\n      }).flatMap(function (connectionStatus) {\n        switch (connectionStatus) {\n          case ConnectionStatus.Ended:\n            return _Observable.Observable[\"throw\"](errorConversationEnded, _this.services.scheduler);\n\n          case ConnectionStatus.FailedToConnect:\n            return _Observable.Observable[\"throw\"](errorFailedToConnect, _this.services.scheduler);\n\n          case ConnectionStatus.ExpiredToken:\n            return _Observable.Observable.of(connectionStatus, _this.services.scheduler);\n\n          default:\n            return _Observable.Observable.of(connectionStatus, _this.services.scheduler);\n        }\n      });\n      return once ? obs.take(1) : obs;\n    }\n  }, {\n    key: \"setConnectionStatusFallback\",\n    value: function setConnectionStatusFallback(connectionStatusFrom, connectionStatusTo) {\n      var maxAttempts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;\n      maxAttempts--;\n      var attempts = 0;\n      var currStatus = null;\n      return function (status) {\n        if (status === connectionStatusFrom && currStatus === status && attempts >= maxAttempts) {\n          attempts = 0;\n          return connectionStatusTo;\n        }\n\n        attempts++;\n        currStatus = status;\n        return status;\n      };\n    }\n  }, {\n    key: \"expiredToken\",\n    value: function expiredToken() {\n      var connectionStatus = this.connectionStatus$.getValue();\n      if (connectionStatus != ConnectionStatus.Ended && connectionStatus != ConnectionStatus.FailedToConnect) this.connectionStatus$.next(ConnectionStatus.ExpiredToken);\n      var protectedConnectionStatus = this.expiredTokenExhaustion(this.connectionStatus$.getValue());\n      this.connectionStatus$.next(protectedConnectionStatus);\n    }\n  }, {\n    key: \"startConversation\",\n    value: function startConversation() {\n      var _this2 = this; //if conversationid is set here, it means we need to call the reconnect api, else it is a new conversation\n\n\n      var url = this.conversationId ? \"\".concat(this.domain, \"/conversations/\").concat(this.conversationId, \"?watermark=\").concat(this.watermark) : \"\".concat(this.domain, \"/conversations\");\n      var method = this.conversationId ? \"GET\" : \"POST\";\n      var body = this.conversationId ? undefined : {\n        locale: this.localeOnStartConversation\n      };\n      return this.services.ajax({\n        method: method,\n        url: url,\n        body: body,\n        timeout: this.timeout,\n        headers: _objectSpread({\n          \"Accept\": \"application/json\",\n          \"Content-Type\": \"application/json\"\n        }, this.commonHeaders())\n      }) //      .do(ajaxResponse => konsole.log(\"conversation ajaxResponse\", ajaxResponse.response))\n      .map(function (ajaxResponse) {\n        return ajaxResponse.response;\n      }).retryWhen(function (error$) {\n        return (// for now we deem 4xx and 5xx errors as unrecoverable\n          // for everything else (timeouts), retry for a while\n          error$.mergeMap(function (error) {\n            return error.status >= 400 && error.status < 600 ? _Observable.Observable[\"throw\"](error, _this2.services.scheduler) : _Observable.Observable.of(error, _this2.services.scheduler);\n          }).delay(_this2.timeout, _this2.services.scheduler).take(_this2.retries)\n        );\n      });\n    }\n  }, {\n    key: \"refreshTokenLoop\",\n    value: function refreshTokenLoop() {\n      var _this3 = this;\n\n      this.tokenRefreshSubscription = _Observable.Observable.interval(intervalRefreshToken, this.services.scheduler).flatMap(function (_) {\n        return _this3.refreshToken();\n      }).subscribe(function (token) {\n        konsole.log(\"refreshing token\", token, \"at\", new Date());\n        _this3.token = token;\n      });\n    }\n  }, {\n    key: \"refreshToken\",\n    value: function refreshToken() {\n      var _this4 = this;\n\n      return this.checkConnection(true).flatMap(function (_) {\n        return _this4.services.ajax({\n          method: \"POST\",\n          url: \"\".concat(_this4.domain, \"/tokens/refresh\"),\n          timeout: _this4.timeout,\n          headers: _objectSpread({}, _this4.commonHeaders())\n        }).map(function (ajaxResponse) {\n          return ajaxResponse.response.token;\n        }).retryWhen(function (error$) {\n          return error$.mergeMap(function (error) {\n            if (error.status === 403) {\n              // if the token is expired there's no reason to keep trying\n              _this4.expiredToken();\n\n              return _Observable.Observable[\"throw\"](error, _this4.services.scheduler);\n            } else if (error.status === 404) {\n              // If the bot is gone, we should stop retrying\n              return _Observable.Observable[\"throw\"](error, _this4.services.scheduler);\n            }\n\n            return _Observable.Observable.of(error, _this4.services.scheduler);\n          }).delay(_this4.timeout, _this4.services.scheduler).take(_this4.retries);\n        });\n      });\n    }\n  }, {\n    key: \"reconnect\",\n    value: function reconnect(conversation) {\n      this.token = conversation.token;\n      this.streamUrl = conversation.streamUrl;\n      if (this.connectionStatus$.getValue() === ConnectionStatus.ExpiredToken) this.connectionStatus$.next(ConnectionStatus.Online);\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      if (this.tokenRefreshSubscription) this.tokenRefreshSubscription.unsubscribe();\n\n      try {\n        this.connectionStatus$.next(ConnectionStatus.Ended);\n      } catch (e) {\n        if (e === errorConversationEnded) return;\n        throw e;\n      }\n    }\n  }, {\n    key: \"getSessionId\",\n    value: function getSessionId() {\n      var _this5 = this; // If we're not connected to the bot, get connected\n      // Will throw an error if we are not connected\n\n\n      konsole.log(\"getSessionId\");\n      return this.checkConnection(true).flatMap(function (_) {\n        return _this5.services.ajax({\n          method: \"GET\",\n          url: \"\".concat(_this5.domain, \"/session/getsessionid\"),\n          withCredentials: true,\n          timeout: _this5.timeout,\n          headers: _objectSpread({\n            \"Content-Type\": \"application/json\"\n          }, _this5.commonHeaders())\n        }).map(function (ajaxResponse) {\n          if (ajaxResponse && ajaxResponse.response && ajaxResponse.response.sessionId) {\n            konsole.log(\"getSessionId response: \" + ajaxResponse.response.sessionId);\n            return ajaxResponse.response.sessionId;\n          }\n\n          return '';\n        })[\"catch\"](function (error) {\n          konsole.log(\"getSessionId error: \" + error.status);\n          return _Observable.Observable.of('', _this5.services.scheduler);\n        });\n      })[\"catch\"](function (error) {\n        return _this5.catchExpiredToken(error);\n      });\n    }\n  }, {\n    key: \"postActivity\",\n    value: function postActivity(activity) {\n      var _this6 = this; // Use postMessageWithAttachments for messages with attachments that are local files (e.g. an image to upload)\n      // Technically we could use it for *all* activities, but postActivity is much lighter weight\n      // So, since WebChat is partially a reference implementation of Direct Line, we implement both.\n\n\n      if (activity.type === \"message\" && activity.attachments && activity.attachments.length > 0) return this.postMessageWithAttachments(activity); // If we're not connected to the bot, get connected\n      // Will throw an error if we are not connected\n\n      konsole.log(\"postActivity\", activity);\n      return this.checkConnection(true).flatMap(function (_) {\n        return _this6.services.ajax({\n          method: \"POST\",\n          url: \"\".concat(_this6.domain, \"/conversations/\").concat(_this6.conversationId, \"/activities\"),\n          body: activity,\n          timeout: _this6.timeout,\n          headers: _objectSpread({\n            \"Content-Type\": \"application/json\"\n          }, _this6.commonHeaders())\n        }).map(function (ajaxResponse) {\n          return ajaxResponse.response.id;\n        })[\"catch\"](function (error) {\n          return _this6.catchPostError(error);\n        });\n      })[\"catch\"](function (error) {\n        return _this6.catchExpiredToken(error);\n      });\n    }\n  }, {\n    key: \"postMessageWithAttachments\",\n    value: function postMessageWithAttachments(message) {\n      var _this7 = this;\n\n      var attachments = message.attachments; // We clean the attachments but making sure every attachment has unique name.\n      // If the file do not have a name, Chrome will assign \"blob\" when it is appended to FormData.\n\n      var attachmentNames = (0, _dedupeFilenames[\"default\"])(attachments.map(function (media) {\n        return media.name || 'blob';\n      }));\n      var cleansedAttachments = attachments.map(function (attachment, index) {\n        return _objectSpread({}, attachment, {\n          name: attachmentNames[index]\n        });\n      });\n      var formData; // If we're not connected to the bot, get connected\n      // Will throw an error if we are not connected\n\n      return this.checkConnection(true).flatMap(function (_) {\n        // To send this message to DirectLine we need to deconstruct it into a \"template\" activity\n        // and one blob for each attachment.\n        formData = new FormData();\n        formData.append('activity', new Blob([JSON.stringify(_objectSpread({}, message, {\n          // Removing contentUrl from attachment, we will send it via multipart\n          attachments: cleansedAttachments.map(function (_ref) {\n            var string = _ref.contentUrl,\n                others = (0, _objectWithoutProperties2[\"default\"])(_ref, [\"contentUrl\"]);\n            return _objectSpread({}, others);\n          })\n        }))], {\n          type: 'application/vnd.microsoft.activity'\n        }));\n        return _Observable.Observable.from(cleansedAttachments, _this7.services.scheduler).flatMap(function (media) {\n          return _this7.services.ajax({\n            method: \"GET\",\n            url: media.contentUrl,\n            responseType: 'arraybuffer'\n          })[\"do\"](function (ajaxResponse) {\n            return formData.append('file', new Blob([ajaxResponse.response], {\n              type: media.contentType\n            }), media.name);\n          });\n        }).count();\n      }).flatMap(function (_) {\n        return _this7.services.ajax({\n          method: \"POST\",\n          url: \"\".concat(_this7.domain, \"/conversations/\").concat(_this7.conversationId, \"/upload?userId=\").concat(message.from.id),\n          body: formData,\n          timeout: _this7.timeout,\n          headers: _objectSpread({}, _this7.commonHeaders())\n        }).map(function (ajaxResponse) {\n          return ajaxResponse.response.id;\n        })[\"catch\"](function (error) {\n          return _this7.catchPostError(error);\n        });\n      })[\"catch\"](function (error) {\n        return _this7.catchPostError(error);\n      });\n    }\n  }, {\n    key: \"catchPostError\",\n    value: function catchPostError(error) {\n      if (error.status === 403) // token has expired (will fall through to return \"retry\")\n        this.expiredToken();else if (error.status >= 400 && error.status < 500) // more unrecoverable errors\n        return _Observable.Observable[\"throw\"](error, this.services.scheduler);\n      return _Observable.Observable.of(\"retry\", this.services.scheduler);\n    }\n  }, {\n    key: \"catchExpiredToken\",\n    value: function catchExpiredToken(error) {\n      return error === errorExpiredToken ? _Observable.Observable.of(\"retry\", this.services.scheduler) : _Observable.Observable[\"throw\"](error, this.services.scheduler);\n    }\n  }, {\n    key: \"pollingGetActivity$\",\n    value: function pollingGetActivity$() {\n      var _this8 = this;\n\n      var poller$ = _Observable.Observable.create(function (subscriber) {\n        // A BehaviorSubject to trigger polling. Since it is a BehaviorSubject\n        // the first event is produced immediately.\n        var trigger$ = new _BehaviorSubject.BehaviorSubject({}); // TODO: remove Date.now, use reactive interval to space out every request\n\n        trigger$.subscribe(function () {\n          if (_this8.connectionStatus$.getValue() === ConnectionStatus.Online) {\n            var startTimestamp = Date.now();\n\n            _this8.services.ajax({\n              headers: _objectSpread({\n                Accept: 'application/json'\n              }, _this8.commonHeaders()),\n              method: 'GET',\n              url: \"\".concat(_this8.domain, \"/conversations/\").concat(_this8.conversationId, \"/activities?watermark=\").concat(_this8.watermark),\n              timeout: _this8.timeout\n            }).subscribe(function (result) {\n              subscriber.next(result);\n              setTimeout(function () {\n                return trigger$.next(null);\n              }, Math.max(0, _this8.pollingInterval - Date.now() + startTimestamp));\n            }, function (error) {\n              switch (error.status) {\n                case 403:\n                  _this8.connectionStatus$.next(ConnectionStatus.ExpiredToken);\n\n                  setTimeout(function () {\n                    return trigger$.next(null);\n                  }, _this8.pollingInterval);\n                  break;\n\n                case 404:\n                  _this8.connectionStatus$.next(ConnectionStatus.Ended);\n\n                  break;\n\n                default:\n                  // propagate the error\n                  subscriber.error(error);\n                  break;\n              }\n            });\n          }\n        });\n      });\n\n      return this.checkConnection().flatMap(function (_) {\n        return poller$[\"catch\"](function () {\n          return _Observable.Observable.empty();\n        }).map(function (ajaxResponse) {\n          return ajaxResponse.response;\n        }).flatMap(function (activityGroup) {\n          return _this8.observableFromActivityGroup(activityGroup);\n        });\n      });\n    }\n  }, {\n    key: \"observableFromActivityGroup\",\n    value: function observableFromActivityGroup(activityGroup) {\n      if (activityGroup.watermark) this.watermark = activityGroup.watermark;\n      return _Observable.Observable.from(activityGroup.activities, this.services.scheduler);\n    }\n  }, {\n    key: \"webSocketActivity$\",\n    value: function webSocketActivity$() {\n      var _this9 = this;\n\n      return this.checkConnection().flatMap(function (_) {\n        return _this9.observableWebSocket() // WebSockets can be closed by the server or the browser. In the former case we need to\n        // retrieve a new streamUrl. In the latter case we could first retry with the current streamUrl,\n        // but it's simpler just to always fetch a new one.\n        .retryWhen(function (error$) {\n          return error$.delay(_this9.getRetryDelay(), _this9.services.scheduler).mergeMap(function (error) {\n            return _this9.reconnectToConversation();\n          });\n        });\n      }).flatMap(function (activityGroup) {\n        return _this9.observableFromActivityGroup(activityGroup);\n      });\n    } // Returns the delay duration in milliseconds\n\n  }, {\n    key: \"getRetryDelay\",\n    value: function getRetryDelay() {\n      return Math.floor(3000 + this.services.random() * 12000);\n    } // Originally we used Observable.webSocket, but it's fairly opinionated and I ended up writing\n    // a lot of code to work around their implementation details. Since WebChat is meant to be a reference\n    // implementation, I decided roll the below, where the logic is more purposeful. - @billba\n\n  }, {\n    key: \"observableWebSocket\",\n    value: function observableWebSocket() {\n      var _this10 = this;\n\n      return _Observable.Observable.create(function (subscriber) {\n        konsole.log(\"creating WebSocket\", _this10.streamUrl);\n        var ws = new _this10.services.WebSocket(_this10.streamUrl);\n        var sub;\n\n        ws.onopen = function (open) {\n          konsole.log(\"WebSocket open\", open); // Chrome is pretty bad at noticing when a WebSocket connection is broken.\n          // If we periodically ping the server with empty messages, it helps Chrome\n          // realize when connection breaks, and close the socket. We then throw an\n          // error, and that give us the opportunity to attempt to reconnect.\n\n          sub = _Observable.Observable.interval(_this10.timeout, _this10.services.scheduler).subscribe(function (_) {\n            try {\n              ws.send(\"\");\n            } catch (e) {\n              konsole.log(\"Ping error\", e);\n            }\n          });\n        };\n\n        ws.onclose = function (close) {\n          konsole.log(\"WebSocket close\", close);\n          if (sub) sub.unsubscribe();\n          subscriber.error(close);\n        };\n\n        ws.onmessage = function (message) {\n          return message.data && subscriber.next(JSON.parse(message.data));\n        }; // This is the 'unsubscribe' method, which is called when this observable is disposed.\n        // When the WebSocket closes itself, we throw an error, and this function is eventually called.\n        // When the observable is closed first (e.g. when tearing down a WebChat instance) then\n        // we need to manually close the WebSocket.\n\n\n        return function () {\n          if (ws.readyState === 0 || ws.readyState === 1) ws.close();\n        };\n      });\n    }\n  }, {\n    key: \"reconnectToConversation\",\n    value: function reconnectToConversation() {\n      var _this11 = this;\n\n      return this.checkConnection(true).flatMap(function (_) {\n        return _this11.services.ajax({\n          method: \"GET\",\n          url: \"\".concat(_this11.domain, \"/conversations/\").concat(_this11.conversationId, \"?watermark=\").concat(_this11.watermark),\n          timeout: _this11.timeout,\n          headers: _objectSpread({\n            \"Accept\": \"application/json\"\n          }, _this11.commonHeaders())\n        })[\"do\"](function (result) {\n          if (!_this11.secret) _this11.token = result.response.token;\n          _this11.streamUrl = result.response.streamUrl;\n        }).map(function (_) {\n          return null;\n        }).retryWhen(function (error$) {\n          return error$.mergeMap(function (error) {\n            if (error.status === 403) {\n              // token has expired. We can't recover from this here, but the embedding\n              // website might eventually call reconnect() with a new token and streamUrl.\n              _this11.expiredToken();\n            } else if (error.status === 404) {\n              return _Observable.Observable[\"throw\"](errorConversationEnded, _this11.services.scheduler);\n            }\n\n            return _Observable.Observable.of(error, _this11.services.scheduler);\n          }).delay(_this11.timeout, _this11.services.scheduler).take(_this11.retries);\n        });\n      });\n    }\n  }, {\n    key: \"commonHeaders\",\n    value: function commonHeaders() {\n      return {\n        \"Authorization\": \"Bearer \".concat(this.token),\n        \"x-ms-bot-agent\": this._botAgent\n      };\n    }\n  }, {\n    key: \"getBotAgent\",\n    value: function getBotAgent() {\n      var customAgent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      var clientAgent = 'directlinejs';\n\n      if (customAgent) {\n        clientAgent += \"; \".concat(customAgent);\n      }\n\n      return \"\".concat(DIRECT_LINE_VERSION, \" (\").concat(clientAgent, \" \").concat(\"0.13.1\", \")\");\n    }\n  }]);\n  return DirectLine;\n}();\n\nexports.DirectLine = DirectLine;","map":{"version":3,"sources":["../src/directLine.ts"],"names":["DIRECT_LINE_VERSION","ConnectionStatus","wrapAjaxWithRetry","notImplemented","inner","err","retryAfterValue","retryAfter","Number","isNaN","Observable","outer","source","get","post","put","patch","getJSON","makeServices","scheduler","services","AsyncScheduler","ajax","WebSocket","random","Math","lifetimeRefreshToken","intervalRefreshToken","POLLING_INTERVAL_LOWER_BOUND","errorExpiredToken","errorConversationEnded","errorFailedToConnect","konsole","log","optionalParams","window","DirectLine","BehaviorSubject","options","Object","console","parsedPollingInterval","once","obs","connectionStatus","conversation","connectionStatusFrom","connectionStatusTo","maxAttempts","attempts","currStatus","status","protectedConnectionStatus","url","method","body","locale","localeOnStartConversation","timeout","headers","ajaxResponse","error$","error","e","withCredentials","activity","message","attachments","attachmentNames","media","cleansedAttachments","name","formData","string","others","type","responseType","contentType","poller$","trigger$","startTimestamp","Date","Accept","subscriber","setTimeout","activityGroup","ws","sub","JSON","result","_botAgent","customAgent","clientAgent"],"mappings":"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","sourcesContent":["// In order to keep file size down, only import the parts of rxjs that we use\n\nimport 'core-js/features/promise';\nimport 'url-search-params-polyfill';\nimport { AjaxResponse, AjaxCreationMethod, AjaxRequest, AjaxError } from 'rxjs/observable/dom/AjaxObservable';\nimport { BehaviorSubject } from 'rxjs/BehaviorSubject';\nimport { Observable } from 'rxjs/Observable';\nimport { IScheduler } from 'rxjs/Scheduler';\nimport { Subscriber } from 'rxjs/Subscriber';\nimport { Subscription } from 'rxjs/Subscription';\nimport { async as AsyncScheduler } from 'rxjs/scheduler/async';\n\nimport 'rxjs/add/operator/catch';\nimport 'rxjs/add/operator/combineLatest';\nimport 'rxjs/add/operator/count';\nimport 'rxjs/add/operator/delay';\nimport 'rxjs/add/operator/do';\nimport 'rxjs/add/operator/filter';\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/mergeMap';\nimport 'rxjs/add/operator/concatMap';\nimport 'rxjs/add/operator/retryWhen';\nimport 'rxjs/add/operator/share';\nimport 'rxjs/add/operator/take';\n\nimport 'rxjs/add/observable/dom/ajax';\nimport 'rxjs/add/observable/empty';\nimport 'rxjs/add/observable/from';\nimport 'rxjs/add/observable/interval';\nimport 'rxjs/add/observable/of';\nimport 'rxjs/add/observable/throw';\n\nimport dedupeFilenames from './dedupeFilenames';\nimport { objectExpression } from '@babel/types';\n\nimport { DirectLineStreaming } from './directLineStreaming';\nexport { DirectLineStreaming };\n\nconst DIRECT_LINE_VERSION = 'DirectLine/3.0';\n\ndeclare var process: {\n    arch: string;\n    env: {\n        VERSION: string;\n        npm_package_version: string;\n    };\n    platform: string;\n    release: string;\n    version: string;\n};\n\n// Direct Line 3.0 types\n\nexport interface Conversation {\n    conversationId: string,\n    token: string,\n    eTag?: string,\n    streamUrl?: string,\n    referenceGrammarId?: string\n}\n\nexport type MediaType = \"image/png\" | \"image/jpg\" | \"image/jpeg\" | \"image/gif\" | \"image/svg+xml\" | \"audio/mpeg\" | \"audio/mp4\" | \"video/mp4\";\n\nexport interface Media {\n    contentType: MediaType,\n    contentUrl: string,\n    name?: string,\n    thumbnailUrl?: string\n}\n\nexport interface UnknownMedia{\n    contentType: string,\n    contentUrl: string,\n    name?: string,\n    thumbnailUrl?: string\n}\n\nexport type CardActionTypes = \"call\" | \"downloadFile\"| \"imBack\" | \"messageBack\" | \"openUrl\" | \"playAudio\" | \"playVideo\" | \"postBack\" | \"signin\" | \"showImage\";\n\nexport type CardAction = CallCardAction | DownloadFileCardAction | IMBackCardAction | MessageBackCardAction | OpenURLCardAction | PlayAudioCardAction | PlayVideoCardAction | PostBackCardAction | SignInCardAction | ShowImageCardAction;\n\nexport interface CallCardAction {\n    image?: string,\n    title: string,\n    type: \"call\",\n    value: any\n}\n\nexport interface DownloadFileCardAction {\n    image?: string,\n    title: string,\n    type: \"downloadFile\",\n    value: any\n}\n\nexport interface IMBackCardAction {\n    image?: string,\n    title?: string,\n    type: \"imBack\",\n    value: string\n}\n\nexport type MessageBackCardAction = MessageBackWithImage | MessageBackWithTitle\n\nexport interface MessageBackWithImage {\n    displayText?: string,\n    image: string,\n    text?: string,\n    title?: string,\n    type: \"messageBack\",\n    value?: any\n}\n\nexport interface MessageBackWithTitle {\n    displayText?: string,\n    image?: string,\n    text?: string,\n    title: string,\n    type: \"messageBack\",\n    value?: any\n}\n\nexport interface OpenURLCardAction {\n    image?: string,\n    title: string,\n    type: \"openUrl\",\n    value: any\n}\n\nexport interface PlayAudioCardAction {\n    image?: string,\n    title: string,\n    type: \"playAudio\",\n    value: any\n}\n\nexport interface PlayVideoCardAction {\n    image?: string,\n    title: string,\n    type: \"playVideo\",\n    value: any\n}\n\nexport interface PostBackCardAction {\n    image?: string,\n    title?: string,\n    type: \"postBack\",\n    value: any\n}\n\nexport interface ShowImageCardAction {\n    image?: string,\n    title: string,\n    type: \"showImage\",\n    value: any\n}\n\nexport interface SignInCardAction {\n    image?: string,\n    title: string,\n    type: \"signin\",\n    value: any\n}\n\nexport interface CardImage {\n    alt?: string,\n    url: string,\n    tap?: CardAction\n}\n\nexport interface HeroCard {\n    contentType: \"application/vnd.microsoft.card.hero\",\n    content: {\n        title?: string,\n        subtitle?: string,\n        text?: string,\n        images?: CardImage[],\n        buttons?: CardAction[],\n        tap?: CardAction\n    }\n}\n\nexport interface Thumbnail {\n    contentType: \"application/vnd.microsoft.card.thumbnail\",\n    content: {\n        title?: string,\n        subtitle?: string,\n        text?: string,\n        images?: CardImage[],\n        buttons?: CardAction[],\n        tap?: CardAction\n    }\n}\n\nexport interface Signin {\n    contentType: \"application/vnd.microsoft.card.signin\",\n    content: {\n        text?: string,\n        buttons?: CardAction[]\n    }\n}\n\nexport interface OAuth {\n    contentType: \"application/vnd.microsoft.card.oauth\",\n    content: {\n        text?: string,\n        connectionname: string,\n        buttons?: CardAction[]\n    }\n}\n\nexport interface ReceiptItem {\n    title?: string,\n    subtitle?: string,\n    text?: string,\n    image?: CardImage,\n    price?: string,\n    quantity?: string,\n    tap?: CardAction\n}\n\nexport interface Receipt {\n    contentType: \"application/vnd.microsoft.card.receipt\",\n    content: {\n        title?: string,\n        facts?: { key: string, value: string }[],\n        items?: ReceiptItem[],\n        tap?: CardAction,\n        tax?: string,\n        vat?: string,\n        total?: string,\n        buttons?: CardAction[]\n    }\n}\n\n// Deprecated format for Skype channels. For testing legacy bots in Emulator only.\nexport interface FlexCard {\n    contentType: \"application/vnd.microsoft.card.flex\",\n    content: {\n        title?: string,\n        subtitle?: string,\n        text?: string,\n        images?: CardImage[],\n        buttons?: CardAction[],\n        aspect?: string\n    }\n}\n\nexport interface AudioCard {\n    contentType: \"application/vnd.microsoft.card.audio\",\n    content: {\n        title?: string,\n        subtitle?: string,\n        text?: string,\n        media?: { url: string, profile?: string }[],\n        buttons?: CardAction[],\n        autoloop?: boolean,\n        autostart?: boolean\n    }\n}\n\nexport interface VideoCard {\n    contentType: \"application/vnd.microsoft.card.video\",\n    content: {\n        title?: string,\n        subtitle?: string,\n        text?: string,\n        media?: { url: string, profile?: string }[],\n        buttons?: CardAction[],\n        image?: { url: string, alt?: string },\n        autoloop?: boolean,\n        autostart?: boolean\n    }\n}\n\nexport interface AdaptiveCard {\n    contentType: \"application/vnd.microsoft.card.adaptive\",\n    content: any;\n}\n\nexport interface AnimationCard {\n    contentType: \"application/vnd.microsoft.card.animation\",\n    content: {\n        title?: string,\n        subtitle?: string,\n        text?: string,\n        media?: { url: string, profile?: string }[],\n        buttons?: CardAction[],\n        image?: { url: string, alt?: string },\n        autoloop?: boolean,\n        autostart?: boolean\n    }\n}\n\nexport type KnownMedia = Media | HeroCard | Thumbnail | Signin | OAuth | Receipt | AudioCard | VideoCard | AnimationCard | FlexCard | AdaptiveCard;\nexport type Attachment = KnownMedia | UnknownMedia;\n\nexport type UserRole = \"bot\" | \"channel\" | \"user\";\n\nexport interface User {\n    id: string,\n    name?: string,\n    iconUrl?: string,\n    role?: UserRole\n}\n\nexport interface IActivity {\n    type: string,\n    channelData?: any,\n    channelId?: string,\n    conversation?: { id: string },\n    eTag?: string,\n    from: User,\n    id?: string,\n    timestamp?: string\n}\n\nexport type AttachmentLayout = \"list\" | \"carousel\";\n\nexport interface Message extends IActivity {\n    type: \"message\",\n    text?: string,\n    locale?: string,\n    textFormat?: \"plain\" | \"markdown\" | \"xml\",\n    attachmentLayout?: AttachmentLayout,\n    attachments?: Attachment[],\n    entities?: any[],\n    suggestedActions?: { actions: CardAction[], to?: string[] },\n    speak?: string,\n    inputHint?: string,\n    value?: object\n}\n\nexport interface Typing extends IActivity {\n    type: \"typing\"\n}\n\nexport interface EventActivity extends IActivity {\n    type: \"event\",\n    name: string,\n    value: any\n}\n\nexport type Activity = Message | Typing | EventActivity;\n\nexport interface ActivityGroup {\n    activities: Activity[],\n    watermark: string\n}\n\n// These types are specific to this client library, not to Direct Line 3.0\n\nexport enum ConnectionStatus {\n    Uninitialized,              // the status when the DirectLine object is first created/constructed\n    Connecting,                 // currently trying to connect to the conversation\n    Online,                     // successfully connected to the conversation. Connection is healthy so far as we know.\n    ExpiredToken,               // last operation errored out with an expired token. Possibly waiting for someone to supply a new one.\n    FailedToConnect,            // the initial attempt to connect to the conversation failed. No recovery possible.\n    Ended                       // the bot ended the conversation\n}\n\nexport interface DirectLineOptions {\n    secret?: string,\n    token?: string,\n    conversationId?: string,\n    watermark?: string,\n    domain?: string,\n    webSocket?: boolean,\n    pollingInterval?: number,\n    streamUrl?: string,\n    timeout?: number,\n    // Attached to all requests to identify requesting agent.\n    botAgent?: string,\n    conversationStartProperties?: any\n}\n\nexport interface Services {\n    scheduler: IScheduler;\n    WebSocket: typeof WebSocket;\n    ajax: AjaxCreationMethod;\n    random: () => number;\n}\n\nconst wrapAjaxWithRetry = (source: AjaxCreationMethod, scheduler: IScheduler): AjaxCreationMethod =>{\n\n    const notImplemented = (): never => { throw new Error('not implemented'); };\n\n    const inner = (response$ : Observable<AjaxResponse>) => {\n        return response$\n        .catch<AjaxResponse, AjaxResponse>((err) => {\n            if(err.status === 429){\n                const retryAfterValue = err.xhr.getResponseHeader('Retry-After');\n                const retryAfter = Number(retryAfterValue);\n                if(!isNaN(retryAfter)){\n                    return Observable.timer(retryAfter, scheduler)\n                    .flatMap(_ => Observable.throw(err, scheduler));\n                }\n            }\n\n            return Observable.throw(err, scheduler);\n        });\n    };\n\n    const outer = (urlOrRequest: string| AjaxRequest) => {\n        return inner(source(urlOrRequest));\n    };\n\n    return Object.assign(outer, {\n        get: (url: string, headers?: Object): Observable<AjaxResponse> => notImplemented(),\n        post: (url: string, body?: any, headers?: Object): Observable<AjaxResponse> => notImplemented(),\n        put: (url: string, body?: any, headers?: Object): Observable<AjaxResponse> => notImplemented(),\n        patch: (url: string, body?: any, headers?: Object): Observable<AjaxResponse> => notImplemented(),\n        delete: (url: string, headers?: Object): Observable<AjaxResponse> => notImplemented(),\n        getJSON: <T>(url: string, headers?: Object): Observable<T> => notImplemented()\n    });\n}\n\nconst makeServices = (services: Partial<Services>): Services => {\n    const scheduler = services.scheduler || AsyncScheduler;\n    return {\n        scheduler,\n        ajax: wrapAjaxWithRetry(services.ajax || Observable.ajax, scheduler),\n        WebSocket: services.WebSocket || WebSocket,\n        random: services.random || Math.random,\n    }\n}\n\nconst lifetimeRefreshToken = 30 * 60 * 1000;\nconst intervalRefreshToken = lifetimeRefreshToken / 2;\n\nconst POLLING_INTERVAL_LOWER_BOUND: number = 200; //ms\n\nconst errorExpiredToken = new Error(\"expired token\");\nconst errorConversationEnded = new Error(\"conversation ended\");\nconst errorFailedToConnect = new Error(\"failed to connect\");\n\nconst konsole = {\n    log: (message?: any, ... optionalParams: any[]) => {\n        if (typeof window !== 'undefined' && (window as any)[\"botchatDebug\"] && message)\n            console.log(message, ... optionalParams);\n    }\n}\n\nexport interface IBotConnection {\n    connectionStatus$: BehaviorSubject<ConnectionStatus>,\n    activity$: Observable<Activity>,\n    end(): void,\n    referenceGrammarId?: string,\n    postActivity(activity: Activity): Observable<string>,\n    getSessionId? : () => Observable<string>\n}\n\nexport class DirectLine implements IBotConnection {\n    public connectionStatus$ = new BehaviorSubject(ConnectionStatus.Uninitialized);\n    public activity$: Observable<Activity>;\n\n    private domain = \"https://directline.botframework.com/v3/directline\";\n    private webSocket: boolean;\n\n    private conversationId: string;\n    private expiredTokenExhaustion: Function;\n    private secret: string;\n    private token: string;\n    private watermark = '';\n    private streamUrl: string;\n    private _botAgent = '';\n    private services: Services;\n    private _userAgent: string;\n    public referenceGrammarId: string;\n    private timeout = 20 * 1000;\n    private retries: number;\n\n    private localeOnStartConversation: string;\n\n    private pollingInterval: number = 1000; //ms\n\n    private tokenRefreshSubscription: Subscription;\n\n    constructor(options: DirectLineOptions & Partial<Services>) {\n        this.secret = options.secret;\n        this.token = options.secret || options.token;\n        this.webSocket = (options.webSocket === undefined ? true : options.webSocket) && typeof WebSocket !== 'undefined' && WebSocket !== undefined;\n\n        if (options.conversationStartProperties && options.conversationStartProperties.locale) {\n            if (Object.prototype.toString.call(options.conversationStartProperties.locale) === '[object String]') {\n                this.localeOnStartConversation = options.conversationStartProperties.locale;\n            } else {\n                console.warn('DirectLineJS: conversationStartProperties.locale was ignored: the locale name may be a BCP 47 language tag');\n            }\n        }\n\n        if (options.domain) {\n            this.domain = options.domain;\n        }\n\n        if (options.conversationId) {\n            this.conversationId = options.conversationId;\n        }\n\n        if (options.watermark) {\n            this.watermark =  options.watermark;\n        }\n\n        if (options.streamUrl) {\n            if (options.token && options.conversationId) {\n                this.streamUrl = options.streamUrl;\n            } else {\n                console.warn('DirectLineJS: streamUrl was ignored: you need to provide a token and a conversationid');\n            }\n        }\n\n        if (options.timeout !== undefined) {\n            this.timeout = options.timeout;\n        }\n\n        this.retries = (lifetimeRefreshToken - intervalRefreshToken) / this.timeout;\n\n        this._botAgent = this.getBotAgent(options.botAgent);\n\n        this.services = makeServices(options);\n\n        const parsedPollingInterval = ~~options.pollingInterval;\n\n        if (parsedPollingInterval < POLLING_INTERVAL_LOWER_BOUND) {\n            if (typeof options.pollingInterval !== 'undefined') {\n                console.warn(`DirectLineJS: provided pollingInterval (${ options.pollingInterval }) is under lower bound (200ms), using default of 1000ms`);\n            }\n        } else {\n            this.pollingInterval = parsedPollingInterval;\n        }\n\n        this.expiredTokenExhaustion = this.setConnectionStatusFallback(\n            ConnectionStatus.ExpiredToken,\n            ConnectionStatus.FailedToConnect,\n            5\n        );\n\n        this.activity$ = (this.webSocket\n            ? this.webSocketActivity$()\n            : this.pollingGetActivity$()\n        ).share();\n    }\n\n    // Every time we're about to make a Direct Line REST call, we call this first to see check the current connection status.\n    // Either throws an error (indicating an error state) or emits a null, indicating a (presumably) healthy connection\n    private checkConnection(once = false) {\n        let obs =  this.connectionStatus$\n        .flatMap(connectionStatus => {\n            if (connectionStatus === ConnectionStatus.Uninitialized) {\n                this.connectionStatus$.next(ConnectionStatus.Connecting);\n\n                //if token and streamUrl are defined it means reconnect has already been done. Skipping it.\n                if (this.token && this.streamUrl) {\n                    this.connectionStatus$.next(ConnectionStatus.Online);\n                    return Observable.of(connectionStatus, this.services.scheduler);\n                } else {\n                    return this.startConversation().do(conversation => {\n                        this.conversationId = conversation.conversationId;\n                        this.token = this.secret || conversation.token;\n                        this.streamUrl = conversation.streamUrl;\n                        this.referenceGrammarId = conversation.referenceGrammarId;\n                        if (!this.secret)\n                            this.refreshTokenLoop();\n\n                        this.connectionStatus$.next(ConnectionStatus.Online);\n                    }, error => {\n                        this.connectionStatus$.next(ConnectionStatus.FailedToConnect);\n                    })\n                    .map(_ => connectionStatus);\n                }\n            }\n            else {\n                return Observable.of(connectionStatus, this.services.scheduler);\n            }\n        })\n        .filter(connectionStatus => connectionStatus != ConnectionStatus.Uninitialized && connectionStatus != ConnectionStatus.Connecting)\n        .flatMap(connectionStatus => {\n            switch (connectionStatus) {\n                case ConnectionStatus.Ended:\n                    return Observable.throw(errorConversationEnded, this.services.scheduler);\n\n                case ConnectionStatus.FailedToConnect:\n                    return Observable.throw(errorFailedToConnect, this.services.scheduler);\n\n                case ConnectionStatus.ExpiredToken:\n                    return Observable.of(connectionStatus, this.services.scheduler);\n\n                default:\n                    return Observable.of(connectionStatus, this.services.scheduler);\n            }\n        })\n\n        return once ? obs.take(1) : obs;\n    }\n\n    setConnectionStatusFallback(\n        connectionStatusFrom: ConnectionStatus,\n        connectionStatusTo: ConnectionStatus,\n        maxAttempts = 5\n    ) {\n        maxAttempts--;\n        let attempts = 0;\n        let currStatus = null;\n        return (status: ConnectionStatus): ConnectionStatus => {\n            if (status === connectionStatusFrom && currStatus === status && attempts >= maxAttempts) {\n                attempts = 0\n                return connectionStatusTo;\n            }\n            attempts++;\n            currStatus = status;\n            return status;\n        };\n    }\n\n    private expiredToken() {\n        const connectionStatus = this.connectionStatus$.getValue();\n        if (connectionStatus != ConnectionStatus.Ended && connectionStatus != ConnectionStatus.FailedToConnect)\n            this.connectionStatus$.next(ConnectionStatus.ExpiredToken);\n\n        const protectedConnectionStatus = this.expiredTokenExhaustion(this.connectionStatus$.getValue());\n        this.connectionStatus$.next(protectedConnectionStatus);\n    }\n\n    private startConversation() {\n        //if conversationid is set here, it means we need to call the reconnect api, else it is a new conversation\n        const url = this.conversationId\n            ? `${this.domain}/conversations/${this.conversationId}?watermark=${this.watermark}`\n            : `${this.domain}/conversations`;\n        const method = this.conversationId ? \"GET\" : \"POST\";\n        const body = this.conversationId\n            ? undefined\n            : {\n                locale: this.localeOnStartConversation\n              };\n        return this.services.ajax({\n            method,\n            url,\n            body,\n            timeout: this.timeout,\n            headers: {\n                \"Accept\": \"application/json\",\n                \"Content-Type\": \"application/json\",\n                ...this.commonHeaders()\n            }\n        })\n//      .do(ajaxResponse => konsole.log(\"conversation ajaxResponse\", ajaxResponse.response))\n        .map(ajaxResponse => ajaxResponse.response as Conversation)\n        .retryWhen(error$ =>\n            // for now we deem 4xx and 5xx errors as unrecoverable\n            // for everything else (timeouts), retry for a while\n            error$.mergeMap((error) => {\n                return error.status >= 400 && error.status < 600\n                ? Observable.throw(error, this.services.scheduler)\n                : Observable.of(error, this.services.scheduler)\n            })\n            .delay(this.timeout, this.services.scheduler)\n            .take(this.retries)\n        )\n    }\n\n    private refreshTokenLoop() {\n        this.tokenRefreshSubscription = Observable.interval(intervalRefreshToken, this.services.scheduler)\n        .flatMap(_ => this.refreshToken())\n        .subscribe(token => {\n            konsole.log(\"refreshing token\", token, \"at\", new Date());\n            this.token = token;\n        });\n    }\n\n    private refreshToken() {\n        return this.checkConnection(true)\n        .flatMap(_ =>\n            this.services.ajax({\n                method: \"POST\",\n                url: `${this.domain}/tokens/refresh`,\n                timeout: this.timeout,\n                headers: {\n                    ...this.commonHeaders()\n                }\n            })\n            .map(ajaxResponse => ajaxResponse.response.token as string)\n            .retryWhen(error$ => error$\n                .mergeMap(error => {\n                    if (error.status === 403) {\n                        // if the token is expired there's no reason to keep trying\n                        this.expiredToken();\n                        return Observable.throw(error, this.services.scheduler);\n                    } else if (error.status === 404) {\n                        // If the bot is gone, we should stop retrying\n                        return Observable.throw(error, this.services.scheduler);\n                    }\n\n                    return Observable.of(error, this.services.scheduler);\n                })\n                .delay(this.timeout, this.services.scheduler)\n                .take(this.retries)\n            )\n        )\n    }\n\n    public reconnect(conversation: Conversation) {\n        this.token = conversation.token;\n        this.streamUrl = conversation.streamUrl;\n        if (this.connectionStatus$.getValue() === ConnectionStatus.ExpiredToken)\n            this.connectionStatus$.next(ConnectionStatus.Online);\n    }\n\n    end() {\n        if (this.tokenRefreshSubscription)\n            this.tokenRefreshSubscription.unsubscribe();\n        try {\n            this.connectionStatus$.next(ConnectionStatus.Ended);\n        } catch (e) {\n            if (e === errorConversationEnded)\n                return;\n            throw(e);\n        }\n    }\n\n    getSessionId(): Observable<string> {\n        // If we're not connected to the bot, get connected\n        // Will throw an error if we are not connected\n        konsole.log(\"getSessionId\");\n        return this.checkConnection(true)\n            .flatMap(_ =>\n                this.services.ajax({\n                    method: \"GET\",\n                    url: `${this.domain}/session/getsessionid`,\n                    withCredentials: true,\n                    timeout: this.timeout,\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...this.commonHeaders()\n                    }\n                })\n                .map(ajaxResponse => {\n                    if (ajaxResponse && ajaxResponse.response && ajaxResponse.response.sessionId) {\n                        konsole.log(\"getSessionId response: \" + ajaxResponse.response.sessionId);\n                        return ajaxResponse.response.sessionId as string;\n                    }\n                    return '';\n                })\n                .catch(error => {\n                    konsole.log(\"getSessionId error: \" + error.status);\n                    return Observable.of('', this.services.scheduler);\n                })\n            )\n            .catch(error => this.catchExpiredToken(error));\n    }\n\n    postActivity(activity: Activity) {\n        // Use postMessageWithAttachments for messages with attachments that are local files (e.g. an image to upload)\n        // Technically we could use it for *all* activities, but postActivity is much lighter weight\n        // So, since WebChat is partially a reference implementation of Direct Line, we implement both.\n        if (activity.type === \"message\" && activity.attachments && activity.attachments.length > 0)\n            return this.postMessageWithAttachments(activity);\n\n        // If we're not connected to the bot, get connected\n        // Will throw an error if we are not connected\n        konsole.log(\"postActivity\", activity);\n        return this.checkConnection(true)\n        .flatMap(_ =>\n            this.services.ajax({\n                method: \"POST\",\n                url: `${this.domain}/conversations/${this.conversationId}/activities`,\n                body: activity,\n                timeout: this.timeout,\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...this.commonHeaders()\n                },\n            })\n            .map(ajaxResponse => ajaxResponse.response.id as string)\n            .catch(error => this.catchPostError(error))\n        )\n        .catch(error => this.catchExpiredToken(error));\n    }\n\n    private postMessageWithAttachments(message: Message) {\n        const { attachments } = message;\n        // We clean the attachments but making sure every attachment has unique name.\n        // If the file do not have a name, Chrome will assign \"blob\" when it is appended to FormData.\n        const attachmentNames: string[] = dedupeFilenames(attachments.map((media: Media) => media.name || 'blob'));\n        const cleansedAttachments = attachments.map((attachment: Media, index: number) => ({\n            ...attachment,\n            name: attachmentNames[index]\n        }));\n        let formData: FormData;\n\n        // If we're not connected to the bot, get connected\n        // Will throw an error if we are not connected\n        return this.checkConnection(true)\n        .flatMap(_ => {\n            // To send this message to DirectLine we need to deconstruct it into a \"template\" activity\n            // and one blob for each attachment.\n            formData = new FormData();\n            formData.append('activity', new Blob([JSON.stringify({\n                ...message,\n                // Removing contentUrl from attachment, we will send it via multipart\n                attachments: cleansedAttachments.map(({ contentUrl: string, ...others }) => ({ ...others }))\n            })], { type: 'application/vnd.microsoft.activity' }));\n\n            return Observable.from(cleansedAttachments, this.services.scheduler)\n            .flatMap((media: Media) =>\n                this.services.ajax({\n                    method: \"GET\",\n                    url: media.contentUrl,\n                    responseType: 'arraybuffer'\n                })\n                .do(ajaxResponse =>\n                    formData.append('file', new Blob([ajaxResponse.response], { type: media.contentType }), media.name)\n                )\n            )\n            .count()\n        })\n        .flatMap(_ =>\n            this.services.ajax({\n                method: \"POST\",\n                url: `${this.domain}/conversations/${this.conversationId}/upload?userId=${message.from.id}`,\n                body: formData,\n                timeout: this.timeout,\n                headers: {\n                    ...this.commonHeaders()\n                }\n            })\n            .map(ajaxResponse => ajaxResponse.response.id as string)\n            .catch(error => this.catchPostError(error))\n        )\n        .catch(error => this.catchPostError(error));\n    }\n\n    private catchPostError(error: any) {\n        if (error.status === 403)\n            // token has expired (will fall through to return \"retry\")\n            this.expiredToken();\n        else if (error.status >= 400 && error.status < 500)\n            // more unrecoverable errors\n            return Observable.throw(error, this.services.scheduler);\n        return Observable.of(\"retry\", this.services.scheduler);\n    }\n\n    private catchExpiredToken(error: any) {\n        return error === errorExpiredToken\n        ? Observable.of(\"retry\", this.services.scheduler)\n        : Observable.throw(error, this.services.scheduler);\n    }\n\n    private pollingGetActivity$() {\n        const poller$: Observable<AjaxResponse> = Observable.create((subscriber: Subscriber<any>) => {\n            // A BehaviorSubject to trigger polling. Since it is a BehaviorSubject\n            // the first event is produced immediately.\n            const trigger$ = new BehaviorSubject<any>({});\n\n            // TODO: remove Date.now, use reactive interval to space out every request\n\n            trigger$.subscribe(() => {\n                if (this.connectionStatus$.getValue() === ConnectionStatus.Online) {\n                    const startTimestamp = Date.now();\n\n                    this.services.ajax({\n                        headers: {\n                            Accept: 'application/json',\n                            ...this.commonHeaders()\n                        },\n                        method: 'GET',\n                        url: `${ this.domain }/conversations/${ this.conversationId }/activities?watermark=${ this.watermark }`,\n                        timeout: this.timeout\n                    }).subscribe(\n                        (result: AjaxResponse) => {\n                            subscriber.next(result);\n                            setTimeout(() => trigger$.next(null), Math.max(0, this.pollingInterval - Date.now() + startTimestamp));\n                        },\n                        (error: any) => {\n                            switch (error.status) {\n                                case 403:\n                                    this.connectionStatus$.next(ConnectionStatus.ExpiredToken);\n                                    setTimeout(() => trigger$.next(null), this.pollingInterval);\n                                    break;\n\n                                case 404:\n                                    this.connectionStatus$.next(ConnectionStatus.Ended);\n                                    break;\n\n                                default:\n                                    // propagate the error\n                                    subscriber.error(error);\n                                    break;\n                            }\n                        }\n                    );\n                }\n            });\n        });\n\n        return this.checkConnection()\n        .flatMap(_ => poller$\n            .catch(() => Observable.empty<AjaxResponse>())\n            .map(ajaxResponse => ajaxResponse.response as ActivityGroup)\n            .flatMap(activityGroup => this.observableFromActivityGroup(activityGroup)));\n    }\n\n    private observableFromActivityGroup(activityGroup: ActivityGroup) {\n        if (activityGroup.watermark)\n            this.watermark = activityGroup.watermark;\n        return Observable.from(activityGroup.activities, this.services.scheduler);\n    }\n\n    private webSocketActivity$(): Observable<Activity> {\n        return this.checkConnection()\n        .flatMap(_ =>\n            this.observableWebSocket<ActivityGroup>()\n            // WebSockets can be closed by the server or the browser. In the former case we need to\n            // retrieve a new streamUrl. In the latter case we could first retry with the current streamUrl,\n            // but it's simpler just to always fetch a new one.\n            .retryWhen(error$ => error$.delay(this.getRetryDelay(), this.services.scheduler).mergeMap(error => this.reconnectToConversation()))\n        )\n        .flatMap(activityGroup => this.observableFromActivityGroup(activityGroup))\n    }\n\n    // Returns the delay duration in milliseconds\n    private getRetryDelay() {\n        return Math.floor(3000 + this.services.random() * 12000);\n    }\n\n    // Originally we used Observable.webSocket, but it's fairly opinionated and I ended up writing\n    // a lot of code to work around their implementation details. Since WebChat is meant to be a reference\n    // implementation, I decided roll the below, where the logic is more purposeful. - @billba\n    private observableWebSocket<T>() {\n        return Observable.create((subscriber: Subscriber<T>) => {\n            konsole.log(\"creating WebSocket\", this.streamUrl);\n            const ws = new this.services.WebSocket(this.streamUrl);\n            let sub: Subscription;\n\n            ws.onopen = open => {\n                konsole.log(\"WebSocket open\", open);\n                // Chrome is pretty bad at noticing when a WebSocket connection is broken.\n                // If we periodically ping the server with empty messages, it helps Chrome\n                // realize when connection breaks, and close the socket. We then throw an\n                // error, and that give us the opportunity to attempt to reconnect.\n                sub = Observable.interval(this.timeout, this.services.scheduler).subscribe(_ => {\n                    try {\n                        ws.send(\"\")\n                    } catch(e) {\n                        konsole.log(\"Ping error\", e);\n                    }\n                });\n            }\n\n            ws.onclose = close => {\n                konsole.log(\"WebSocket close\", close);\n                if (sub) sub.unsubscribe();\n                subscriber.error(close);\n            }\n\n            ws.onmessage = message => message.data && subscriber.next(JSON.parse(message.data));\n\n            // This is the 'unsubscribe' method, which is called when this observable is disposed.\n            // When the WebSocket closes itself, we throw an error, and this function is eventually called.\n            // When the observable is closed first (e.g. when tearing down a WebChat instance) then\n            // we need to manually close the WebSocket.\n            return () => {\n                if (ws.readyState === 0 || ws.readyState === 1) ws.close();\n            }\n        }) as Observable<T>\n    }\n\n    private reconnectToConversation() {\n        return this.checkConnection(true)\n        .flatMap(_ =>\n            this.services.ajax({\n                method: \"GET\",\n                url: `${this.domain}/conversations/${this.conversationId}?watermark=${this.watermark}`,\n                timeout: this.timeout,\n                headers: {\n                    \"Accept\": \"application/json\",\n                    ...this.commonHeaders()\n                }\n            })\n            .do(result => {\n                if (!this.secret)\n                    this.token = result.response.token;\n                this.streamUrl = result.response.streamUrl;\n            })\n            .map(_ => null)\n            .retryWhen(error$ => error$\n                .mergeMap(error => {\n                    if (error.status === 403) {\n                        // token has expired. We can't recover from this here, but the embedding\n                        // website might eventually call reconnect() with a new token and streamUrl.\n                        this.expiredToken();\n                    } else if (error.status === 404) {\n                        return Observable.throw(errorConversationEnded, this.services.scheduler);\n                    }\n\n                    return Observable.of(error, this.services.scheduler);\n                })\n                .delay(this.timeout, this.services.scheduler)\n                .take(this.retries)\n            )\n        )\n    }\n\n    private commonHeaders() {\n        return {\n            \"Authorization\": `Bearer ${this.token}`,\n            \"x-ms-bot-agent\": this._botAgent\n        };\n    }\n\n    private getBotAgent(customAgent: string = ''): string {\n        let clientAgent = 'directlinejs'\n\n        if (customAgent) {\n            clientAgent += `; ${customAgent}`\n        }\n\n        return `${DIRECT_LINE_VERSION} (${clientAgent} ${process.env.npm_package_version})`;\n    }\n\n\n}\n"]},"metadata":{},"sourceType":"script"}