{"ast":null,"code":"import _classCallCheck from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { Stream } from \"./Exports\";\nexport var ChunkedArrayBufferStream = /*#__PURE__*/function (_Stream) {\n  _inherits(ChunkedArrayBufferStream, _Stream);\n\n  var _super = _createSuper(ChunkedArrayBufferStream);\n\n  function ChunkedArrayBufferStream(targetChunkSize, streamId) {\n    var _this;\n\n    _classCallCheck(this, ChunkedArrayBufferStream);\n\n    _this = _super.call(this, streamId);\n    _this.privTargetChunkSize = targetChunkSize;\n    _this.privNextBufferReadyBytes = 0;\n    return _this;\n  }\n\n  _createClass(ChunkedArrayBufferStream, [{\n    key: \"writeStreamChunk\",\n    value: function writeStreamChunk(chunk) {\n      // No pending write, and the buffer is the right size so write it.\n      if (chunk.isEnd || 0 === this.privNextBufferReadyBytes && chunk.buffer.byteLength === this.privTargetChunkSize) {\n        _get(_getPrototypeOf(ChunkedArrayBufferStream.prototype), \"writeStreamChunk\", this).call(this, chunk);\n\n        return;\n      }\n\n      var bytesCopiedFromBuffer = 0;\n\n      while (bytesCopiedFromBuffer < chunk.buffer.byteLength) {\n        // Fill the next buffer.\n        if (undefined === this.privNextBufferToWrite) {\n          this.privNextBufferToWrite = new ArrayBuffer(this.privTargetChunkSize);\n          this.privNextBufferStartTime = chunk.timeReceived;\n        } // Find out how many bytes we can copy into the read buffer.\n\n\n        var bytesToCopy = Math.min(chunk.buffer.byteLength - bytesCopiedFromBuffer, this.privTargetChunkSize - this.privNextBufferReadyBytes);\n        var targetView = new Uint8Array(this.privNextBufferToWrite);\n        var sourceView = new Uint8Array(chunk.buffer.slice(bytesCopiedFromBuffer, bytesToCopy + bytesCopiedFromBuffer));\n        targetView.set(sourceView, this.privNextBufferReadyBytes);\n        this.privNextBufferReadyBytes += bytesToCopy;\n        bytesCopiedFromBuffer += bytesToCopy; // Are we ready to write?\n\n        if (this.privNextBufferReadyBytes === this.privTargetChunkSize) {\n          _get(_getPrototypeOf(ChunkedArrayBufferStream.prototype), \"writeStreamChunk\", this).call(this, {\n            buffer: this.privNextBufferToWrite,\n            isEnd: false,\n            timeReceived: this.privNextBufferStartTime\n          });\n\n          this.privNextBufferReadyBytes = 0;\n          this.privNextBufferToWrite = undefined;\n        }\n      }\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      // Send whatever is pending, then close the base class.\n      if (0 !== this.privNextBufferReadyBytes && !this.isClosed) {\n        _get(_getPrototypeOf(ChunkedArrayBufferStream.prototype), \"writeStreamChunk\", this).call(this, {\n          buffer: this.privNextBufferToWrite.slice(0, this.privNextBufferReadyBytes),\n          isEnd: false,\n          timeReceived: this.privNextBufferStartTime\n        });\n      }\n\n      _get(_getPrototypeOf(ChunkedArrayBufferStream.prototype), \"close\", this).call(this);\n    }\n  }]);\n\n  return ChunkedArrayBufferStream;\n}(Stream);","map":{"version":3,"sources":["src/common/ChunkedArrayBufferStream.ts"],"names":[],"mappings":";;;;;;AAAA;AACA;AAEA,SAAuB,MAAvB,QAAqC,WAArC;AAEA,WAAa,wBAAb;AAAA;;AAAA;;AAMI,oCAAY,eAAZ,EAAqC,QAArC,EAAsD;AAAA;;AAAA;;AAClD,8BAAM,QAAN;AACA,UAAK,mBAAL,GAA2B,eAA3B;AACA,UAAK,wBAAL,GAAgC,CAAhC;AAHkD;AAIrD;;AAVL;AAAA;AAAA,WAYW,0BAAiB,KAAjB,EAAiD;AACpD;AACA,UAAI,KAAK,CAAC,KAAN,IACC,MAAM,KAAK,wBAAX,IAAuC,KAAK,CAAC,MAAN,CAAa,UAAb,KAA4B,KAAK,mBAD7E,EACmG;AAC/F,uGAAuB,KAAvB;;AACA;AACH;;AAED,UAAI,qBAAqB,GAAW,CAApC;;AAEA,aAAO,qBAAqB,GAAG,KAAK,CAAC,MAAN,CAAa,UAA5C,EAAwD;AACpD;AACA,YAAI,SAAS,KAAK,KAAK,qBAAvB,EAA8C;AAC1C,eAAK,qBAAL,GAA6B,IAAI,WAAJ,CAAgB,KAAK,mBAArB,CAA7B;AACA,eAAK,uBAAL,GAA+B,KAAK,CAAC,YAArC;AACH,SALmD,CAOpD;;;AACA,YAAM,WAAW,GAAW,IAAI,CAAC,GAAL,CAAS,KAAK,CAAC,MAAN,CAAa,UAAb,GAA0B,qBAAnC,EAA0D,KAAK,mBAAL,GAA2B,KAAK,wBAA1F,CAA5B;AACA,YAAM,UAAU,GAAe,IAAI,UAAJ,CAAe,KAAK,qBAApB,CAA/B;AACA,YAAM,UAAU,GAAe,IAAI,UAAJ,CAAe,KAAK,CAAC,MAAN,CAAa,KAAb,CAAmB,qBAAnB,EAA0C,WAAW,GAAG,qBAAxD,CAAf,CAA/B;AAEA,QAAA,UAAU,CAAC,GAAX,CAAe,UAAf,EAA2B,KAAK,wBAAhC;AACA,aAAK,wBAAL,IAAiC,WAAjC;AACA,QAAA,qBAAqB,IAAI,WAAzB,CAdoD,CAgBpD;;AACA,YAAI,KAAK,wBAAL,KAAkC,KAAK,mBAA3C,EAAgE;AAC5D,yGAAuB;AACnB,YAAA,MAAM,EAAE,KAAK,qBADM;AAEnB,YAAA,KAAK,EAAE,KAFY;AAGnB,YAAA,YAAY,EAAE,KAAK;AAHA,WAAvB;;AAKA,eAAK,wBAAL,GAAgC,CAAhC;AACA,eAAK,qBAAL,GAA6B,SAA7B;AACH;AACJ;AACJ;AAjDL;AAAA;AAAA,WAmDW,iBAAK;AACR;AACA,UAAI,MAAM,KAAK,wBAAX,IAAuC,CAAC,KAAK,QAAjD,EAA2D;AACvD,uGAAuB;AACnB,UAAA,MAAM,EAAE,KAAK,qBAAL,CAA2B,KAA3B,CAAiC,CAAjC,EAAoC,KAAK,wBAAzC,CADW;AAEnB,UAAA,KAAK,EAAE,KAFY;AAGnB,UAAA,YAAY,EAAE,KAAK;AAHA,SAAvB;AAKH;;AAED;AACH;AA9DL;;AAAA;AAAA,EAA8C,MAA9C","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { IStreamChunk, Stream } from \"./Exports\";\r\n\r\nexport class ChunkedArrayBufferStream extends Stream<ArrayBuffer> {\r\n    private privTargetChunkSize: number;\r\n    private privNextBufferToWrite: ArrayBuffer;\r\n    private privNextBufferStartTime: number;\r\n    private privNextBufferReadyBytes: number;\r\n\r\n    constructor(targetChunkSize: number, streamId?: string) {\r\n        super(streamId);\r\n        this.privTargetChunkSize = targetChunkSize;\r\n        this.privNextBufferReadyBytes = 0;\r\n    }\r\n\r\n    public writeStreamChunk(chunk: IStreamChunk<ArrayBuffer>): void {\r\n        // No pending write, and the buffer is the right size so write it.\r\n        if (chunk.isEnd ||\r\n            (0 === this.privNextBufferReadyBytes && chunk.buffer.byteLength === this.privTargetChunkSize)) {\r\n            super.writeStreamChunk(chunk);\r\n            return;\r\n        }\r\n\r\n        let bytesCopiedFromBuffer: number = 0;\r\n\r\n        while (bytesCopiedFromBuffer < chunk.buffer.byteLength) {\r\n            // Fill the next buffer.\r\n            if (undefined === this.privNextBufferToWrite) {\r\n                this.privNextBufferToWrite = new ArrayBuffer(this.privTargetChunkSize);\r\n                this.privNextBufferStartTime = chunk.timeReceived;\r\n            }\r\n\r\n            // Find out how many bytes we can copy into the read buffer.\r\n            const bytesToCopy: number = Math.min(chunk.buffer.byteLength - bytesCopiedFromBuffer, this.privTargetChunkSize - this.privNextBufferReadyBytes);\r\n            const targetView: Uint8Array = new Uint8Array(this.privNextBufferToWrite);\r\n            const sourceView: Uint8Array = new Uint8Array(chunk.buffer.slice(bytesCopiedFromBuffer, bytesToCopy + bytesCopiedFromBuffer));\r\n\r\n            targetView.set(sourceView, this.privNextBufferReadyBytes);\r\n            this.privNextBufferReadyBytes += bytesToCopy;\r\n            bytesCopiedFromBuffer += bytesToCopy;\r\n\r\n            // Are we ready to write?\r\n            if (this.privNextBufferReadyBytes === this.privTargetChunkSize) {\r\n                super.writeStreamChunk({\r\n                    buffer: this.privNextBufferToWrite,\r\n                    isEnd: false,\r\n                    timeReceived: this.privNextBufferStartTime,\r\n                });\r\n                this.privNextBufferReadyBytes = 0;\r\n                this.privNextBufferToWrite = undefined;\r\n            }\r\n        }\r\n    }\r\n\r\n    public close(): void {\r\n        // Send whatever is pending, then close the base class.\r\n        if (0 !== this.privNextBufferReadyBytes && !this.isClosed) {\r\n            super.writeStreamChunk({\r\n                buffer: this.privNextBufferToWrite.slice(0, this.privNextBufferReadyBytes),\r\n                isEnd: false,\r\n                timeReceived: this.privNextBufferStartTime,\r\n            });\r\n        }\r\n\r\n        super.close();\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}