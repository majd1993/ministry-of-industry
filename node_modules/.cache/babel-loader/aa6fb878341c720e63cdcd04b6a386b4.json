{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = speakActivityAndStartDictateOnIncomingActivityFromOthersSaga;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _effects = require(\"redux-saga/effects\");\n\nvar _incomingActivity = require(\"../actions/incomingActivity\");\n\nvar _DictateState = require(\"../constants/DictateState\");\n\nvar _markActivity = _interopRequireDefault(require(\"../actions/markActivity\"));\n\nvar _setDictateState = _interopRequireDefault(require(\"../actions/setDictateState\"));\n\nvar _shouldSpeakIncomingActivity = _interopRequireDefault(require(\"../selectors/shouldSpeakIncomingActivity\"));\n\nvar _speakableActivity = _interopRequireDefault(require(\"../definitions/speakableActivity\"));\n\nvar _stopDictate = _interopRequireDefault(require(\"../actions/stopDictate\"));\n\nvar _whileConnected = _interopRequireDefault(require(\"./effects/whileConnected\"));\n\nvar _marked = /*#__PURE__*/_regenerator[\"default\"].mark(speakActivityAndStartDictateOnIncomingActivityFromOthers),\n    _marked2 = /*#__PURE__*/_regenerator[\"default\"].mark(speakActivityAndStartDictateOnIncomingActivityFromOthersSaga);\n\nfunction speakActivityAndStartDictateOnIncomingActivityFromOthers(_ref) {\n  var userID;\n  return _regenerator[\"default\"].wrap(function speakActivityAndStartDictateOnIncomingActivityFromOthers$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          userID = _ref.userID;\n          _context2.next = 3;\n          return (0, _effects.takeEvery)(function (_ref2) {\n            var payload = _ref2.payload,\n                type = _ref2.type;\n            return (// In Direct Line, the \"role\" is not filled (yet), but we do know the user ID.\n              // In Direct Line Speech, we do not know the user ID, but \"role\" is filled with \"bot\" or \"user\".\n              // Here, we do two checks: the speakable activity must not have user ID, and must not have role === 'user'\n              type === _incomingActivity.INCOMING_ACTIVITY && payload.activity.from.id !== userID && payload.activity.from.role !== 'user'\n            );\n          }, /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(_ref3) {\n            var activity, shouldSpeakIncomingActivity, shouldSpeak;\n            return _regenerator[\"default\"].wrap(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    activity = _ref3.payload.activity;\n                    _context.next = 3;\n                    return (0, _effects.select)(_shouldSpeakIncomingActivity[\"default\"]);\n\n                  case 3:\n                    shouldSpeakIncomingActivity = _context.sent;\n                    shouldSpeak = (0, _speakableActivity[\"default\"])(activity) && shouldSpeakIncomingActivity;\n\n                    if (!(shouldSpeak && (activity.speak || activity.text || ~(activity.attachments || []).findIndex(function (_ref4) {\n                      var _ref4$content = _ref4.content;\n                      _ref4$content = _ref4$content === void 0 ? {} : _ref4$content;\n                      var speak = _ref4$content.speak;\n                      return speak;\n                    })))) {\n                      _context.next = 8;\n                      break;\n                    }\n\n                    _context.next = 8;\n                    return (0, _effects.put)((0, _markActivity[\"default\"])(activity, 'speak', true));\n\n                  case 8:\n                    if (!(shouldSpeak && activity.inputHint === 'expectingInput')) {\n                      _context.next = 13;\n                      break;\n                    }\n\n                    _context.next = 11;\n                    return (0, _effects.put)((0, _setDictateState[\"default\"])(_DictateState.WILL_START));\n\n                  case 11:\n                    _context.next = 16;\n                    break;\n\n                  case 13:\n                    if (!(activity.inputHint === 'ignoringInput')) {\n                      _context.next = 16;\n                      break;\n                    }\n\n                    _context.next = 16;\n                    return (0, _effects.put)((0, _stopDictate[\"default\"])());\n\n                  case 16:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _callee);\n          }));\n\n        case 3:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked);\n}\n\nfunction speakActivityAndStartDictateOnIncomingActivityFromOthersSaga() {\n  return _regenerator[\"default\"].wrap(function speakActivityAndStartDictateOnIncomingActivityFromOthersSaga$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.next = 2;\n          return (0, _whileConnected[\"default\"])(speakActivityAndStartDictateOnIncomingActivityFromOthers);\n\n        case 2:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked2);\n}","map":{"version":3,"sources":["../../src/sagas/speakActivityAndStartDictateOnIncomingActivityFromOthersSaga.js"],"names":["speakActivityAndStartDictateOnIncomingActivityFromOthers","userID","payload","type","INCOMING_ACTIVITY","activity","shouldSpeakIncomingActivity","shouldSpeakIncomingActivitySelector","shouldSpeak","speak","WILL_START","speakActivityAndStartDictateOnIncomingActivityFromOthersSaga"],"mappings":"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","sourcesContent":["import { put, select, takeEvery } from 'redux-saga/effects';\n\nimport { INCOMING_ACTIVITY } from '../actions/incomingActivity';\nimport { WILL_START } from '../constants/DictateState';\nimport markActivity from '../actions/markActivity';\nimport setDictateState from '../actions/setDictateState';\nimport shouldSpeakIncomingActivitySelector from '../selectors/shouldSpeakIncomingActivity';\nimport speakableActivity from '../definitions/speakableActivity';\nimport stopDictate from '../actions/stopDictate';\nimport whileConnected from './effects/whileConnected';\n\nfunction* speakActivityAndStartDictateOnIncomingActivityFromOthers({ userID }) {\n  yield takeEvery(\n    ({ payload, type }) =>\n      // In Direct Line, the \"role\" is not filled (yet), but we do know the user ID.\n      // In Direct Line Speech, we do not know the user ID, but \"role\" is filled with \"bot\" or \"user\".\n      // Here, we do two checks: the speakable activity must not have user ID, and must not have role === 'user'\n      type === INCOMING_ACTIVITY && payload.activity.from.id !== userID && payload.activity.from.role !== 'user',\n    function*({ payload: { activity } }) {\n      const shouldSpeakIncomingActivity = yield select(shouldSpeakIncomingActivitySelector);\n      const shouldSpeak = speakableActivity(activity) && shouldSpeakIncomingActivity;\n\n      if (\n        shouldSpeak &&\n        (activity.speak ||\n          activity.text ||\n          ~(activity.attachments || []).findIndex(({ content: { speak } = {} }) => speak))\n      ) {\n        yield put(markActivity(activity, 'speak', true));\n      }\n\n      if (shouldSpeak && activity.inputHint === 'expectingInput') {\n        yield put(setDictateState(WILL_START));\n      } else if (activity.inputHint === 'ignoringInput') {\n        yield put(stopDictate());\n      }\n    }\n  );\n}\n\nexport default function* speakActivityAndStartDictateOnIncomingActivityFromOthersSaga() {\n  yield whileConnected(speakActivityAndStartDictateOnIncomingActivityFromOthers);\n}\n"],"sourceRoot":"core:///"},"metadata":{},"sourceType":"script"}