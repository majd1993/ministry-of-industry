{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n/* eslint no-await-in-loop: \"off\" */\n\n\nvar _default = /*#__PURE__*/function () {\n  function _default(audioContext) {\n    (0, _classCallCheck2.default)(this, _default);\n    this.audioContext = audioContext;\n  }\n\n  (0, _createClass2.default)(_default, [{\n    key: \"pause\",\n    value: function pause() {\n      this.audioContext && this.audioContext.suspend();\n      this.playingUtterance && this.playingUtterance.dispatchEvent(new CustomEvent('pause'));\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      this.audioContext && this.audioContext.resume();\n      this.playingUtterance && this.playingUtterance.dispatchEvent(new CustomEvent('resume'));\n    }\n  }, {\n    key: \"start\",\n    value: function () {\n      var _start = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(queue) {\n        var utterance;\n        return _regenerator.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(utterance = queue.shift())) {\n                  _context.next = 7;\n                  break;\n                }\n\n                this.playingUtterance = utterance;\n                _context.next = 4;\n                return utterance.play(this.audioContext);\n\n              case 4:\n                this.playingUtterance = null;\n                _context.next = 0;\n                break;\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function start(_x) {\n        return _start.apply(this, arguments);\n      }\n\n      return start;\n    }()\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.playingUtterance && this.playingUtterance.stop();\n\n      if (this.audioContext.state === 'suspended') {\n        // Play -> Pause -> Cancel (stop)\n        // This would generate these events: \"start\", \"pause\", \"end\"\n        // Without this code, the \"end\" event will not emit until resume() is called\n        // Cancelling an unstarted utterance will not emit any \"start\" or \"end\" event\n        this.audioContext.resume();\n      }\n    }\n  }]);\n  return _default;\n}();\n\nexports.default = _default;","map":{"version":3,"sources":["../../../src/SpeechServices/TextToSpeech/AudioContextConsumer.js"],"names":["queue","utterance"],"mappings":";;;;;;;;;;;;;;;;AAAA;;;;AAGE,WAAA,QAAA,CAAA,YAAA,EAA0B;AAAA,KAAA,GAAA,gBAAA,CAAA,OAAA,EAAA,IAAA,EAAA,QAAA;AACxB,SAAA,YAAA,GAAA,YAAA;AACD;;;;4BAEO;AACN,WAAA,YAAA,IAAqB,KAAA,YAAA,CAArB,OAAqB,EAArB;AACA,WAAA,gBAAA,IAAyB,KAAA,gBAAA,CAAA,aAAA,CAAoC,IAAA,WAAA,CAA7D,OAA6D,CAApC,CAAzB;AACD;;;6BAEQ;AACP,WAAA,YAAA,IAAqB,KAAA,YAAA,CAArB,MAAqB,EAArB;AACA,WAAA,gBAAA,IAAyB,KAAA,gBAAA,CAAA,aAAA,CAAoC,IAAA,WAAA,CAA7D,QAA6D,CAApC,CAAzB;AACD;;;;4GAEWA,K;;;;;;sBAGFC,SAAS,GAAGD,KAAK,CAALA,KAAAA,E;;;;;AAClB,qBAAA,gBAAA,GAAA,SAAA;;uBAEMC,SAAS,CAATA,IAAAA,CAAe,KAAfA,YAAAA,C;;;AAEN,qBAAA,gBAAA,GAAA,IAAA;;;;;;;;;;;;;;;;;;;;2BAIG;AACL,WAAA,gBAAA,IAAyB,KAAA,gBAAA,CAAzB,IAAyB,EAAzB;;AAEA,UAAI,KAAA,YAAA,CAAA,KAAA,KAAJ,WAAA,EAA6C;AAC3C;AACA;AAEA;AACA;AACA,aAAA,YAAA,CAAA,MAAA;AACD;AACF","sourcesContent":["/* eslint no-await-in-loop: \"off\" */\n\nexport default class {\n  constructor(audioContext) {\n    this.audioContext = audioContext;\n  }\n\n  pause() {\n    this.audioContext && this.audioContext.suspend();\n    this.playingUtterance && this.playingUtterance.dispatchEvent(new CustomEvent('pause'));\n  }\n\n  resume() {\n    this.audioContext && this.audioContext.resume();\n    this.playingUtterance && this.playingUtterance.dispatchEvent(new CustomEvent('resume'));\n  }\n\n  async start(queue) {\n    let utterance;\n\n    while ((utterance = queue.shift())) {\n      this.playingUtterance = utterance;\n\n      await utterance.play(this.audioContext);\n\n      this.playingUtterance = null;\n    }\n  }\n\n  stop() {\n    this.playingUtterance && this.playingUtterance.stop();\n\n    if (this.audioContext.state === 'suspended') {\n      // Play -> Pause -> Cancel (stop)\n      // This would generate these events: \"start\", \"pause\", \"end\"\n\n      // Without this code, the \"end\" event will not emit until resume() is called\n      // Cancelling an unstarted utterance will not emit any \"start\" or \"end\" event\n      this.audioContext.resume();\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}