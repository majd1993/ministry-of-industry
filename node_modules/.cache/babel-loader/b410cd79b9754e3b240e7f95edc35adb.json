{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = createSynthesize;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _QueuedUtterance = _interopRequireDefault(require(\"./QueuedUtterance\"));\n\nfunction createSynthesize() {\n  var queueWithCurrent = [];\n  var running;\n\n  var run = function run() {\n    return _regenerator[\"default\"].async(function run$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!running) {\n              _context2.next = 2;\n              break;\n            }\n\n            return _context2.abrupt(\"return\");\n\n          case 2:\n            running = true;\n            _context2.prev = 3;\n            _context2.next = 6;\n            return _regenerator[\"default\"].awrap(function _callee() {\n              var queuedUtterance;\n              return _regenerator[\"default\"].async(function _callee$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      if (!(queuedUtterance = queueWithCurrent[0])) {\n                        _context.next = 12;\n                        break;\n                      }\n\n                      _context.prev = 1;\n                      _context.next = 4;\n                      return _regenerator[\"default\"].awrap(queuedUtterance.speak());\n\n                    case 4:\n                      _context.next = 9;\n                      break;\n\n                    case 6:\n                      _context.prev = 6;\n                      _context.t0 = _context[\"catch\"](1); // TODO: If the error is due to Safari restriction on user touch\n                      //       The next loop on the next audio will also fail because it was not queued with a user touch\n\n                      _context.t0.message !== 'cancelled' && console.error(_context.t0);\n\n                    case 9:\n                      queueWithCurrent = queueWithCurrent.filter(function (target) {\n                        return target !== queuedUtterance;\n                      });\n                      _context.next = 0;\n                      break;\n\n                    case 12:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, null, null, [[1, 6]]);\n            }());\n\n          case 6:\n            _context2.prev = 6;\n            running = false;\n            return _context2.finish(6);\n\n          case 9:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, [[3,, 6, 9]]);\n  };\n\n  return function (ponyfill, utterance) {\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        onEnd = _ref.onEnd,\n        onError = _ref.onError,\n        onStart = _ref.onStart;\n\n    if (!(utterance instanceof ponyfill.SpeechSynthesisUtterance)) {\n      throw new Error('utterance must be instance of the ponyfill');\n    }\n\n    var queuedUtterance = new _QueuedUtterance[\"default\"](ponyfill, utterance, {\n      onEnd: onEnd,\n      onError: onError,\n      onStart: onStart\n    });\n    queueWithCurrent = [].concat((0, _toConsumableArray2[\"default\"])(queueWithCurrent), [queuedUtterance]);\n    run();\n    return {\n      // The cancel() function returns a Promise\n      cancel: function cancel() {\n        return queuedUtterance.cancel();\n      },\n      promise: queuedUtterance.promise\n    };\n  };\n}","map":{"version":3,"sources":["../src/createSynthesize.js"],"names":["queueWithCurrent","run","running","queuedUtterance","console","target","onEnd","onError","onStart","utterance","ponyfill","QueuedUtterance","cancel","promise"],"mappings":"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","sourcesContent":["import QueuedUtterance from './QueuedUtterance';\n\nexport default function createSynthesize() {\n  let queueWithCurrent = [];\n  let running;\n\n  const run = async () => {\n    if (running) {\n      return;\n    }\n\n    running = true;\n\n    try {\n      let queuedUtterance;\n\n      while ((queuedUtterance = queueWithCurrent[0])) {\n        try {\n          await queuedUtterance.speak();\n        } catch (err) {\n          // TODO: If the error is due to Safari restriction on user touch\n          //       The next loop on the next audio will also fail because it was not queued with a user touch\n\n          err.message !== 'cancelled' && console.error(err);\n        }\n\n        queueWithCurrent = queueWithCurrent.filter(target => target !== queuedUtterance);\n      }\n    } finally {\n      running = false;\n    }\n  }\n\n  return (ponyfill, utterance, { onEnd, onError, onStart } = {}) => {\n    if (!(utterance instanceof ponyfill.SpeechSynthesisUtterance)) {\n      throw new Error('utterance must be instance of the ponyfill');\n    }\n\n    const queuedUtterance = new QueuedUtterance(ponyfill, utterance, { onEnd, onError, onStart });\n\n    queueWithCurrent = [...queueWithCurrent, queuedUtterance];\n    run();\n\n    return {\n      // The cancel() function returns a Promise\n      cancel: () => queuedUtterance.cancel(),\n      promise: queuedUtterance.promise\n    };\n  };\n}\n"]},"metadata":{},"sourceType":"script"}