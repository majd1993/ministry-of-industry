{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) {\n    if (b.hasOwnProperty(p)) d[p] = b[p];\n  }\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = require('../Observable');\n\nvar ScalarObservable_1 = require('./ScalarObservable');\n\nvar EmptyObservable_1 = require('./EmptyObservable');\n\nvar isScheduler_1 = require('../util/isScheduler');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar ArrayObservable = function (_super) {\n  __extends(ArrayObservable, _super);\n\n  function ArrayObservable(array, scheduler) {\n    _super.call(this);\n\n    this.array = array;\n    this.scheduler = scheduler;\n\n    if (!scheduler && array.length === 1) {\n      this._isScalar = true;\n      this.value = array[0];\n    }\n  }\n\n  ArrayObservable.create = function (array, scheduler) {\n    return new ArrayObservable(array, scheduler);\n  };\n  /**\n   * Creates an Observable that emits some values you specify as arguments,\n   * immediately one after the other, and then emits a complete notification.\n   *\n   * <span class=\"informal\">Emits the arguments you provide, then completes.\n   * </span>\n   *\n   * <img src=\"./img/of.png\" width=\"100%\">\n   *\n   * This static operator is useful for creating a simple Observable that only\n   * emits the arguments given, and the complete notification thereafter. It can\n   * be used for composing with other Observables, such as with {@link concat}.\n   * By default, it uses a `null` IScheduler, which means the `next`\n   * notifications are sent synchronously, although with a different IScheduler\n   * it is possible to determine when those notifications will be delivered.\n   *\n   * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>\n   * var numbers = Rx.Observable.of(10, 20, 30);\n   * var letters = Rx.Observable.of('a', 'b', 'c');\n   * var interval = Rx.Observable.interval(1000);\n   * var result = numbers.concat(letters).concat(interval);\n   * result.subscribe(x => console.log(x));\n   *\n   * @see {@link create}\n   * @see {@link empty}\n   * @see {@link never}\n   * @see {@link throw}\n   *\n   * @param {...T} values Arguments that represent `next` values to be emitted.\n   * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n   * the emissions of the `next` notifications.\n   * @return {Observable<T>} An Observable that emits each given input value.\n   * @static true\n   * @name of\n   * @owner Observable\n   */\n\n\n  ArrayObservable.of = function () {\n    var array = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      array[_i - 0] = arguments[_i];\n    }\n\n    var scheduler = array[array.length - 1];\n\n    if (isScheduler_1.isScheduler(scheduler)) {\n      array.pop();\n    } else {\n      scheduler = null;\n    }\n\n    var len = array.length;\n\n    if (len > 1) {\n      return new ArrayObservable(array, scheduler);\n    } else if (len === 1) {\n      return new ScalarObservable_1.ScalarObservable(array[0], scheduler);\n    } else {\n      return new EmptyObservable_1.EmptyObservable(scheduler);\n    }\n  };\n\n  ArrayObservable.dispatch = function (state) {\n    var array = state.array,\n        index = state.index,\n        count = state.count,\n        subscriber = state.subscriber;\n\n    if (index >= count) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(array[index]);\n\n    if (subscriber.closed) {\n      return;\n    }\n\n    state.index = index + 1;\n    this.schedule(state);\n  };\n  /** @deprecated internal use only */\n\n\n  ArrayObservable.prototype._subscribe = function (subscriber) {\n    var index = 0;\n    var array = this.array;\n    var count = array.length;\n    var scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(ArrayObservable.dispatch, 0, {\n        array: array,\n        index: index,\n        count: count,\n        subscriber: subscriber\n      });\n    } else {\n      for (var i = 0; i < count && !subscriber.closed; i++) {\n        subscriber.next(array[i]);\n      }\n\n      subscriber.complete();\n    }\n  };\n\n  return ArrayObservable;\n}(Observable_1.Observable);\n\nexports.ArrayObservable = ArrayObservable;","map":{"version":3,"sources":["../../src/observable/ArrayObservable.ts"],"names":[],"mappings":"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","sourcesContent":["import { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { ScalarObservable } from './ScalarObservable';\nimport { EmptyObservable } from './EmptyObservable';\nimport { Subscriber } from '../Subscriber';\nimport { isScheduler } from '../util/isScheduler';\nimport { TeardownLogic } from '../Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class ArrayObservable<T> extends Observable<T> {\n\n  static create<T>(array: T[], scheduler?: IScheduler): Observable<T> {\n    return new ArrayObservable(array, scheduler);\n  }\n\n  static of<T>(item1: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, item4: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, item4: T, item5: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, item4: T, item5: T, item6: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(...array: Array<T | IScheduler>): Observable<T>;\n  /**\n   * Creates an Observable that emits some values you specify as arguments,\n   * immediately one after the other, and then emits a complete notification.\n   *\n   * <span class=\"informal\">Emits the arguments you provide, then completes.\n   * </span>\n   *\n   * <img src=\"./img/of.png\" width=\"100%\">\n   *\n   * This static operator is useful for creating a simple Observable that only\n   * emits the arguments given, and the complete notification thereafter. It can\n   * be used for composing with other Observables, such as with {@link concat}.\n   * By default, it uses a `null` IScheduler, which means the `next`\n   * notifications are sent synchronously, although with a different IScheduler\n   * it is possible to determine when those notifications will be delivered.\n   *\n   * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>\n   * var numbers = Rx.Observable.of(10, 20, 30);\n   * var letters = Rx.Observable.of('a', 'b', 'c');\n   * var interval = Rx.Observable.interval(1000);\n   * var result = numbers.concat(letters).concat(interval);\n   * result.subscribe(x => console.log(x));\n   *\n   * @see {@link create}\n   * @see {@link empty}\n   * @see {@link never}\n   * @see {@link throw}\n   *\n   * @param {...T} values Arguments that represent `next` values to be emitted.\n   * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n   * the emissions of the `next` notifications.\n   * @return {Observable<T>} An Observable that emits each given input value.\n   * @static true\n   * @name of\n   * @owner Observable\n   */\n  static of<T>(...array: Array<T | IScheduler>): Observable<T> {\n    let scheduler = <IScheduler>array[array.length - 1];\n    if (isScheduler(scheduler)) {\n      array.pop();\n    } else {\n      scheduler = null;\n    }\n\n    const len = array.length;\n    if (len > 1) {\n      return new ArrayObservable<T>(<any>array, scheduler);\n    } else if (len === 1) {\n      return new ScalarObservable<T>(<any>array[0], scheduler);\n    } else {\n      return new EmptyObservable<T>(scheduler);\n    }\n  }\n\n  static dispatch(state: any) {\n\n    const { array, index, count, subscriber } = state;\n\n    if (index >= count) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(array[index]);\n\n    if (subscriber.closed) {\n      return;\n    }\n\n    state.index = index + 1;\n\n    (<any> this).schedule(state);\n  }\n\n  // value used if Array has one value and _isScalar\n  value: any;\n\n  constructor(private array: T[], private scheduler?: IScheduler) {\n    super();\n    if (!scheduler && array.length === 1) {\n      this._isScalar = true;\n      this.value = array[0];\n    }\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n    let index = 0;\n    const array = this.array;\n    const count = array.length;\n    const scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(ArrayObservable.dispatch, 0, {\n        array, index, count, subscriber\n      });\n    } else {\n      for (let i = 0; i < count && !subscriber.closed; i++) {\n        subscriber.next(array[i]);\n      }\n      subscriber.complete();\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}