{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = patchDialogServiceConnectorInline;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _pDeferEs = _interopRequireDefault(require(\"p-defer-es5\")); // Patching a function to add pre-processing of arguments and post-processing of result.\n\n\nfunction patchFunction(fn, pre, post) {\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    args = pre ? pre.apply(void 0, (0, _toConsumableArray2.default)(args)) : args;\n    var result = fn.apply(void 0, (0, _toConsumableArray2.default)(args));\n    return post ? post(result) : result;\n  };\n}\n\nfunction patchDialogServiceConnectorInline(dialogServiceConnector) {\n  // This function will patch DialogServiceConnector by modifying the object.\n  // The patches are intended to fill-in features to make DialogServiceConnector object works like the full-fledged Recognizer object.\n  var lastRecognitionDeferred;\n  dialogServiceConnector.listenOnceAsync = patchFunction(dialogServiceConnector.listenOnceAsync.bind(dialogServiceConnector), function (resolve, reject) {\n    lastRecognitionDeferred = (0, _pDeferEs.default)();\n\n    for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      args[_key2 - 2] = arguments[_key2];\n    }\n\n    return [patchFunction(resolve, null, function (result) {\n      lastRecognitionDeferred.resolve(result);\n      return result;\n    }), patchFunction(reject, null, function (error) {\n      lastRecognitionDeferred.reject(error);\n      return error;\n    })].concat(args);\n  }); // TODO: startContinuousRecognitionAsync is not working yet, use listenOnceAsync instead.\n\n  dialogServiceConnector.startContinuousRecognitionAsync = function (resolve, reject) {\n    dialogServiceConnector.listenOnceAsync(function () {// We will resolve the Promise in a setTimeout.\n    }, function (err) {\n      resolve = null;\n      reject && reject(err);\n    });\n    setTimeout(function () {\n      reject = null;\n      resolve && resolve();\n    }, 0);\n  }; // TODO: stopContinuousRecognitionAsync is not working yet.\n  //       We will leave out the implementation as falsy, Web Chat will disable the microphone button after start dictate.\n  //       This will prevent user from aborting speech recognition.\n  // dialogServiceConnector.stopContinuousRecognitionAsync = resolve => {\n  // };\n\n\n  return dialogServiceConnector;\n}","map":{"version":3,"sources":["../src/patchDialogServiceConnectorInline.js"],"names":["args","pre","result","fn","post","dialogServiceConnector","patchFunction","lastRecognitionDeferred","resolve","reject","setTimeout"],"mappings":";;;;;;;;;;;AAAA,IAAA,SAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,aAAA,CAAA,CAAA,C,CAEA;;;AACA,SAAA,aAAA,CAAA,EAAA,EAAA,GAAA,EAAA,IAAA,EAAsC;AACpC,SAAO,YAAa;AAAA,SAAA,IAAA,IAAA,GAAA,SAAA,CAAA,MAAA,EAATA,IAAS,GAAA,IAAA,KAAA,CAAA,IAAA,CAAA,EAAA,IAAA,GAAA,CAAA,EAAA,IAAA,GAAA,IAAA,EAAA,IAAA,EAAA,EAAA;AAATA,MAAAA,IAAS,CAAA,IAAA,CAATA,GAAS,SAAA,CAAA,IAAA,CAATA;AAAS;;AAClBA,IAAAA,IAAI,GAAGC,GAAG,GAAGA,GAAG,CAAHA,KAAAA,CAAAA,KAAAA,CAAAA,EAAAA,CAAAA,GAAAA,mBAAAA,CAAAA,OAAAA,EAAH,IAAGA,CAAAA,CAAH,GAAVD,IAAAA;AAEA,QAAME,MAAM,GAAGC,EAAE,CAAFA,KAAAA,CAAAA,KAAAA,CAAAA,EAAAA,CAAAA,GAAAA,mBAAAA,CAAAA,OAAAA,EAAf,IAAeA,CAAAA,CAAf;AAEA,WAAOC,IAAI,GAAGA,IAAI,CAAP,MAAO,CAAP,GAAX,MAAA;AALF,GAAA;AAOD;;AAEc,SAAA,iCAAA,CAAA,sBAAA,EAAmE;AAChF;AACA;AAEA,MAAA,uBAAA;AAEAC,EAAAA,sBAAsB,CAAtBA,eAAAA,GAAyCC,aAAa,CACpDD,sBAAsB,CAAtBA,eAAAA,CAAAA,IAAAA,CADoD,sBACpDA,CADoD,EAEpD,UAAA,OAAA,EAAA,MAAA,EAA8B;AAC5BE,IAAAA,uBAAuB,GAAG,CAAA,GAAA,SAAA,CAA1BA,OAA0B,GAA1BA;;AAD4B,SAAA,IAAA,KAAA,GAAA,SAAA,CAAA,MAAA,EAATP,IAAS,GAAA,IAAA,KAAA,CAAA,KAAA,GAAA,CAAA,GAAA,KAAA,GAAA,CAAA,GAAA,CAAA,CAAA,EAAA,KAAA,GAAA,CAAA,EAAA,KAAA,GAAA,KAAA,EAAA,KAAA,EAAA,EAAA;AAATA,MAAAA,IAAS,CAAA,KAAA,GAAA,CAAA,CAATA,GAAS,SAAA,CAAA,KAAA,CAATA;AAAS;;AAG5B,WAAA,CACEM,aAAa,CAAA,OAAA,EAAA,IAAA,EAAgB,UAAA,MAAA,EAAU;AACrCC,MAAAA,uBAAuB,CAAvBA,OAAAA,CAAAA,MAAAA;AAEA,aAAA,MAAA;AAJJ,KACe,CADf,EAMED,aAAa,CAAA,MAAA,EAAA,IAAA,EAAe,UAAA,KAAA,EAAS;AACnCC,MAAAA,uBAAuB,CAAvBA,MAAAA,CAAAA,KAAAA;AAEA,aAAA,KAAA;AATJ,KAMe,CANf,EAAA,MAAA,CAAA,IAAA,CAAA;AAX4E,GAM1B,CAAtDF,CANgF,CA2BhF;;AACAA,EAAAA,sBAAsB,CAAtBA,+BAAAA,GAAyD,UAAA,OAAA,EAAA,MAAA,EAAqB;AAC5EA,IAAAA,sBAAsB,CAAtBA,eAAAA,CACE,YAAM,CACJ;AAFJA,KAAAA,EAIE,UAAA,GAAA,EAAO;AACLG,MAAAA,OAAO,GAAPA,IAAAA;AACAC,MAAAA,MAAM,IAAIA,MAAM,CAAhBA,GAAgB,CAAhBA;AANJJ,KAAAA;AAUAK,IAAAA,UAAU,CAAC,YAAM;AACfD,MAAAA,MAAM,GAANA,IAAAA;AACAD,MAAAA,OAAO,IAAIA,OAAXA,EAAAA;AAFQ,KAAA,EAAVE,CAAU,CAAVA;AAvC8E,GA4BhFL,CA5BgF,CA6ChF;AACA;AACA;AACA;AACA;;;AAEA,SAAA,sBAAA;AACD","sourcesContent":["import createDeferred from 'p-defer-es5';\n\n// Patching a function to add pre-processing of arguments and post-processing of result.\nfunction patchFunction(fn, pre, post) {\n  return (...args) => {\n    args = pre ? pre(...args) : args;\n\n    const result = fn(...args);\n\n    return post ? post(result) : result;\n  };\n}\n\nexport default function patchDialogServiceConnectorInline(dialogServiceConnector) {\n  // This function will patch DialogServiceConnector by modifying the object.\n  // The patches are intended to fill-in features to make DialogServiceConnector object works like the full-fledged Recognizer object.\n\n  let lastRecognitionDeferred;\n\n  dialogServiceConnector.listenOnceAsync = patchFunction(\n    dialogServiceConnector.listenOnceAsync.bind(dialogServiceConnector),\n    (resolve, reject, ...args) => {\n      lastRecognitionDeferred = createDeferred();\n\n      return [\n        patchFunction(resolve, null, result => {\n          lastRecognitionDeferred.resolve(result);\n\n          return result;\n        }),\n        patchFunction(reject, null, error => {\n          lastRecognitionDeferred.reject(error);\n\n          return error;\n        }),\n        ...args\n      ];\n    }\n  );\n\n  // TODO: startContinuousRecognitionAsync is not working yet, use listenOnceAsync instead.\n  dialogServiceConnector.startContinuousRecognitionAsync = (resolve, reject) => {\n    dialogServiceConnector.listenOnceAsync(\n      () => {\n        // We will resolve the Promise in a setTimeout.\n      },\n      err => {\n        resolve = null;\n        reject && reject(err);\n      }\n    );\n\n    setTimeout(() => {\n      reject = null;\n      resolve && resolve();\n    }, 0);\n  };\n\n  // TODO: stopContinuousRecognitionAsync is not working yet.\n  //       We will leave out the implementation as falsy, Web Chat will disable the microphone button after start dictate.\n  //       This will prevent user from aborting speech recognition.\n  // dialogServiceConnector.stopContinuousRecognitionAsync = resolve => {\n  // };\n\n  return dialogServiceConnector;\n}\n"],"sourceRoot":"directlinespeech:///"},"metadata":{},"sourceType":"script"}