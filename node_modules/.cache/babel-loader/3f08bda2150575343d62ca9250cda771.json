{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { createNoDashGuid, Deferred, Events, PromiseState } from \"../common/Exports\";\nimport { ConnectingToServiceEvent, ListeningStartedEvent, RecognitionStartedEvent, RecognitionTriggeredEvent } from \"./RecognitionEvents\";\nimport { ServiceTelemetryListener } from \"./ServiceTelemetryListener.Internal\";\nexport var RequestSession = /*#__PURE__*/function () {\n  function RequestSession(audioSourceId) {\n    var _this = this;\n\n    _classCallCheck(this, RequestSession);\n\n    this.privIsDisposed = false;\n    this.privDetachables = new Array();\n    this.privIsAudioNodeDetached = false;\n    this.privIsRecognizing = false;\n    this.privIsSpeechEnded = false;\n    this.privTurnStartAudioOffset = 0;\n    this.privLastRecoOffset = 0;\n    this.privHypothesisReceived = false;\n    this.privBytesSent = 0;\n    this.privRecogNumber = 0;\n\n    this.onAudioSourceAttachCompleted = function (audioNode, isError, error) {\n      _this.privAudioNode = audioNode;\n      _this.privIsAudioNodeDetached = false;\n\n      if (isError) {\n        _this.onComplete();\n      } else {\n        _this.onEvent(new ListeningStartedEvent(_this.privRequestId, _this.privSessionId, _this.privAudioSourceId, _this.privAudioNodeId));\n      }\n    };\n\n    this.onPreConnectionStart = function (authFetchEventId, connectionId) {\n      _this.privAuthFetchEventId = authFetchEventId;\n      _this.privSessionId = connectionId;\n\n      _this.onEvent(new ConnectingToServiceEvent(_this.privRequestId, _this.privAuthFetchEventId, _this.privSessionId));\n    };\n\n    this.onAuthCompleted = function (isError, error) {\n      if (isError) {\n        _this.onComplete();\n      }\n    };\n\n    this.onConnectionEstablishCompleted = function (statusCode, reason) {\n      if (statusCode === 200) {\n        _this.onEvent(new RecognitionStartedEvent(_this.requestId, _this.privAudioSourceId, _this.privAudioNodeId, _this.privAuthFetchEventId, _this.privSessionId));\n\n        if (!!_this.privAudioNode) {\n          _this.privAudioNode.replay();\n        }\n\n        _this.privTurnStartAudioOffset = _this.privLastRecoOffset;\n        _this.privBytesSent = 0;\n        return;\n      } else if (statusCode === 403) {\n        _this.onComplete();\n      }\n    };\n\n    this.onServiceTurnEndResponse = function (continuousRecognition) {\n      _this.privTurnDeferral.resolve(true);\n\n      if (!continuousRecognition || _this.isSpeechEnded) {\n        _this.onComplete();\n      } else {\n        // Start a new request set.\n        _this.privTurnStartAudioOffset = _this.privLastRecoOffset;\n        _this.privRequestId = createNoDashGuid();\n\n        _this.privAudioNode.replay();\n      }\n    };\n\n    this.onServiceTurnStartResponse = function () {\n      if (_this.privTurnDeferral.state() === PromiseState.None) {\n        // What? How are we starting a turn with another not done?\n        _this.privTurnDeferral.reject(\"Another turn started before current completed.\");\n      }\n\n      _this.privTurnDeferral = new Deferred();\n    };\n\n    this.dispose = function (error) {\n      if (!_this.privIsDisposed) {\n        // we should have completed by now. If we did not its an unknown error.\n        _this.privIsDisposed = true;\n\n        var _iterator = _createForOfIteratorHelper(_this.privDetachables),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var detachable = _step.value;\n            detachable.detach();\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        _this.privServiceTelemetryListener.dispose();\n      }\n    };\n\n    this.getTelemetry = function () {\n      if (_this.privServiceTelemetryListener.hasTelemetry) {\n        return _this.privServiceTelemetryListener.getTelemetry();\n      } else {\n        return null;\n      }\n    };\n\n    this.onEvent = function (event) {\n      if (!!_this.privServiceTelemetryListener) {\n        _this.privServiceTelemetryListener.onEvent(event);\n      }\n\n      Events.instance.onEvent(event);\n    };\n\n    this.onComplete = function () {\n      if (!!_this.privIsRecognizing) {\n        _this.privIsRecognizing = false;\n\n        _this.detachAudioNode();\n      }\n    };\n\n    this.detachAudioNode = function () {\n      if (!_this.privIsAudioNodeDetached) {\n        _this.privIsAudioNodeDetached = true;\n\n        if (_this.privAudioNode) {\n          _this.privAudioNode.detach();\n        }\n      }\n    };\n\n    this.privAudioSourceId = audioSourceId;\n    this.privRequestId = createNoDashGuid();\n    this.privAudioNodeId = createNoDashGuid();\n    this.privTurnDeferral = new Deferred(); // We're not in a turn, so resolve.\n\n    this.privTurnDeferral.resolve(true);\n  }\n\n  _createClass(RequestSession, [{\n    key: \"sessionId\",\n    get: function get() {\n      return this.privSessionId;\n    }\n  }, {\n    key: \"requestId\",\n    get: function get() {\n      return this.privRequestId;\n    }\n  }, {\n    key: \"audioNodeId\",\n    get: function get() {\n      return this.privAudioNodeId;\n    }\n  }, {\n    key: \"turnCompletionPromise\",\n    get: function get() {\n      return this.privTurnDeferral.promise();\n    }\n  }, {\n    key: \"isSpeechEnded\",\n    get: function get() {\n      return this.privIsSpeechEnded;\n    }\n  }, {\n    key: \"isRecognizing\",\n    get: function get() {\n      return this.privIsRecognizing;\n    }\n  }, {\n    key: \"currentTurnAudioOffset\",\n    get: function get() {\n      return this.privTurnStartAudioOffset;\n    }\n  }, {\n    key: \"recogNumber\",\n    get: function get() {\n      return this.privRecogNumber;\n    } // The number of bytes sent for the current connection.\n    // Counter is reset to 0 each time a connection is established.\n\n  }, {\n    key: \"bytesSent\",\n    get: function get() {\n      return this.privBytesSent;\n    }\n  }, {\n    key: \"listenForServiceTelemetry\",\n    value: function listenForServiceTelemetry(eventSource) {\n      if (!!this.privServiceTelemetryListener) {\n        this.privDetachables.push(eventSource.attachListener(this.privServiceTelemetryListener));\n      }\n    }\n  }, {\n    key: \"startNewRecognition\",\n    value: function startNewRecognition() {\n      this.privIsSpeechEnded = false;\n      this.privIsRecognizing = true;\n      this.privTurnStartAudioOffset = 0;\n      this.privLastRecoOffset = 0;\n      this.privRequestId = createNoDashGuid();\n      this.privRecogNumber++;\n      this.privServiceTelemetryListener = new ServiceTelemetryListener(this.privRequestId, this.privAudioSourceId, this.privAudioNodeId);\n      this.onEvent(new RecognitionTriggeredEvent(this.requestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));\n    }\n  }, {\n    key: \"onHypothesis\",\n    value: function onHypothesis(offset) {\n      if (!this.privHypothesisReceived) {\n        this.privHypothesisReceived = true;\n        this.privServiceTelemetryListener.hypothesisReceived(this.privAudioNode.findTimeAtOffset(offset));\n      }\n    }\n  }, {\n    key: \"onPhraseRecognized\",\n    value: function onPhraseRecognized(offset) {\n      this.privServiceTelemetryListener.phraseReceived(this.privAudioNode.findTimeAtOffset(offset));\n      this.onServiceRecognized(offset);\n    }\n  }, {\n    key: \"onServiceRecognized\",\n    value: function onServiceRecognized(offset) {\n      this.privLastRecoOffset = offset;\n      this.privHypothesisReceived = false;\n      this.privAudioNode.shrinkBuffers(offset);\n    }\n  }, {\n    key: \"onAudioSent\",\n    value: function onAudioSent(bytesSent) {\n      this.privBytesSent += bytesSent;\n    }\n  }, {\n    key: \"onStopRecognizing\",\n    value: function onStopRecognizing() {\n      this.onComplete();\n    } // Should be called with the audioNode for this session has indicated that it is out of speech.\n\n  }, {\n    key: \"onSpeechEnded\",\n    value: function onSpeechEnded() {\n      this.privIsSpeechEnded = true;\n    }\n  }]);\n\n  return RequestSession;\n}();","map":{"version":3,"sources":["src/common.speech/RequestSession.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { ReplayableAudioNode } from \"../common.browser/Exports\";\r\nimport {\r\n    createNoDashGuid,\r\n    Deferred,\r\n    Events,\r\n    IDetachable,\r\n    IEventSource,\r\n    PlatformEvent,\r\n    Promise,\r\n    PromiseState\r\n} from \"../common/Exports\";\r\nimport {\r\n    ConnectingToServiceEvent,\r\n    ListeningStartedEvent,\r\n    RecognitionStartedEvent,\r\n    RecognitionTriggeredEvent,\r\n    SpeechRecognitionEvent,\r\n} from \"./RecognitionEvents\";\r\nimport { ServiceTelemetryListener } from \"./ServiceTelemetryListener.Internal\";\r\n\r\nexport class RequestSession {\r\n    private privIsDisposed: boolean = false;\r\n    private privServiceTelemetryListener: ServiceTelemetryListener;\r\n    private privDetachables: IDetachable[] = new Array<IDetachable>();\r\n    private privRequestId: string;\r\n    private privAudioSourceId: string;\r\n    private privAudioNodeId: string;\r\n    private privAudioNode: ReplayableAudioNode;\r\n    private privAuthFetchEventId: string;\r\n    private privIsAudioNodeDetached: boolean = false;\r\n    private privIsRecognizing: boolean = false;\r\n    private privIsSpeechEnded: boolean = false;\r\n    private privTurnStartAudioOffset: number = 0;\r\n    private privLastRecoOffset: number = 0;\r\n    private privHypothesisReceived: boolean = false;\r\n    private privBytesSent: number = 0;\r\n    private privRecogNumber: number = 0;\r\n    private privSessionId: string;\r\n    private privTurnDeferral: Deferred<boolean>;\r\n\r\n    constructor(audioSourceId: string) {\r\n        this.privAudioSourceId = audioSourceId;\r\n        this.privRequestId = createNoDashGuid();\r\n        this.privAudioNodeId = createNoDashGuid();\r\n        this.privTurnDeferral = new Deferred<boolean>();\r\n\r\n        // We're not in a turn, so resolve.\r\n        this.privTurnDeferral.resolve(true);\r\n    }\r\n\r\n    public get sessionId(): string {\r\n        return this.privSessionId;\r\n    }\r\n\r\n    public get requestId(): string {\r\n        return this.privRequestId;\r\n    }\r\n\r\n    public get audioNodeId(): string {\r\n        return this.privAudioNodeId;\r\n    }\r\n\r\n    public get turnCompletionPromise(): Promise<boolean> {\r\n        return this.privTurnDeferral.promise();\r\n    }\r\n\r\n    public get isSpeechEnded(): boolean {\r\n        return this.privIsSpeechEnded;\r\n    }\r\n\r\n    public get isRecognizing(): boolean {\r\n        return this.privIsRecognizing;\r\n    }\r\n\r\n    public get currentTurnAudioOffset(): number {\r\n        return this.privTurnStartAudioOffset;\r\n    }\r\n\r\n    public get recogNumber(): number {\r\n        return this.privRecogNumber;\r\n    }\r\n\r\n    // The number of bytes sent for the current connection.\r\n    // Counter is reset to 0 each time a connection is established.\r\n    public get bytesSent(): number {\r\n        return this.privBytesSent;\r\n    }\r\n    public listenForServiceTelemetry(eventSource: IEventSource<PlatformEvent>): void {\r\n        if (!!this.privServiceTelemetryListener) {\r\n            this.privDetachables.push(eventSource.attachListener(this.privServiceTelemetryListener));\r\n        }\r\n    }\r\n\r\n    public startNewRecognition(): void {\r\n        this.privIsSpeechEnded = false;\r\n        this.privIsRecognizing = true;\r\n        this.privTurnStartAudioOffset = 0;\r\n        this.privLastRecoOffset = 0;\r\n        this.privRequestId = createNoDashGuid();\r\n        this.privRecogNumber++;\r\n        this.privServiceTelemetryListener = new ServiceTelemetryListener(this.privRequestId, this.privAudioSourceId, this.privAudioNodeId);\r\n        this.onEvent(new RecognitionTriggeredEvent(this.requestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));\r\n    }\r\n\r\n    public onAudioSourceAttachCompleted = (audioNode: ReplayableAudioNode, isError: boolean, error?: string): void => {\r\n        this.privAudioNode = audioNode;\r\n        this.privIsAudioNodeDetached = false;\r\n\r\n        if (isError) {\r\n            this.onComplete();\r\n        } else {\r\n            this.onEvent(new ListeningStartedEvent(this.privRequestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));\r\n        }\r\n    }\r\n\r\n    public onPreConnectionStart = (authFetchEventId: string, connectionId: string): void => {\r\n        this.privAuthFetchEventId = authFetchEventId;\r\n        this.privSessionId = connectionId;\r\n        this.onEvent(new ConnectingToServiceEvent(this.privRequestId, this.privAuthFetchEventId, this.privSessionId));\r\n    }\r\n\r\n    public onAuthCompleted = (isError: boolean, error?: string): void => {\r\n        if (isError) {\r\n            this.onComplete();\r\n        }\r\n    }\r\n\r\n    public onConnectionEstablishCompleted = (statusCode: number, reason?: string): void => {\r\n        if (statusCode === 200) {\r\n            this.onEvent(new RecognitionStartedEvent(this.requestId, this.privAudioSourceId, this.privAudioNodeId, this.privAuthFetchEventId, this.privSessionId));\r\n            if (!!this.privAudioNode) {\r\n                this.privAudioNode.replay();\r\n            }\r\n            this.privTurnStartAudioOffset = this.privLastRecoOffset;\r\n            this.privBytesSent = 0;\r\n            return;\r\n        } else if (statusCode === 403) {\r\n            this.onComplete();\r\n        }\r\n    }\r\n\r\n    public onServiceTurnEndResponse = (continuousRecognition: boolean): void => {\r\n        this.privTurnDeferral.resolve(true);\r\n\r\n        if (!continuousRecognition || this.isSpeechEnded) {\r\n            this.onComplete();\r\n        } else {\r\n            // Start a new request set.\r\n            this.privTurnStartAudioOffset = this.privLastRecoOffset;\r\n            this.privRequestId = createNoDashGuid();\r\n            this.privAudioNode.replay();\r\n        }\r\n    }\r\n\r\n    public onServiceTurnStartResponse = (): void => {\r\n        if (this.privTurnDeferral.state() === PromiseState.None) {\r\n            // What? How are we starting a turn with another not done?\r\n            this.privTurnDeferral.reject(\"Another turn started before current completed.\");\r\n        }\r\n\r\n        this.privTurnDeferral = new Deferred<boolean>();\r\n    }\r\n\r\n    public onHypothesis(offset: number): void {\r\n        if (!this.privHypothesisReceived) {\r\n            this.privHypothesisReceived = true;\r\n            this.privServiceTelemetryListener.hypothesisReceived(this.privAudioNode.findTimeAtOffset(offset));\r\n        }\r\n    }\r\n\r\n    public onPhraseRecognized(offset: number): void {\r\n        this.privServiceTelemetryListener.phraseReceived(this.privAudioNode.findTimeAtOffset(offset));\r\n        this.onServiceRecognized(offset);\r\n    }\r\n\r\n    public onServiceRecognized(offset: number): void {\r\n        this.privLastRecoOffset = offset;\r\n        this.privHypothesisReceived = false;\r\n        this.privAudioNode.shrinkBuffers(offset);\r\n    }\r\n\r\n    public onAudioSent(bytesSent: number): void {\r\n        this.privBytesSent += bytesSent;\r\n    }\r\n\r\n    public dispose = (error?: string): void => {\r\n        if (!this.privIsDisposed) {\r\n            // we should have completed by now. If we did not its an unknown error.\r\n            this.privIsDisposed = true;\r\n            for (const detachable of this.privDetachables) {\r\n                detachable.detach();\r\n            }\r\n\r\n            this.privServiceTelemetryListener.dispose();\r\n        }\r\n    }\r\n\r\n    public getTelemetry = (): string => {\r\n        if (this.privServiceTelemetryListener.hasTelemetry) {\r\n            return this.privServiceTelemetryListener.getTelemetry();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public onStopRecognizing(): void {\r\n        this.onComplete();\r\n    }\r\n\r\n    // Should be called with the audioNode for this session has indicated that it is out of speech.\r\n    public onSpeechEnded(): void {\r\n        this.privIsSpeechEnded = true;\r\n    }\r\n\r\n    protected onEvent = (event: SpeechRecognitionEvent): void => {\r\n        if (!!this.privServiceTelemetryListener) {\r\n            this.privServiceTelemetryListener.onEvent(event);\r\n        }\r\n        Events.instance.onEvent(event);\r\n    }\r\n\r\n    private onComplete = (): void => {\r\n        if (!!this.privIsRecognizing) {\r\n            this.privIsRecognizing = false;\r\n            this.detachAudioNode();\r\n        }\r\n    }\r\n\r\n    private detachAudioNode = (): void => {\r\n        if (!this.privIsAudioNodeDetached) {\r\n            this.privIsAudioNodeDetached = true;\r\n            if (this.privAudioNode) {\r\n                this.privAudioNode.detach();\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}