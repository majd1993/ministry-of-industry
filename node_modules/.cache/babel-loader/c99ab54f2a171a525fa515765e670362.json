{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { PromiseHelper } from \"../common/Exports\";\nexport var ReplayableAudioNode = /*#__PURE__*/function () {\n  function ReplayableAudioNode(audioSource, bytesPerSecond) {\n    var _this = this;\n\n    _classCallCheck(this, ReplayableAudioNode);\n\n    this.privBuffers = [];\n    this.privReplayOffset = 0;\n    this.privLastShrinkOffset = 0;\n    this.privBufferStartOffset = 0;\n    this.privBufferSerial = 0;\n    this.privBufferedBytes = 0;\n    this.privReplay = false;\n    this.privLastChunkAcquiredTime = 0;\n\n    this.id = function () {\n      return _this.privAudioNode.id();\n    };\n\n    this.privAudioNode = audioSource;\n    this.privBytesPerSecond = bytesPerSecond;\n  } // Reads and returns the next chunk of audio buffer.\n  // If replay of existing buffers are needed, read() will first seek and replay\n  // existing content, and upoin completion it will read new content from the underlying\n  // audio node, saving that content into the replayable buffers.\n\n\n  _createClass(ReplayableAudioNode, [{\n    key: \"read\",\n    value: function read() {\n      var _this2 = this;\n\n      // if there is a replay request to honor.\n      if (!!this.privReplay && this.privBuffers.length !== 0) {\n        // Find the start point in the buffers.\n        // Offsets are in 100ns increments.\n        // So how many bytes do we need to seek to get the right offset?\n        var offsetToSeek = this.privReplayOffset - this.privBufferStartOffset;\n        var bytesToSeek = Math.round(offsetToSeek * this.privBytesPerSecond * 1e-7);\n\n        if (0 !== bytesToSeek % 2) {\n          bytesToSeek++;\n        }\n\n        var i = 0;\n\n        while (i < this.privBuffers.length && bytesToSeek >= this.privBuffers[i].chunk.buffer.byteLength) {\n          bytesToSeek -= this.privBuffers[i++].chunk.buffer.byteLength;\n        }\n\n        var retVal = this.privBuffers[i].chunk.buffer.slice(bytesToSeek);\n        this.privReplayOffset += retVal.byteLength / this.privBytesPerSecond * 1e+7; // If we've reached the end of the buffers, stop replaying.\n\n        if (i === this.privBuffers.length - 1) {\n          this.privReplay = false;\n        }\n\n        return PromiseHelper.fromResult({\n          buffer: retVal,\n          isEnd: false,\n          timeReceived: this.privBuffers[i].chunk.timeReceived\n        });\n      }\n\n      return this.privAudioNode.read().onSuccessContinueWith(function (result) {\n        if (result && result.buffer) {\n          _this2.privBuffers.push(new BufferEntry(result, _this2.privBufferSerial++, _this2.privBufferedBytes));\n\n          _this2.privBufferedBytes += result.buffer.byteLength;\n        }\n\n        return result;\n      });\n    }\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      this.privAudioNode.detach();\n      this.privBuffers = undefined;\n    }\n  }, {\n    key: \"replay\",\n    value: function replay() {\n      if (this.privBuffers && 0 !== this.privBuffers.length) {\n        this.privReplay = true;\n        this.privReplayOffset = this.privLastShrinkOffset;\n      }\n    } // Shrinks the existing audio buffers to start at the new offset, or at the\n    // beginning of the buffer closest to the requested offset.\n    // A replay request will start from the last shrink point.\n\n  }, {\n    key: \"shrinkBuffers\",\n    value: function shrinkBuffers(offset) {\n      if (this.privBuffers === undefined) {\n        return;\n      }\n\n      this.privLastShrinkOffset = offset; // Find the start point in the buffers.\n      // Offsets are in 100ns increments.\n      // So how many bytes do we need to seek to get the right offset?\n\n      var offsetToSeek = offset - this.privBufferStartOffset;\n      var bytesToSeek = Math.round(offsetToSeek * this.privBytesPerSecond * 1e-7);\n      var i = 0;\n\n      while (i < this.privBuffers.length && bytesToSeek >= this.privBuffers[i].chunk.buffer.byteLength) {\n        bytesToSeek -= this.privBuffers[i++].chunk.buffer.byteLength;\n      }\n\n      this.privBufferStartOffset = Math.round(offset - bytesToSeek / this.privBytesPerSecond * 1e+7);\n      this.privBuffers = this.privBuffers.slice(i);\n    } // Finds the time a buffer of audio was first seen by offset.\n\n  }, {\n    key: \"findTimeAtOffset\",\n    value: function findTimeAtOffset(offset) {\n      if (offset < this.privBufferStartOffset || this.privBuffers === undefined) {\n        return 0;\n      }\n\n      var _iterator = _createForOfIteratorHelper(this.privBuffers),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var value = _step.value;\n          var startOffset = value.byteOffset / this.privBytesPerSecond * 1e7;\n          var endOffset = startOffset + value.chunk.buffer.byteLength / this.privBytesPerSecond * 1e7;\n\n          if (offset >= startOffset && offset <= endOffset) {\n            return value.chunk.timeReceived;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return 0;\n    }\n  }]);\n\n  return ReplayableAudioNode;\n}(); // Primary use of this class is to help debugging problems with the replay\n// code. If the memory cost of alloc / dealloc gets too much, drop it and just use\n// the ArrayBuffer directly.\n// tslint:disable-next-line:max-classes-per-file\n\nvar BufferEntry = function BufferEntry(chunk, serial, byteOffset) {\n  _classCallCheck(this, BufferEntry);\n\n  this.chunk = chunk;\n  this.serial = serial;\n  this.byteOffset = byteOffset;\n};","map":{"version":3,"sources":["src/common.browser/ReplayableAudioNode.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { AudioStreamFormatImpl } from \"../../src/sdk/Audio/AudioStreamFormat\";\r\nimport {\r\n    IAudioStreamNode,\r\n    IStreamChunk,\r\n    Promise,\r\n    PromiseHelper,\r\n} from \"../common/Exports\";\r\n\r\nexport class ReplayableAudioNode implements IAudioStreamNode {\r\n    private privAudioNode: IAudioStreamNode;\r\n    private privBytesPerSecond: number;\r\n    private privBuffers: BufferEntry[] = [];\r\n    private privReplayOffset: number = 0;\r\n    private privLastShrinkOffset: number = 0;\r\n    private privBufferStartOffset: number = 0;\r\n    private privBufferSerial: number = 0;\r\n    private privBufferedBytes: number = 0;\r\n    private privReplay: boolean = false;\r\n    private privLastChunkAcquiredTime: number = 0;\r\n\r\n    public constructor(audioSource: IAudioStreamNode, bytesPerSecond: number) {\r\n        this.privAudioNode = audioSource;\r\n        this.privBytesPerSecond = bytesPerSecond;\r\n    }\r\n\r\n    public id = (): string => {\r\n        return this.privAudioNode.id();\r\n    }\r\n\r\n    // Reads and returns the next chunk of audio buffer.\r\n    // If replay of existing buffers are needed, read() will first seek and replay\r\n    // existing content, and upoin completion it will read new content from the underlying\r\n    // audio node, saving that content into the replayable buffers.\r\n    public read(): Promise<IStreamChunk<ArrayBuffer>> {\r\n        // if there is a replay request to honor.\r\n        if (!!this.privReplay && this.privBuffers.length !== 0) {\r\n            // Find the start point in the buffers.\r\n            // Offsets are in 100ns increments.\r\n            // So how many bytes do we need to seek to get the right offset?\r\n            const offsetToSeek: number = this.privReplayOffset - this.privBufferStartOffset;\r\n\r\n            let bytesToSeek: number = Math.round(offsetToSeek * this.privBytesPerSecond * 1e-7);\r\n            if (0 !== (bytesToSeek % 2)) {\r\n                bytesToSeek++;\r\n            }\r\n\r\n            let i: number = 0;\r\n\r\n            while (i < this.privBuffers.length && bytesToSeek >= this.privBuffers[i].chunk.buffer.byteLength) {\r\n                bytesToSeek -= this.privBuffers[i++].chunk.buffer.byteLength;\r\n            }\r\n\r\n            const retVal: ArrayBuffer = this.privBuffers[i].chunk.buffer.slice(bytesToSeek);\r\n\r\n            this.privReplayOffset += (retVal.byteLength / this.privBytesPerSecond) * 1e+7;\r\n\r\n            // If we've reached the end of the buffers, stop replaying.\r\n            if (i === this.privBuffers.length - 1) {\r\n                this.privReplay = false;\r\n            }\r\n\r\n            return PromiseHelper.fromResult<IStreamChunk<ArrayBuffer>>({\r\n                buffer: retVal,\r\n                isEnd: false,\r\n                timeReceived: this.privBuffers[i].chunk.timeReceived,\r\n            });\r\n        }\r\n\r\n        return this.privAudioNode.read()\r\n            .onSuccessContinueWith((result: IStreamChunk<ArrayBuffer>) => {\r\n                if (result && result.buffer) {\r\n                    this.privBuffers.push(new BufferEntry(result, this.privBufferSerial++, this.privBufferedBytes));\r\n                    this.privBufferedBytes += result.buffer.byteLength;\r\n                }\r\n                return result;\r\n            });\r\n    }\r\n\r\n    public detach(): void {\r\n        this.privAudioNode.detach();\r\n        this.privBuffers = undefined;\r\n    }\r\n\r\n    public replay(): void {\r\n        if (this.privBuffers && 0 !== this.privBuffers.length) {\r\n            this.privReplay = true;\r\n            this.privReplayOffset = this.privLastShrinkOffset;\r\n        }\r\n    }\r\n\r\n    // Shrinks the existing audio buffers to start at the new offset, or at the\r\n    // beginning of the buffer closest to the requested offset.\r\n    // A replay request will start from the last shrink point.\r\n    public shrinkBuffers(offset: number): void {\r\n        if (this.privBuffers === undefined) {\r\n            return;\r\n        }\r\n\r\n        this.privLastShrinkOffset = offset;\r\n\r\n        // Find the start point in the buffers.\r\n        // Offsets are in 100ns increments.\r\n        // So how many bytes do we need to seek to get the right offset?\r\n        const offsetToSeek: number = offset - this.privBufferStartOffset;\r\n\r\n        let bytesToSeek: number = Math.round(offsetToSeek * this.privBytesPerSecond * 1e-7);\r\n\r\n        let i: number = 0;\r\n\r\n        while (i < this.privBuffers.length && bytesToSeek >= this.privBuffers[i].chunk.buffer.byteLength) {\r\n            bytesToSeek -= this.privBuffers[i++].chunk.buffer.byteLength;\r\n        }\r\n        this.privBufferStartOffset = Math.round(offset - ((bytesToSeek / this.privBytesPerSecond) * 1e+7));\r\n        this.privBuffers = this.privBuffers.slice(i);\r\n    }\r\n\r\n    // Finds the time a buffer of audio was first seen by offset.\r\n    public findTimeAtOffset(offset: number): number {\r\n        if (offset < this.privBufferStartOffset || this.privBuffers === undefined) {\r\n            return 0;\r\n        }\r\n\r\n        for (const value of this.privBuffers) {\r\n            const startOffset: number = (value.byteOffset / this.privBytesPerSecond) * 1e7;\r\n            const endOffset: number = startOffset + ((value.chunk.buffer.byteLength / this.privBytesPerSecond) * 1e7);\r\n\r\n            if (offset >= startOffset && offset <= endOffset) {\r\n                return value.chunk.timeReceived;\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n}\r\n\r\n// Primary use of this class is to help debugging problems with the replay\r\n// code. If the memory cost of alloc / dealloc gets too much, drop it and just use\r\n// the ArrayBuffer directly.\r\n// tslint:disable-next-line:max-classes-per-file\r\nclass BufferEntry {\r\n    public chunk: IStreamChunk<ArrayBuffer>;\r\n    public serial: number;\r\n    public byteOffset: number;\r\n\r\n    public constructor(chunk: IStreamChunk<ArrayBuffer>, serial: number, byteOffset: number) {\r\n        this.chunk = chunk;\r\n        this.serial = serial;\r\n        this.byteOffset = byteOffset;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}