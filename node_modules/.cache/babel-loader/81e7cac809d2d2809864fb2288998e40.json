{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) {\n    if (b.hasOwnProperty(p)) d[p] = b[p];\n  }\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar async_1 = require('../scheduler/async');\n\nvar isDate_1 = require('../util/isDate');\n\nvar Subscriber_1 = require('../Subscriber');\n\nvar Notification_1 = require('../Notification');\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * <img src=\"./img/delay.png\" width=\"100%\">\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * @example <caption>Delay each click by one second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @example <caption>Delay all clicks until a future date happens</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var date = new Date('March 15, 2050 12:00:00'); // in the future\n * var delayedClicks = clicks.delay(date); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n *\n * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n * a `Date` until which the emission of the source items is delayed.\n * @param {Scheduler} [scheduler=async] The IScheduler to use for\n * managing the timers that handle the time-shift for each item.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified timeout or Date.\n * @method delay\n * @owner Observable\n */\n\n\nfunction delay(delay, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async_1.async;\n  }\n\n  var absoluteDelay = isDate_1.isDate(delay);\n  var delayFor = absoluteDelay ? +delay - scheduler.now() : Math.abs(delay);\n  return function (source) {\n    return source.lift(new DelayOperator(delayFor, scheduler));\n  };\n}\n\nexports.delay = delay;\n\nvar DelayOperator = function () {\n  function DelayOperator(delay, scheduler) {\n    this.delay = delay;\n    this.scheduler = scheduler;\n  }\n\n  DelayOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));\n  };\n\n  return DelayOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar DelaySubscriber = function (_super) {\n  __extends(DelaySubscriber, _super);\n\n  function DelaySubscriber(destination, delay, scheduler) {\n    _super.call(this, destination);\n\n    this.delay = delay;\n    this.scheduler = scheduler;\n    this.queue = [];\n    this.active = false;\n    this.errored = false;\n  }\n\n  DelaySubscriber.dispatch = function (state) {\n    var source = state.source;\n    var queue = source.queue;\n    var scheduler = state.scheduler;\n    var destination = state.destination;\n\n    while (queue.length > 0 && queue[0].time - scheduler.now() <= 0) {\n      queue.shift().notification.observe(destination);\n    }\n\n    if (queue.length > 0) {\n      var delay_1 = Math.max(0, queue[0].time - scheduler.now());\n      this.schedule(state, delay_1);\n    } else {\n      source.active = false;\n    }\n  };\n\n  DelaySubscriber.prototype._schedule = function (scheduler) {\n    this.active = true;\n    this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {\n      source: this,\n      destination: this.destination,\n      scheduler: scheduler\n    }));\n  };\n\n  DelaySubscriber.prototype.scheduleNotification = function (notification) {\n    if (this.errored === true) {\n      return;\n    }\n\n    var scheduler = this.scheduler;\n    var message = new DelayMessage(scheduler.now() + this.delay, notification);\n    this.queue.push(message);\n\n    if (this.active === false) {\n      this._schedule(scheduler);\n    }\n  };\n\n  DelaySubscriber.prototype._next = function (value) {\n    this.scheduleNotification(Notification_1.Notification.createNext(value));\n  };\n\n  DelaySubscriber.prototype._error = function (err) {\n    this.errored = true;\n    this.queue = [];\n    this.destination.error(err);\n  };\n\n  DelaySubscriber.prototype._complete = function () {\n    this.scheduleNotification(Notification_1.Notification.createComplete());\n  };\n\n  return DelaySubscriber;\n}(Subscriber_1.Subscriber);\n\nvar DelayMessage = function () {\n  function DelayMessage(time, notification) {\n    this.time = time;\n    this.notification = notification;\n  }\n\n  return DelayMessage;\n}();","map":{"version":3,"sources":["../../src/operators/delay.ts"],"names":[],"mappings":"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","sourcesContent":["import { async } from '../scheduler/async';\nimport { isDate } from '../util/isDate';\nimport { Operator } from '../Operator';\nimport { IScheduler } from '../Scheduler';\nimport { Subscriber } from '../Subscriber';\nimport { Action } from '../scheduler/Action';\nimport { Notification } from '../Notification';\nimport { Observable } from '../Observable';\nimport { PartialObserver } from '../Observer';\nimport { TeardownLogic } from '../Subscription';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * <img src=\"./img/delay.png\" width=\"100%\">\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * @example <caption>Delay each click by one second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @example <caption>Delay all clicks until a future date happens</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var date = new Date('March 15, 2050 12:00:00'); // in the future\n * var delayedClicks = clicks.delay(date); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n *\n * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n * a `Date` until which the emission of the source items is delayed.\n * @param {Scheduler} [scheduler=async] The IScheduler to use for\n * managing the timers that handle the time-shift for each item.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified timeout or Date.\n * @method delay\n * @owner Observable\n */\nexport function delay<T>(delay: number|Date,\n                         scheduler: IScheduler = async): MonoTypeOperatorFunction<T> {\n  const absoluteDelay = isDate(delay);\n  const delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(<number>delay);\n  return (source: Observable<T>) => source.lift(new DelayOperator(delayFor, scheduler));\n}\n\nclass DelayOperator<T> implements Operator<T, T> {\n  constructor(private delay: number,\n              private scheduler: IScheduler) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));\n  }\n}\n\ninterface DelayState<T> {\n  source: DelaySubscriber<T>;\n  destination: PartialObserver<T>;\n  scheduler: IScheduler;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DelaySubscriber<T> extends Subscriber<T> {\n  private queue: Array<DelayMessage<T>> = [];\n  private active: boolean = false;\n  private errored: boolean = false;\n\n  private static dispatch<T>(this: Action<DelayState<T>>, state: DelayState<T>): void {\n    const source = state.source;\n    const queue = source.queue;\n    const scheduler = state.scheduler;\n    const destination = state.destination;\n\n    while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {\n      queue.shift().notification.observe(destination);\n    }\n\n    if (queue.length > 0) {\n      const delay = Math.max(0, queue[0].time - scheduler.now());\n      this.schedule(state, delay);\n    } else {\n      source.active = false;\n    }\n  }\n\n  constructor(destination: Subscriber<T>,\n              private delay: number,\n              private scheduler: IScheduler) {\n    super(destination);\n  }\n\n  private _schedule(scheduler: IScheduler): void {\n    this.active = true;\n    this.add(scheduler.schedule<DelayState<T>>(DelaySubscriber.dispatch, this.delay, {\n      source: this, destination: this.destination, scheduler: scheduler\n    }));\n  }\n\n  private scheduleNotification(notification: Notification<T>): void {\n    if (this.errored === true) {\n      return;\n    }\n\n    const scheduler = this.scheduler;\n    const message = new DelayMessage(scheduler.now() + this.delay, notification);\n    this.queue.push(message);\n\n    if (this.active === false) {\n      this._schedule(scheduler);\n    }\n  }\n\n  protected _next(value: T) {\n    this.scheduleNotification(Notification.createNext(value));\n  }\n\n  protected _error(err: any) {\n    this.errored = true;\n    this.queue = [];\n    this.destination.error(err);\n  }\n\n  protected _complete() {\n    this.scheduleNotification(Notification.createComplete());\n  }\n}\n\nclass DelayMessage<T> {\n  constructor(public readonly time: number,\n              public readonly notification: Notification<T>) {\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}