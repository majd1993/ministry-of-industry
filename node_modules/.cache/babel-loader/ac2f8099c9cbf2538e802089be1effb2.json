{"ast":null,"code":"import _classCallCheck from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// Multi-device Conversation is a Preview feature.\nimport { ConversationConnectionConfig } from \"../../common.speech/Exports\";\nimport { Contracts } from \"../Contracts\";\nimport { AudioConfig, CancellationErrorCode, CancellationReason, Connection, ProfanityOption, PropertyCollection, PropertyId, SpeechTranslationConfig, TranslationRecognizer } from \"../Exports\";\nimport { ConversationImpl } from \"./Conversation\";\nimport { ConversationTranslationCanceledEventArgs } from \"./Exports\";\nexport var SpeechState;\n\n(function (SpeechState) {\n  SpeechState[SpeechState[\"Inactive\"] = 0] = \"Inactive\";\n  SpeechState[SpeechState[\"Connecting\"] = 1] = \"Connecting\";\n  SpeechState[SpeechState[\"Connected\"] = 2] = \"Connected\";\n})(SpeechState || (SpeechState = {}));\n/***\n * Join, leave or connect to a conversation.\n */\n\n\nexport var ConversationTranslator = /*#__PURE__*/function () {\n  function ConversationTranslator(audioConfig) {\n    var _this = this;\n\n    _classCallCheck(this, ConversationTranslator);\n\n    this.privIsDisposed = false;\n    this.privIsSpeaking = false;\n    this.privSpeechState = SpeechState.Inactive;\n    this.privErrors = ConversationConnectionConfig.restErrors;\n    this.privPlaceholderKey = \"abcdefghijklmnopqrstuvwxyz012345\";\n    this.privPlaceholderRegion = \"westus\";\n    /** Recognizer callbacks */\n\n    this.onSpeechConnected = function (e) {\n      _this.privSpeechState = SpeechState.Connected;\n    };\n\n    this.onSpeechDisconnected = function (e) {\n      _this.privSpeechState = SpeechState.Inactive;\n\n      _this.cancelSpeech();\n    };\n\n    this.onSpeechRecognized = function (r, e) {\n      // TODO: add support for getting recognitions from here if own speech\n      var _a; // if there is an error connecting to the conversation service from the speech service the error will be returned in the ErrorDetails field.\n\n\n      if ((_a = e.result) === null || _a === void 0 ? void 0 : _a.errorDetails) {\n        _this.cancelSpeech(); // TODO: format the error message contained in 'errorDetails'\n\n\n        _this.fireCancelEvent(e.result.errorDetails);\n      }\n    };\n\n    this.onSpeechRecognizing = function (r, e) {// TODO: add support for getting recognitions from here if own speech\n    };\n\n    this.onSpeechCanceled = function (r, e) {\n      if (_this.privSpeechState !== SpeechState.Inactive) {\n        try {\n          _this.cancelSpeech();\n        } catch (error) {\n          _this.privSpeechState = SpeechState.Inactive;\n        }\n      }\n    };\n\n    this.onSpeechSessionStarted = function (r, e) {\n      _this.privSpeechState = SpeechState.Connected;\n    };\n\n    this.onSpeechSessionStopped = function (r, e) {\n      _this.privSpeechState = SpeechState.Inactive;\n    };\n\n    this.privProperties = new PropertyCollection();\n    this.privAudioConfig = audioConfig;\n  }\n\n  _createClass(ConversationTranslator, [{\n    key: \"properties\",\n    get: function get() {\n      return this.privProperties;\n    }\n  }, {\n    key: \"speechRecognitionLanguage\",\n    get: function get() {\n      return this.privSpeechRecognitionLanguage;\n    }\n  }, {\n    key: \"participants\",\n    get: function get() {\n      var _a;\n\n      return (_a = this.privConversation) === null || _a === void 0 ? void 0 : _a.participants;\n    }\n  }, {\n    key: \"joinConversationAsync\",\n    value: function joinConversationAsync(conversation, nickname, param1, param2, param3) {\n      var _this2 = this;\n\n      try {\n        if (typeof conversation === \"string\") {\n          Contracts.throwIfNullOrUndefined(conversation, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversation id\"));\n          Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\n\n          if (!!this.privConversation) {\n            this.handleError(new Error(this.privErrors.permissionDeniedStart), param3);\n          }\n\n          var lang = param1;\n\n          if (lang === undefined || lang === null || lang === \"\") {\n            lang = ConversationConnectionConfig.defaultLanguageCode;\n          } // create a placecholder config\n\n\n          this.privSpeechTranslationConfig = SpeechTranslationConfig.fromSubscription(this.privPlaceholderKey, this.privPlaceholderRegion);\n          this.privSpeechTranslationConfig.setProfanity(ProfanityOption.Masked);\n          this.privSpeechTranslationConfig.addTargetLanguage(lang);\n          this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage], lang);\n          this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.ConversationTranslator_Name], nickname);\n          var endpoint = this.privProperties.getProperty(PropertyId.ConversationTranslator_Host);\n\n          if (endpoint) {\n            this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.ConversationTranslator_Host], endpoint);\n          }\n\n          var speechEndpointHost = this.privProperties.getProperty(PropertyId.SpeechServiceConnection_Host);\n\n          if (speechEndpointHost) {\n            this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_Host], speechEndpointHost);\n          } // join the conversation\n\n\n          this.privConversation = new ConversationImpl(this.privSpeechTranslationConfig);\n          this.privConversation.conversationTranslator = this;\n          this.privConversation.joinConversationAsync(conversation, nickname, lang, function (result) {\n            if (!result) {\n              _this2.handleError(new Error(_this2.privErrors.permissionDeniedConnect), param3);\n            }\n\n            _this2.privSpeechTranslationConfig.authorizationToken = result; // connect to the ws\n\n            _this2.privConversation.startConversationAsync(function () {\n              _this2.handleCallback(param2, param3);\n            }, function (error) {\n              _this2.handleError(error, param3);\n            });\n          }, function (error) {\n            _this2.handleError(error, param3);\n          });\n        } else if (typeof conversation === \"object\") {\n          Contracts.throwIfNullOrUndefined(conversation, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversation id\"));\n          Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\")); // save the nickname\n\n          this.privProperties.setProperty(PropertyId.ConversationTranslator_Name, nickname); // ref the conversation object\n\n          this.privConversation = conversation; // ref the conversation translator object\n\n          this.privConversation.conversationTranslator = this;\n          Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedConnect);\n          Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect);\n          this.privSpeechTranslationConfig = conversation.config;\n          this.handleCallback(param1, param2);\n        } else {\n          this.handleError(new Error(this.privErrors.invalidArgs.replace(\"{arg}\", \"invalid conversation type\")), param2);\n        }\n      } catch (error) {\n        this.handleError(error, typeof param1 === \"string\" ? param3 : param2);\n      }\n    }\n    /**\n     * Leave the conversation\n     * @param cb\n     * @param err\n     */\n\n  }, {\n    key: \"leaveConversationAsync\",\n    value: function leaveConversationAsync(cb, err) {\n      var _this3 = this;\n\n      try {\n        // stop the speech websocket\n        this.cancelSpeech(); // stop the websocket\n\n        this.privConversation.endConversationAsync(function () {\n          // https delete request\n          _this3.privConversation.deleteConversationAsync(function () {\n            _this3.handleCallback(cb, err);\n\n            _this3.dispose();\n          }, function (error) {\n            _this3.handleError(error, err);\n          });\n        }, function (error) {\n          _this3.handleError(error, err);\n        });\n      } catch (error) {\n        this.handleError(error, err);\n      }\n    }\n    /**\n     * Send a text message\n     * @param message\n     * @param cb\n     * @param err\n     */\n\n  }, {\n    key: \"sendTextMessageAsync\",\n    value: function sendTextMessageAsync(message, cb, err) {\n      var _a;\n\n      try {\n        Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend);\n        Contracts.throwIfNullOrWhitespace(message, this.privErrors.invalidArgs.replace(\"{arg}\", message));\n        (_a = this.privConversation) === null || _a === void 0 ? void 0 : _a.sendTextMessageAsync(message, cb, err);\n      } catch (error) {\n        this.handleError(error, err);\n      }\n    }\n    /**\n     * Start speaking\n     * @param cb\n     * @param err\n     */\n\n  }, {\n    key: \"startTranscribingAsync\",\n    value: function startTranscribingAsync(cb, err) {\n      var _this4 = this;\n\n      try {\n        Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend);\n        Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect);\n\n        if (!this.canSpeak) {\n          this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n        }\n\n        if (this.privTranslationRecognizer === undefined) {\n          this.connectTranslatorRecognizer(function () {\n            _this4.startContinuousRecognition(function () {\n              _this4.privIsSpeaking = true;\n\n              _this4.handleCallback(cb, err);\n            }, function (error) {\n              _this4.privIsSpeaking = false; // this.fireCancelEvent(error);\n\n              _this4.cancelSpeech();\n\n              _this4.handleError(error, err);\n            });\n          }, function (error) {\n            _this4.handleError(error, err);\n          });\n        } else {\n          this.startContinuousRecognition(function () {\n            _this4.privIsSpeaking = true;\n\n            _this4.handleCallback(cb, err);\n          }, function (error) {\n            _this4.privIsSpeaking = false; // this.fireCancelEvent(error);\n\n            _this4.cancelSpeech();\n\n            _this4.handleError(error, err);\n          });\n        }\n      } catch (error) {\n        this.handleError(error, err);\n        this.cancelSpeech();\n      }\n    }\n    /**\n     * Stop speaking\n     * @param cb\n     * @param err\n     */\n\n  }, {\n    key: \"stopTranscribingAsync\",\n    value: function stopTranscribingAsync(cb, err) {\n      var _this5 = this;\n\n      var _a;\n\n      try {\n        if (!this.privIsSpeaking) {\n          // stop speech\n          this.cancelSpeech();\n          this.handleCallback(cb, err);\n          return;\n        } // stop the recognition but leave the websocket open\n\n\n        this.privIsSpeaking = false;\n        (_a = this.privTranslationRecognizer) === null || _a === void 0 ? void 0 : _a.stopContinuousRecognitionAsync(function () {\n          _this5.handleCallback(cb, err);\n        }, function (error) {\n          _this5.handleError(error, err);\n\n          _this5.cancelSpeech();\n        });\n      } catch (error) {\n        this.handleError(error, err);\n        this.cancelSpeech();\n      }\n    }\n  }, {\n    key: \"isDisposed\",\n    value: function isDisposed() {\n      return this.privIsDisposed;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose(reason) {\n      var _a, _b;\n\n      if (this.isDisposed && !this.privIsSpeaking) {\n        return;\n      }\n\n      this.cancelSpeech();\n      this.privIsDisposed = true;\n      (_a = this.privSpeechTranslationConfig) === null || _a === void 0 ? void 0 : _a.close();\n      this.privSpeechRecognitionLanguage = undefined;\n      this.privProperties = undefined;\n      this.privAudioConfig = undefined;\n      this.privSpeechTranslationConfig = undefined;\n      (_b = this.privConversation) === null || _b === void 0 ? void 0 : _b.dispose();\n      this.privConversation = undefined;\n    }\n    /**\n     * Connect to the speech translation recognizer.\n     * Currently there is no language validation performed before sending the SpeechLanguage code to the service.\n     * If it's an invalid language the raw error will be: 'Error during WebSocket handshake: Unexpected response code: 400'\n     * e.g. pass in 'fr' instead of 'fr-FR', or a text-only language 'cy'\n     * @param cb\n     * @param err\n     */\n\n  }, {\n    key: \"connectTranslatorRecognizer\",\n    value: function connectTranslatorRecognizer(cb, err) {\n      try {\n        if (this.privAudioConfig === undefined) {\n          this.privAudioConfig = AudioConfig.fromDefaultMicrophoneInput();\n        } // clear the temp subscription key if it's a participant joining\n\n\n        if (this.privSpeechTranslationConfig.getProperty(PropertyId[PropertyId.SpeechServiceConnection_Key]) === this.privPlaceholderKey) {\n          this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_Key], \"\");\n        } // TODO\n\n\n        var token = encodeURIComponent(this.privConversation.room.token);\n        var endpointHost = this.privSpeechTranslationConfig.getProperty(PropertyId[PropertyId.SpeechServiceConnection_Host], ConversationConnectionConfig.speechHost);\n        endpointHost = endpointHost.replace(\"{region}\", this.privConversation.room.cognitiveSpeechRegion);\n        var url = \"wss://\".concat(endpointHost).concat(ConversationConnectionConfig.speechPath, \"?\").concat(ConversationConnectionConfig.configParams.token, \"=\").concat(token);\n        this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_Endpoint], url);\n        this.privTranslationRecognizer = new TranslationRecognizer(this.privSpeechTranslationConfig, this.privAudioConfig);\n        this.privTranslationRecognizerConnection = Connection.fromRecognizer(this.privTranslationRecognizer);\n        this.privTranslationRecognizerConnection.connected = this.onSpeechConnected;\n        this.privTranslationRecognizerConnection.disconnected = this.onSpeechDisconnected;\n        this.privTranslationRecognizer.recognized = this.onSpeechRecognized;\n        this.privTranslationRecognizer.recognizing = this.onSpeechRecognizing;\n        this.privTranslationRecognizer.canceled = this.onSpeechCanceled;\n        this.privTranslationRecognizer.sessionStarted = this.onSpeechSessionStarted;\n        this.privTranslationRecognizer.sessionStopped = this.onSpeechSessionStopped;\n        this.handleCallback(cb, err);\n      } catch (error) {\n        this.handleError(error, err);\n        this.cancelSpeech(); // this.fireCancelEvent(error); ?\n      }\n    }\n    /**\n     * Handle the start speaking request\n     * @param cb\n     * @param err\n     */\n\n  }, {\n    key: \"startContinuousRecognition\",\n    value: function startContinuousRecognition(cb, err) {\n      this.privTranslationRecognizer.startContinuousRecognitionAsync(cb, err);\n    }\n    /**\n     * Fire a cancel event\n     * @param error\n     */\n\n  }, {\n    key: \"fireCancelEvent\",\n    value: function fireCancelEvent(error) {\n      var _a, _b, _c, _d, _e, _f, _g;\n\n      try {\n        if (!!this.canceled) {\n          var cancelEvent = new ConversationTranslationCanceledEventArgs((_b = (_a = error) === null || _a === void 0 ? void 0 : _a.reason, _b !== null && _b !== void 0 ? _b : CancellationReason.Error), (_d = (_c = error) === null || _c === void 0 ? void 0 : _c.errorDetails, _d !== null && _d !== void 0 ? _d : error), (_f = (_e = error) === null || _e === void 0 ? void 0 : _e.errorCode, _f !== null && _f !== void 0 ? _f : CancellationErrorCode.RuntimeError), undefined, (_g = error) === null || _g === void 0 ? void 0 : _g.sessionId);\n          this.canceled(this, cancelEvent);\n        }\n      } catch (e) {//\n      }\n    }\n    /**\n     * Cancel the speech websocket\n     */\n\n  }, {\n    key: \"cancelSpeech\",\n    value: function cancelSpeech() {\n      var _a, _b;\n\n      try {\n        this.privIsSpeaking = false;\n        (_a = this.privTranslationRecognizer) === null || _a === void 0 ? void 0 : _a.stopContinuousRecognitionAsync();\n        (_b = this.privTranslationRecognizerConnection) === null || _b === void 0 ? void 0 : _b.closeConnection();\n        this.privTranslationRecognizerConnection = undefined;\n        this.privTranslationRecognizer = undefined;\n        this.privSpeechState = SpeechState.Inactive;\n      } catch (e) {// ignore the error\n      }\n    }\n  }, {\n    key: \"canSpeak\",\n    get: function get() {\n      // is there a Conversation websocket available\n      if (!this.privConversation.isConnected) {\n        return false;\n      } // is the user already speaking\n\n\n      if (this.privIsSpeaking || this.privSpeechState === SpeechState.Connected || this.privSpeechState === SpeechState.Connecting) {\n        return false;\n      } // is the user muted\n\n\n      if (this.privConversation.isMutedByHost) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"handleCallback\",\n    value: function handleCallback(cb, err) {\n      if (!!cb) {\n        try {\n          cb();\n        } catch (e) {\n          if (!!err) {\n            err(e);\n          }\n        }\n\n        cb = undefined;\n      }\n    }\n  }, {\n    key: \"handleError\",\n    value: function handleError(error, err) {\n      if (!!err) {\n        if (error instanceof Error) {\n          var typedError = error;\n          err(typedError.name + \": \" + typedError.message);\n        } else {\n          err(error);\n        }\n      }\n    }\n  }]);\n\n  return ConversationTranslator;\n}();","map":{"version":3,"sources":["src/sdk/Transcription/ConversationTranslator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n// Multi-device Conversation is a Preview feature.\r\n\r\nimport { ConversationConnectionConfig } from \"../../common.speech/Exports\";\r\nimport { IDisposable, IErrorMessages } from \"../../common/Exports\";\r\nimport { Contracts } from \"../Contracts\";\r\nimport {\r\n    AudioConfig,\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    Connection,\r\n    ConnectionEventArgs,\r\n    ProfanityOption,\r\n    PropertyCollection,\r\n    PropertyId,\r\n    Recognizer,\r\n    SessionEventArgs,\r\n    SpeechTranslationConfig,\r\n    TranslationRecognitionCanceledEventArgs,\r\n    TranslationRecognitionEventArgs,\r\n    TranslationRecognizer\r\n} from \"../Exports\";\r\nimport { ConversationImpl } from \"./Conversation\";\r\nimport {\r\n    ConversationExpirationEventArgs,\r\n    ConversationParticipantsChangedEventArgs,\r\n    ConversationTranslationCanceledEventArgs,\r\n    ConversationTranslationEventArgs,\r\n    Participant,\r\n} from \"./Exports\";\r\nimport { Callback, IConversation } from \"./IConversation\";\r\nimport { IConversationTranslator } from \"./IConversationTranslator\";\r\n\r\nexport enum SpeechState {\r\n    Inactive, Connecting, Connected\r\n}\r\n\r\n/***\r\n * Join, leave or connect to a conversation.\r\n */\r\nexport class ConversationTranslator implements IConversationTranslator, IDisposable {\r\n\r\n    private privSpeechRecognitionLanguage: string;\r\n    private privProperties: PropertyCollection;\r\n    private privAudioConfig: AudioConfig;\r\n    private privSpeechTranslationConfig: SpeechTranslationConfig;\r\n    private privTranslationRecognizerConnection: Connection;\r\n    private privIsDisposed: boolean = false;\r\n    private privTranslationRecognizer: TranslationRecognizer;\r\n    private privIsSpeaking: boolean = false;\r\n    private privConversation: ConversationImpl;\r\n    private privSpeechState: SpeechState = SpeechState.Inactive;\r\n    private privErrors: IErrorMessages = ConversationConnectionConfig.restErrors;\r\n    private privPlaceholderKey: string = \"abcdefghijklmnopqrstuvwxyz012345\";\r\n    private privPlaceholderRegion: string = \"westus\";\r\n\r\n    public constructor(audioConfig?: AudioConfig) {\r\n        this.privProperties = new PropertyCollection();\r\n        this.privAudioConfig = audioConfig;\r\n    }\r\n\r\n    public get properties(): PropertyCollection {\r\n        return this.privProperties;\r\n    }\r\n\r\n    public get speechRecognitionLanguage(): string {\r\n        return this.privSpeechRecognitionLanguage;\r\n    }\r\n\r\n    public get participants(): Participant[] {\r\n        return this.privConversation?.participants;\r\n    }\r\n\r\n    public canceled: (sender: IConversationTranslator, event: ConversationTranslationCanceledEventArgs) => void;\r\n    public conversationExpiration: (sender: IConversationTranslator, event: ConversationExpirationEventArgs) => void;\r\n    public participantsChanged: (sender: IConversationTranslator, event: ConversationParticipantsChangedEventArgs) => void;\r\n    public sessionStarted: (sender: IConversationTranslator, event: SessionEventArgs) => void;\r\n    public sessionStopped: (sender: IConversationTranslator, event: SessionEventArgs) => void;\r\n    public textMessageReceived: (sender: IConversationTranslator, event: ConversationTranslationEventArgs) => void;\r\n    public transcribed: (sender: IConversationTranslator, event: ConversationTranslationEventArgs) => void;\r\n    public transcribing: (sender: IConversationTranslator, event: ConversationTranslationEventArgs) => void;\r\n\r\n    /**\r\n     * Join a conversation. If this is the host, pass in the previously created Conversation object.\r\n     * @param conversation\r\n     * @param nickname\r\n     * @param lang\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public joinConversationAsync(conversation: IConversation, nickname: string, cb?: Callback, err?: Callback): void;\r\n    public joinConversationAsync(conversationId: string, nickname: string, lang: string, cb?: Callback, err?: Callback): void;\r\n    public joinConversationAsync(conversation: any, nickname: string, param1?: string | Callback, param2?: Callback, param3?: Callback): void {\r\n\r\n        try {\r\n\r\n            if (typeof conversation === \"string\") {\r\n\r\n                Contracts.throwIfNullOrUndefined(conversation, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversation id\"));\r\n                Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\r\n\r\n                if (!!this.privConversation) {\r\n                    this.handleError(new Error(this.privErrors.permissionDeniedStart), param3);\r\n                }\r\n\r\n                let lang: string = param1 as string;\r\n                if (lang === undefined || lang === null || lang === \"\") { lang = ConversationConnectionConfig.defaultLanguageCode; }\r\n\r\n                // create a placecholder config\r\n                this.privSpeechTranslationConfig = SpeechTranslationConfig.fromSubscription(\r\n                    this.privPlaceholderKey,\r\n                    this.privPlaceholderRegion);\r\n                this.privSpeechTranslationConfig.setProfanity(ProfanityOption.Masked);\r\n                this.privSpeechTranslationConfig.addTargetLanguage(lang);\r\n                this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage], lang);\r\n                this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.ConversationTranslator_Name], nickname);\r\n\r\n                const endpoint: string = this.privProperties.getProperty(PropertyId.ConversationTranslator_Host);\r\n                if (endpoint) {\r\n                    this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.ConversationTranslator_Host], endpoint);\r\n                }\r\n                const speechEndpointHost: string = this.privProperties.getProperty(PropertyId.SpeechServiceConnection_Host);\r\n                if (speechEndpointHost) {\r\n                    this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_Host], speechEndpointHost);\r\n                }\r\n\r\n                // join the conversation\r\n                this.privConversation = new ConversationImpl(this.privSpeechTranslationConfig);\r\n                this.privConversation.conversationTranslator = this;\r\n\r\n                this.privConversation.joinConversationAsync(\r\n                    conversation,\r\n                    nickname,\r\n                    lang,\r\n                    ((result: string) => {\r\n\r\n                        if (!result) {\r\n                            this.handleError(new Error(this.privErrors.permissionDeniedConnect), param3);\r\n                        }\r\n\r\n                        this.privSpeechTranslationConfig.authorizationToken = result;\r\n\r\n                        // connect to the ws\r\n                        this.privConversation.startConversationAsync(\r\n                            (() => {\r\n                                this.handleCallback(param2, param3);\r\n                            }),\r\n                            ((error: any) => {\r\n                                this.handleError(error, param3);\r\n                            }));\r\n\r\n                    }),\r\n                    ((error: any) => {\r\n                        this.handleError(error, param3);\r\n                    }));\r\n\r\n            } else if (typeof conversation === \"object\") {\r\n\r\n                Contracts.throwIfNullOrUndefined(conversation, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversation id\"));\r\n                Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\r\n\r\n                // save the nickname\r\n                this.privProperties.setProperty(PropertyId.ConversationTranslator_Name, nickname);\r\n                // ref the conversation object\r\n                this.privConversation = conversation as ConversationImpl;\r\n                // ref the conversation translator object\r\n                this.privConversation.conversationTranslator = this;\r\n\r\n                Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedConnect);\r\n                Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect);\r\n\r\n                this.privSpeechTranslationConfig = conversation.config;\r\n\r\n                this.handleCallback(param1 as Callback, param2);\r\n            } else {\r\n                this.handleError(\r\n                    new Error(this.privErrors.invalidArgs.replace(\"{arg}\", \"invalid conversation type\")),\r\n                    param2);\r\n            }\r\n\r\n        } catch (error) {\r\n            this.handleError(error, typeof param1 === \"string\" ? param3 : param2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Leave the conversation\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public leaveConversationAsync(cb?: Callback, err?: Callback): void {\r\n\r\n        try {\r\n\r\n            // stop the speech websocket\r\n            this.cancelSpeech();\r\n\r\n            // stop the websocket\r\n            this.privConversation.endConversationAsync(\r\n                (() => {\r\n                    // https delete request\r\n                    this.privConversation.deleteConversationAsync(\r\n                        (() => {\r\n                            this.handleCallback(cb, err);\r\n                            this.dispose();\r\n                        }),\r\n                        ((error: any) => {\r\n                            this.handleError(error, err);\r\n                        }));\r\n                }),\r\n                ((error: any) => {\r\n                    this.handleError(error, err);\r\n                }));\r\n\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send a text message\r\n     * @param message\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public sendTextMessageAsync(message: string, cb?: Callback, err?: Callback): void {\r\n\r\n        try {\r\n            Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend);\r\n            Contracts.throwIfNullOrWhitespace(message, this.privErrors.invalidArgs.replace(\"{arg}\", message));\r\n\r\n            this.privConversation?.sendTextMessageAsync(message, cb, err);\r\n        } catch (error) {\r\n\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Start speaking\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public startTranscribingAsync(cb?: Callback, err?: Callback): void {\r\n\r\n        try {\r\n            Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend);\r\n            Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect);\r\n\r\n            if (!this.canSpeak) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\r\n            }\r\n\r\n            if (this.privTranslationRecognizer === undefined) {\r\n                this.connectTranslatorRecognizer(\r\n                    (() => {\r\n                        this.startContinuousRecognition(\r\n                            (() => {\r\n                                this.privIsSpeaking = true;\r\n                                this.handleCallback(cb, err);\r\n                            }),\r\n                            ((error: any) => {\r\n\r\n                                this.privIsSpeaking = false;\r\n                                // this.fireCancelEvent(error);\r\n                                this.cancelSpeech();\r\n                                this.handleError(error, err);\r\n                            }));\r\n                    }),\r\n                    ((error: any) => {\r\n                        this.handleError(error, err);\r\n                    }));\r\n            } else {\r\n                this.startContinuousRecognition(\r\n                    (() => {\r\n                        this.privIsSpeaking = true;\r\n                        this.handleCallback(cb, err);\r\n                    }),\r\n                    ((error: any) => {\r\n                        this.privIsSpeaking = false;\r\n                        // this.fireCancelEvent(error);\r\n                        this.cancelSpeech();\r\n\r\n                        this.handleError(error, err);\r\n                    }));\r\n            }\r\n\r\n        } catch (error) {\r\n\r\n            this.handleError(error, err);\r\n\r\n            this.cancelSpeech();\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stop speaking\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public stopTranscribingAsync(cb?: Callback, err?: Callback): void {\r\n\r\n        try {\r\n            if (!this.privIsSpeaking) {\r\n                // stop speech\r\n                this.cancelSpeech();\r\n                this.handleCallback(cb, err);\r\n                return;\r\n            }\r\n\r\n            // stop the recognition but leave the websocket open\r\n            this.privIsSpeaking = false;\r\n            this.privTranslationRecognizer?.stopContinuousRecognitionAsync(() => {\r\n                this.handleCallback(cb, err);\r\n            }, (error: any) => {\r\n                this.handleError(error, err);\r\n                this.cancelSpeech();\r\n            });\r\n\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n            this.cancelSpeech();\r\n        }\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return this.privIsDisposed;\r\n    }\r\n\r\n    public dispose(reason?: string): void {\r\n        if (this.isDisposed && !this.privIsSpeaking) {\r\n            return;\r\n        }\r\n        this.cancelSpeech();\r\n        this.privIsDisposed = true;\r\n        this.privSpeechTranslationConfig?.close();\r\n        this.privSpeechRecognitionLanguage = undefined;\r\n        this.privProperties = undefined;\r\n        this.privAudioConfig = undefined;\r\n        this.privSpeechTranslationConfig = undefined;\r\n        this.privConversation?.dispose();\r\n        this.privConversation = undefined;\r\n    }\r\n\r\n    /**\r\n     * Connect to the speech translation recognizer.\r\n     * Currently there is no language validation performed before sending the SpeechLanguage code to the service.\r\n     * If it's an invalid language the raw error will be: 'Error during WebSocket handshake: Unexpected response code: 400'\r\n     * e.g. pass in 'fr' instead of 'fr-FR', or a text-only language 'cy'\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    private connectTranslatorRecognizer(cb?: Callback, err?: Callback): void {\r\n\r\n        try {\r\n\r\n            if (this.privAudioConfig === undefined) {\r\n                this.privAudioConfig = AudioConfig.fromDefaultMicrophoneInput();\r\n            }\r\n\r\n            // clear the temp subscription key if it's a participant joining\r\n            if (this.privSpeechTranslationConfig.getProperty(PropertyId[PropertyId.SpeechServiceConnection_Key])\r\n                === this.privPlaceholderKey) {\r\n                this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_Key], \"\");\r\n            }\r\n\r\n            // TODO\r\n            const token: string = encodeURIComponent(this.privConversation.room.token);\r\n\r\n            let endpointHost: string = this.privSpeechTranslationConfig.getProperty(\r\n                PropertyId[PropertyId.SpeechServiceConnection_Host], ConversationConnectionConfig.speechHost);\r\n            endpointHost = endpointHost.replace(\"{region}\", this.privConversation.room.cognitiveSpeechRegion);\r\n\r\n            const url: string = `wss://${endpointHost}${ConversationConnectionConfig.speechPath}?${ConversationConnectionConfig.configParams.token}=${token}`;\r\n\r\n            this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_Endpoint], url);\r\n\r\n            this.privTranslationRecognizer = new TranslationRecognizer(this.privSpeechTranslationConfig, this.privAudioConfig);\r\n            this.privTranslationRecognizerConnection = Connection.fromRecognizer(this.privTranslationRecognizer);\r\n            this.privTranslationRecognizerConnection.connected = this.onSpeechConnected;\r\n            this.privTranslationRecognizerConnection.disconnected = this.onSpeechDisconnected;\r\n            this.privTranslationRecognizer.recognized = this.onSpeechRecognized;\r\n            this.privTranslationRecognizer.recognizing = this.onSpeechRecognizing;\r\n            this.privTranslationRecognizer.canceled = this.onSpeechCanceled;\r\n            this.privTranslationRecognizer.sessionStarted = this.onSpeechSessionStarted;\r\n            this.privTranslationRecognizer.sessionStopped = this.onSpeechSessionStopped;\r\n\r\n            this.handleCallback(cb, err);\r\n\r\n        } catch (error) {\r\n\r\n            this.handleError(error, err);\r\n\r\n            this.cancelSpeech();\r\n            // this.fireCancelEvent(error); ?\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle the start speaking request\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    private startContinuousRecognition(cb?: Callback, err?: Callback): void {\r\n        this.privTranslationRecognizer.startContinuousRecognitionAsync(cb, err);\r\n    }\r\n\r\n    /** Recognizer callbacks */\r\n    private onSpeechConnected = (e: ConnectionEventArgs) => {\r\n        this.privSpeechState = SpeechState.Connected;\r\n    }\r\n\r\n    private onSpeechDisconnected = (e: ConnectionEventArgs) => {\r\n        this.privSpeechState = SpeechState.Inactive;\r\n        this.cancelSpeech();\r\n    }\r\n\r\n    private onSpeechRecognized = (r: TranslationRecognizer, e: TranslationRecognitionEventArgs) => {\r\n        // TODO: add support for getting recognitions from here if own speech\r\n\r\n        // if there is an error connecting to the conversation service from the speech service the error will be returned in the ErrorDetails field.\r\n        if (e.result?.errorDetails) {\r\n            this.cancelSpeech();\r\n            // TODO: format the error message contained in 'errorDetails'\r\n            this.fireCancelEvent(e.result.errorDetails);\r\n        }\r\n    }\r\n\r\n    private onSpeechRecognizing = (r: TranslationRecognizer, e: TranslationRecognitionEventArgs) => {\r\n        // TODO: add support for getting recognitions from here if own speech\r\n    }\r\n\r\n    private onSpeechCanceled = (r: TranslationRecognizer, e: TranslationRecognitionCanceledEventArgs) => {\r\n        if (this.privSpeechState !== SpeechState.Inactive) {\r\n            try {\r\n                this.cancelSpeech();\r\n            } catch (error) {\r\n                this.privSpeechState = SpeechState.Inactive;\r\n            }\r\n        }\r\n    }\r\n\r\n    private onSpeechSessionStarted = (r: Recognizer, e: SessionEventArgs) => {\r\n        this.privSpeechState = SpeechState.Connected;\r\n\r\n    }\r\n\r\n    private onSpeechSessionStopped = (r: Recognizer, e: SessionEventArgs) => {\r\n        this.privSpeechState = SpeechState.Inactive;\r\n    }\r\n\r\n    /**\r\n     * Fire a cancel event\r\n     * @param error\r\n     */\r\n    private fireCancelEvent(error: any): void {\r\n        try {\r\n            if (!!this.canceled) {\r\n                const cancelEvent: ConversationTranslationCanceledEventArgs = new ConversationTranslationCanceledEventArgs(\r\n                    error?.reason ?? CancellationReason.Error,\r\n                    error?.errorDetails ?? error,\r\n                    error?.errorCode ?? CancellationErrorCode.RuntimeError,\r\n                    undefined,\r\n                    error?.sessionId);\r\n\r\n                this.canceled(this, cancelEvent);\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Cancel the speech websocket\r\n     */\r\n    private cancelSpeech(): void {\r\n        try {\r\n            this.privIsSpeaking = false;\r\n            this.privTranslationRecognizer?.stopContinuousRecognitionAsync();\r\n            this.privTranslationRecognizerConnection?.closeConnection();\r\n            this.privTranslationRecognizerConnection = undefined;\r\n            this.privTranslationRecognizer = undefined;\r\n            this.privSpeechState = SpeechState.Inactive;\r\n        } catch (e) {\r\n            // ignore the error\r\n        }\r\n    }\r\n\r\n    private get canSpeak(): boolean {\r\n\r\n        // is there a Conversation websocket available\r\n        if (!this.privConversation.isConnected) {\r\n            return false;\r\n        }\r\n\r\n        // is the user already speaking\r\n        if (this.privIsSpeaking || this.privSpeechState === SpeechState.Connected || this.privSpeechState === SpeechState.Connecting) {\r\n            return false;\r\n        }\r\n\r\n        // is the user muted\r\n        if (this.privConversation.isMutedByHost) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private handleCallback(cb: Callback, err: Callback): void {\r\n        if (!!cb) {\r\n            try {\r\n                cb();\r\n            } catch (e) {\r\n                if (!!err) {\r\n                    err(e);\r\n                }\r\n            }\r\n            cb = undefined;\r\n        }\r\n    }\r\n\r\n    private handleError(error: any, err: Callback): void {\r\n        if (!!err) {\r\n            if (error instanceof Error) {\r\n                const typedError: Error = error as Error;\r\n                err(typedError.name + \": \" + typedError.message);\r\n\r\n            } else {\r\n                err(error);\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}