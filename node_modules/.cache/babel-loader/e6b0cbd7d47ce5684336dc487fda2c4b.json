{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _botframeworkWebchatComponent = require(\"botframework-webchat-component\");\n\nvar _classnames = _interopRequireDefault(require(\"classnames\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _useAdaptiveCardsHostConfig = _interopRequireDefault(require(\"../hooks/useAdaptiveCardsHostConfig\"));\n\nvar _useAdaptiveCardsPackage = _interopRequireDefault(require(\"../hooks/useAdaptiveCardsPackage\"));\n/* eslint no-magic-numbers: [\"error\", { \"ignore\": [-1, 0, 2] }] */\n\n\nvar ErrorBox = _botframeworkWebchatComponent.Components.ErrorBox;\nvar useDisabled = _botframeworkWebchatComponent.hooks.useDisabled,\n    useLocalizer = _botframeworkWebchatComponent.hooks.useLocalizer,\n    usePerformCardAction = _botframeworkWebchatComponent.hooks.usePerformCardAction,\n    useRenderMarkdownAsHTML = _botframeworkWebchatComponent.hooks.useRenderMarkdownAsHTML,\n    useScrollToEnd = _botframeworkWebchatComponent.hooks.useScrollToEnd,\n    useStyleSet = _botframeworkWebchatComponent.hooks.useStyleSet;\nvar node_env = process.env.node_env || process.env.NODE_ENV;\n\nfunction addClass(element, className) {\n  var classNames = new Set(element.className.split(' '));\n\n  if (!classNames.has(className)) {\n    classNames.add(className);\n    element.className = Array.from(classNames).join(' ');\n    return true;\n  }\n\n  return false;\n}\n\nfunction addPersistentClassWithUndo(element, className) {\n  if (addClass(element, className)) {\n    // After we add the class, keep observing the element to make sure the class is not removed.\n    var observer = new MutationObserver(function () {\n      return addClass(element, className);\n    });\n    observer.observe(element, {\n      attributes: true,\n      attributeFilter: ['class']\n    });\n    return function () {\n      var classNames = new Set(element.className.split(' '));\n      classNames.delete(className);\n      element.className = Array.from(classNames).join(' ');\n      observer.disconnect();\n    };\n  }\n}\n\nfunction isPlainObject(obj) {\n  return Object.getPrototypeOf(obj) === Object.prototype;\n}\n\nfunction setAttributeWithUndo(element, qualifiedName, nextValue) {\n  var value = element.getAttribute(qualifiedName);\n\n  if (value !== nextValue) {\n    element.setAttribute(qualifiedName, nextValue);\n    return function () {\n      return value ? element.setAttribute(qualifiedName, value) : element.removeAttribute(qualifiedName);\n    };\n  }\n}\n\nvar disabledHandler = function disabledHandler(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n  event.stopPropagation();\n};\n\nfunction addEventListenerOnceWithUndo(element, name, handler) {\n  /* eslint-disable-next-line prefer-const */\n  var detach;\n\n  var detachingHandler = function detachingHandler(event) {\n    try {\n      handler(event);\n    } finally {\n      // IE11 does not support { once: true }, so we need to detach manually.\n      detach();\n    }\n  };\n\n  detach = function detach() {\n    return element.removeEventListener(name, detachingHandler);\n  };\n\n  element.addEventListener(name, detachingHandler, {\n    once: true\n  });\n  return detach;\n}\n\nfunction disableElementWithUndo(element) {\n  var undoStack = [];\n  var isActive = element === document.activeElement;\n  var tag = element.nodeName.toLowerCase();\n  /* eslint-disable-next-line default-case */\n\n  switch (tag) {\n    // Should we not disable <a>? Will some of the <a> are styled as button?\n    case 'a':\n      undoStack.push(addEventListenerOnceWithUndo(element, 'click', disabledHandler));\n      break;\n\n    case 'button':\n    case 'input':\n    case 'select':\n    case 'textarea':\n      undoStack.push(setAttributeWithUndo(element, 'aria-disabled', 'true'));\n\n      if (isActive) {\n        undoStack.push(addEventListenerOnceWithUndo(element, 'blur', function () {\n          return undoStack.push(setAttributeWithUndo(element, 'disabled', 'disabled'));\n        }));\n      } else {\n        undoStack.push(setAttributeWithUndo(element, 'disabled', 'disabled'));\n      }\n\n      if (tag === 'input' || tag === 'textarea') {\n        undoStack.push(addEventListenerOnceWithUndo(element, 'click', disabledHandler));\n        undoStack.push(setAttributeWithUndo(element, 'readonly', 'readonly'));\n      } else if (tag === 'select') {\n        undoStack.push.apply(undoStack, (0, _toConsumableArray2.default)([].map.call(element.querySelectorAll('option'), function (option) {\n          return setAttributeWithUndo(option, 'disabled', 'disabled');\n        })));\n      }\n\n      break;\n  }\n\n  return function () {\n    return undoStack.forEach(function (undo) {\n      return undo && undo();\n    });\n  };\n}\n\nfunction disableInputElementsWithUndo(element) {\n  var observeSubtree = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var undoStack = [].map.call(element.querySelectorAll('a, button, input, select, textarea'), function (element) {\n    return disableElementWithUndo(element);\n  });\n  var tag = element.nodeName.toLowerCase(); // Only set tabindex=\"-1\" on focusable element. Otherwise, we will make <div> focusable by mouse.\n\n  (tag === 'a' || tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea') && undoStack.push(setAttributeWithUndo(element, 'tabindex', '-1'));\n\n  if (observeSubtree) {\n    var observer = new MutationObserver(function (mutations) {\n      return mutations.forEach(function (_ref) {\n        var addedNodes = _ref.addedNodes;\n        return undoStack.push.apply(undoStack, (0, _toConsumableArray2.default)(addedNodes.map(function (addedNode) {\n          return disableInputElementsWithUndo(addedNode, false);\n        })));\n      });\n    });\n    observer.observe(element, {\n      childList: true,\n      subtree: true\n    });\n    undoStack.push(function () {\n      return observer.disconnect();\n    });\n  }\n\n  return function () {\n    return undoStack.forEach(function (undo) {\n      return undo && undo();\n    });\n  };\n}\n\nfunction getFocusableElements(element) {\n  return [].filter.call(element.querySelectorAll(['a', 'body', 'button', 'frame', 'iframe', 'img', 'input', 'isindex', 'object', 'select', 'textarea', '[tabindex]'].join(', ')), function (element) {\n    var tabIndex = (0, _botframeworkWebchatComponent.getTabIndex)(element);\n    return typeof tabIndex === 'number' && tabIndex >= 0;\n  });\n}\n\nfunction restoreActiveElementIndex(element, activeElementIndex) {\n  var focusable = getFocusableElements(element)[activeElementIndex];\n  focusable && focusable.focus();\n}\n\nfunction saveActiveElementIndex(element) {\n  return getFocusableElements(element).indexOf(document.activeElement);\n}\n\nfunction restoreInputValues(element, inputValues) {\n  var inputs = element.querySelectorAll('input, select, textarea');\n  [].forEach.call(inputs, function (input, index) {\n    var value = inputValues[index];\n\n    if (typeof value !== 'undefined') {\n      var tagName = input.tagName,\n          type = input.type;\n\n      if (tagName === 'INPUT' && (type === 'checkbox' || type === 'radio')) {\n        input.checked = value;\n      } else {\n        input.value = value;\n      }\n    }\n  });\n}\n\nfunction saveInputValues(element) {\n  var inputs = element.querySelectorAll('input, select, textarea');\n  return [].map.call(inputs, function (_ref2) {\n    var checked = _ref2.checked,\n        tagName = _ref2.tagName,\n        type = _ref2.type,\n        value = _ref2.value;\n\n    if (tagName === 'INPUT' && (type === 'checkbox' || type === 'radio')) {\n      return checked;\n    }\n\n    return value;\n  });\n}\n\nvar AdaptiveCardRenderer = function AdaptiveCardRenderer(_ref3) {\n  var actionPerformedClassName = _ref3.actionPerformedClassName,\n      adaptiveCard = _ref3.adaptiveCard,\n      disabledFromProps = _ref3.disabled,\n      tapAction = _ref3.tapAction;\n\n  var _useStyleSet = useStyleSet(),\n      _useStyleSet2 = (0, _slicedToArray2.default)(_useStyleSet, 1),\n      adaptiveCardRendererStyleSet = _useStyleSet2[0].adaptiveCardRenderer;\n\n  var _useAdaptiveCardsPack = (0, _useAdaptiveCardsPackage.default)(),\n      _useAdaptiveCardsPack2 = (0, _slicedToArray2.default)(_useAdaptiveCardsPack, 1),\n      _useAdaptiveCardsPack3 = _useAdaptiveCardsPack2[0],\n      GlobalSettings = _useAdaptiveCardsPack3.GlobalSettings,\n      HostConfig = _useAdaptiveCardsPack3.HostConfig;\n\n  var _useState = (0, _react.useState)([]),\n      _useState2 = (0, _slicedToArray2.default)(_useState, 2),\n      actionsPerformed = _useState2[0],\n      setActionsPerformed = _useState2[1];\n\n  var _useAdaptiveCardsHost = (0, _useAdaptiveCardsHostConfig.default)(),\n      _useAdaptiveCardsHost2 = (0, _slicedToArray2.default)(_useAdaptiveCardsHost, 1),\n      adaptiveCardsHostConfig = _useAdaptiveCardsHost2[0];\n\n  var _useDisabled = useDisabled(),\n      _useDisabled2 = (0, _slicedToArray2.default)(_useDisabled, 1),\n      disabledFromComposer = _useDisabled2[0];\n\n  var _useState3 = (0, _react.useState)([]),\n      _useState4 = (0, _slicedToArray2.default)(_useState3, 2),\n      errors = _useState4[0],\n      setErrors = _useState4[1];\n\n  var _useState5 = (0, _react.useState)(0),\n      _useState6 = (0, _slicedToArray2.default)(_useState5, 2),\n      lastRender = _useState6[0],\n      setLastRender = _useState6[1];\n\n  var activeElementIndexRef = (0, _react.useRef)(-1);\n  var adaptiveCardElementRef = (0, _react.useRef)();\n  var contentRef = (0, _react.useRef)();\n  var inputValuesRef = (0, _react.useRef)([]);\n  var localize = useLocalizer();\n  var performCardAction = usePerformCardAction();\n  var renderMarkdownAsHTML = useRenderMarkdownAsHTML();\n  var scrollToEnd = useScrollToEnd();\n  var disabled = disabledFromComposer || disabledFromProps; // TODO: [P2] #3199 We should consider using `adaptiveCard.selectAction` instead.\n  // The null check for \"tapAction\" is in \"handleClickAndKeyPressForTapAction\".\n\n  var handleClickAndKeyPress = (0, _react.useCallback)(function (event) {\n    var key = event.key,\n        target = event.target,\n        type = event.type; // Some items, e.g. tappable text, cannot be disabled thru DOM attributes\n\n    var current = contentRef.current;\n    var adaptiveCardRoot = current.querySelector('.ac-adaptiveCard[tabindex=\"0\"]');\n\n    if (!adaptiveCardRoot) {\n      return console.warn('botframework-webchat: No Adaptive Card root container can be found, probably on an unsupported Adaptive Card version.');\n    } // For \"keypress\" event, we only listen to ENTER and SPACEBAR key.\n\n\n    if (type === 'keypress') {\n      if (key !== 'Enter' && key !== ' ') {\n        return;\n      }\n\n      event.preventDefault();\n    } // We will call performCardAction if either:\n    // 1. We are on the target, or\n    // 2. The event-dispatching element is not interactive\n\n\n    if (target !== adaptiveCardRoot) {\n      var tabIndex = (0, _botframeworkWebchatComponent.getTabIndex)(target); // If the user is clicking on something that is already clickable, do not allow them to click the card.\n      // E.g. a hero card can be tappable, and image and buttons inside the hero card can also be tappable.\n\n      if (typeof tabIndex === 'number' && tabIndex >= 0) {\n        return;\n      }\n    }\n\n    performCardAction(tapAction);\n    scrollToEnd();\n  }, [contentRef, performCardAction, scrollToEnd, tapAction]); // Only listen to event if it is not disabled and have \"tapAction\" prop.\n\n  var handleClickAndKeyPressForTapAction = !disabled && tapAction ? handleClickAndKeyPress : undefined;\n  var addActionsPerformed = (0, _react.useCallback)(function (action) {\n    return !~actionsPerformed.indexOf(action) && setActionsPerformed([].concat((0, _toConsumableArray2.default)(actionsPerformed), [action]));\n  }, [actionsPerformed, setActionsPerformed]);\n  var handleExecuteAction = (0, _react.useCallback)(function (action) {\n    // Some items, e.g. tappable image, cannot be disabled thru DOM attributes\n    if (disabled) {\n      return;\n    }\n\n    addActionsPerformed(action);\n    var actionTypeName = action.getJsonTypeName();\n\n    if (actionTypeName === 'Action.OpenUrl') {\n      performCardAction({\n        type: 'openUrl',\n        value: action.url\n      });\n    } else if (actionTypeName === 'Action.Submit') {\n      if (typeof action.data !== 'undefined') {\n        var actionData = action.data;\n\n        if (actionData && actionData.__isBotFrameworkCardAction) {\n          var cardAction = actionData.cardAction;\n          var displayText = cardAction.displayText,\n              text = cardAction.text,\n              type = cardAction.type,\n              value = cardAction.value;\n          performCardAction({\n            displayText: displayText,\n            text: text,\n            type: type,\n            value: value\n          });\n        } else {\n          performCardAction({\n            type: typeof action.data === 'string' ? 'imBack' : 'postBack',\n            value: action.data\n          });\n        }\n      }\n\n      scrollToEnd();\n    } else {\n      console.error(\"Web Chat: received unknown action from Adaptive Cards\");\n      console.error(action);\n    }\n  }, [addActionsPerformed, disabled, performCardAction, scrollToEnd]);\n  (0, _react.useLayoutEffect)(function () {\n    var current = contentRef.current;\n\n    if (!current || !adaptiveCard) {\n      activeElementIndexRef.current = -1;\n      inputValuesRef.current = [];\n    } // Currently, the only way to set the Markdown engine is to set it thru static member of AdaptiveCard class\n    // TODO: [P3] Checks if we could make the \"renderMarkdownAsHTML\" per card\n    //       This could be limitations from Adaptive Cards package (not supported as of 1.2.5)\n    //       Because there could be timing difference between .parse and .render, we could be using wrong Markdown engine\n\n\n    adaptiveCard.constructor.onProcessMarkdown = function (text, result) {\n      if (renderMarkdownAsHTML) {\n        result.outputHtml = renderMarkdownAsHTML(text);\n        result.didProcess = true;\n      }\n    };\n\n    if (adaptiveCardsHostConfig) {\n      adaptiveCard.hostConfig = isPlainObject(adaptiveCardsHostConfig) ? new HostConfig(adaptiveCardsHostConfig) : adaptiveCardsHostConfig;\n    } // For accessibility issue #1340, `tabindex=\"0\"` must not be set for the root container if it is not interactive.\n\n\n    GlobalSettings.setTabIndexAtCardRoot = !!tapAction;\n\n    var _adaptiveCard$validat = adaptiveCard.validateProperties(),\n        failures = _adaptiveCard$validat.failures;\n\n    if (failures.length) {\n      return setErrors(failures.reduce(function (items, _ref4) {\n        var errors = _ref4.errors;\n        return [].concat((0, _toConsumableArray2.default)(items), (0, _toConsumableArray2.default)(errors.map(function (_ref5) {\n          var message = _ref5.message;\n          return new Error(message);\n        })));\n      }, []));\n    }\n\n    var element;\n\n    try {\n      element = adaptiveCard.render();\n    } catch (error) {\n      return setErrors([error]);\n    }\n\n    if (!element) {\n      return setErrors([new Error('Adaptive Card rendered as empty element')]);\n    } // Clear errors on next render\n\n\n    setErrors([]);\n    restoreInputValues(element, inputValuesRef.current);\n    current.appendChild(element);\n    adaptiveCardElementRef.current = element; // Focus can only be restored after the DOM is attached.\n\n    restoreActiveElementIndex(element, activeElementIndexRef.current);\n    setLastRender(Date.now());\n    return function () {\n      activeElementIndexRef.current = saveActiveElementIndex(element);\n      inputValuesRef.current = saveInputValues(element);\n      current.removeChild(adaptiveCardElementRef.current);\n      adaptiveCardElementRef.current = undefined;\n    };\n  }, [adaptiveCard, adaptiveCardsHostConfig, contentRef, GlobalSettings, HostConfig, renderMarkdownAsHTML, setErrors, tapAction]);\n  (0, _react.useEffect)(function () {\n    // Set onExecuteAction without causing unnecessary re-render.\n    adaptiveCard.onExecuteAction = disabled ? undefined : handleExecuteAction;\n  }, [adaptiveCard, disabled, handleExecuteAction]);\n  (0, _react.useEffect)(function () {\n    // If the Adaptive Card get re-rendered, re-disable elements as needed.\n    if (disabled) {\n      return disableInputElementsWithUndo(adaptiveCardElementRef.current);\n    }\n  }, [disabled, lastRender]);\n  (0, _react.useEffect)(function () {\n    // If the Adaptive Card changed, reset all actions performed.\n    setActionsPerformed([]);\n  }, [adaptiveCard]);\n  (0, _react.useEffect)(function () {\n    // Add developers to highlight actions when they have been clicked.\n    if (!actionPerformedClassName) {\n      return;\n    }\n\n    var undoStack = actionsPerformed.map(function (_ref6) {\n      var renderedElement = _ref6.renderedElement;\n      return renderedElement && adaptiveCardElementRef.current.contains(renderedElement) && addPersistentClassWithUndo(renderedElement, actionPerformedClassName);\n    });\n    return function () {\n      return undoStack.forEach(function (undo) {\n        return undo && undo();\n      });\n    };\n  }, [actionsPerformed, actionPerformedClassName, lastRender]);\n  return errors.length ? node_env === 'development' ? /*#__PURE__*/_react.default.createElement(ErrorBox, {\n    error: errors[0],\n    type: localize('ADAPTIVE_CARD_ERROR_BOX_TITLE_RENDER')\n  }) : false : /*#__PURE__*/_react.default.createElement(\"div\", {\n    className: (0, _classnames.default)(adaptiveCardRendererStyleSet + '', 'webchat__adaptive-card-renderer'),\n    onClick: handleClickAndKeyPressForTapAction,\n    onKeyPress: handleClickAndKeyPressForTapAction,\n    ref: contentRef\n  });\n};\n\nAdaptiveCardRenderer.defaultProps = {\n  actionPerformedClassName: '',\n  disabled: undefined,\n  tapAction: undefined\n};\nAdaptiveCardRenderer.propTypes = {\n  actionPerformedClassName: _propTypes.default.string,\n  adaptiveCard: _propTypes.default.any.isRequired,\n  disabled: _propTypes.default.bool,\n  tapAction: _propTypes.default.shape({\n    type: _propTypes.default.string.isRequired,\n    value: _propTypes.default.string\n  })\n};\nvar _default = AdaptiveCardRenderer;\nexports.default = _default;","map":{"version":3,"sources":["../../../src/adaptiveCards/Attachment/AdaptiveCardRenderer.js"],"names":["ErrorBox","Components","useDisabled","useLocalizer","usePerformCardAction","useRenderMarkdownAsHTML","useScrollToEnd","useStyleSet","hooks","node_env","process","classNames","element","Array","addClass","observer","attributes","attributeFilter","Object","value","disabledHandler","event","detachingHandler","handler","detach","once","undoStack","isActive","document","tag","addEventListenerOnceWithUndo","setAttributeWithUndo","undo","observeSubtree","disableElementWithUndo","addedNodes","disableInputElementsWithUndo","childList","subtree","tabIndex","focusable","getFocusableElements","inputs","inputValues","tagName","type","input","checked","AdaptiveCardRenderer","actionPerformedClassName","adaptiveCard","disabled","disabledFromProps","tapAction","adaptiveCardRendererStyleSet","GlobalSettings","HostConfig","actionsPerformed","setActionsPerformed","adaptiveCardsHostConfig","disabledFromComposer","errors","setErrors","lastRender","setLastRender","activeElementIndexRef","adaptiveCardElementRef","contentRef","inputValuesRef","localize","performCardAction","renderMarkdownAsHTML","scrollToEnd","handleClickAndKeyPress","key","target","current","adaptiveCardRoot","console","handleClickAndKeyPressForTapAction","addActionsPerformed","handleExecuteAction","actionTypeName","action","url","actionData","cardAction","displayText","text","data","result","isPlainObject","failures","message","restoreInputValues","restoreActiveElementIndex","Date","saveActiveElementIndex","saveInputValues","renderedElement","addPersistentClassWithUndo","undefined","PropTypes","string"],"mappings":"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","sourcesContent":["/* eslint no-magic-numbers: [\"error\", { \"ignore\": [-1, 0, 2] }] */\n\nimport { Components, getTabIndex, hooks } from 'botframework-webchat-component';\nimport classNames from 'classnames';\nimport PropTypes from 'prop-types';\nimport React, { useCallback, useEffect, useLayoutEffect, useRef, useState } from 'react';\n\nimport useAdaptiveCardsHostConfig from '../hooks/useAdaptiveCardsHostConfig';\nimport useAdaptiveCardsPackage from '../hooks/useAdaptiveCardsPackage';\n\nconst { ErrorBox } = Components;\nconst { useDisabled, useLocalizer, usePerformCardAction, useRenderMarkdownAsHTML, useScrollToEnd, useStyleSet } = hooks;\n\nconst node_env = process.env.node_env || process.env.NODE_ENV;\n\nfunction addClass(element, className) {\n  const classNames = new Set(element.className.split(' '));\n\n  if (!classNames.has(className)) {\n    classNames.add(className);\n\n    element.className = Array.from(classNames).join(' ');\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction addPersistentClassWithUndo(element, className) {\n  if (addClass(element, className)) {\n    // After we add the class, keep observing the element to make sure the class is not removed.\n    const observer = new MutationObserver(() => addClass(element, className));\n\n    observer.observe(element, { attributes: true, attributeFilter: ['class'] });\n\n    return () => {\n      const classNames = new Set(element.className.split(' '));\n\n      classNames.delete(className);\n\n      element.className = Array.from(classNames).join(' ');\n      observer.disconnect();\n    };\n  }\n}\n\nfunction isPlainObject(obj) {\n  return Object.getPrototypeOf(obj) === Object.prototype;\n}\n\nfunction setAttributeWithUndo(element, qualifiedName, nextValue) {\n  const value = element.getAttribute(qualifiedName);\n\n  if (value !== nextValue) {\n    element.setAttribute(qualifiedName, nextValue);\n\n    return () => (value ? element.setAttribute(qualifiedName, value) : element.removeAttribute(qualifiedName));\n  }\n}\n\nconst disabledHandler = event => {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n  event.stopPropagation();\n};\n\nfunction addEventListenerOnceWithUndo(element, name, handler) {\n  /* eslint-disable-next-line prefer-const */\n  let detach;\n  const detachingHandler = event => {\n    try {\n      handler(event);\n    } finally {\n      // IE11 does not support { once: true }, so we need to detach manually.\n      detach();\n    }\n  };\n\n  detach = () => element.removeEventListener(name, detachingHandler);\n\n  element.addEventListener(name, detachingHandler, { once: true });\n\n  return detach;\n}\n\nfunction disableElementWithUndo(element) {\n  const undoStack = [];\n  const isActive = element === document.activeElement;\n  const tag = element.nodeName.toLowerCase();\n\n  /* eslint-disable-next-line default-case */\n  switch (tag) {\n    // Should we not disable <a>? Will some of the <a> are styled as button?\n    case 'a':\n      undoStack.push(addEventListenerOnceWithUndo(element, 'click', disabledHandler));\n\n      break;\n\n    case 'button':\n    case 'input':\n    case 'select':\n    case 'textarea':\n      undoStack.push(setAttributeWithUndo(element, 'aria-disabled', 'true'));\n\n      if (isActive) {\n        undoStack.push(\n          addEventListenerOnceWithUndo(element, 'blur', () =>\n            undoStack.push(setAttributeWithUndo(element, 'disabled', 'disabled'))\n          )\n        );\n      } else {\n        undoStack.push(setAttributeWithUndo(element, 'disabled', 'disabled'));\n      }\n\n      if (tag === 'input' || tag === 'textarea') {\n        undoStack.push(addEventListenerOnceWithUndo(element, 'click', disabledHandler));\n        undoStack.push(setAttributeWithUndo(element, 'readonly', 'readonly'));\n      } else if (tag === 'select') {\n        undoStack.push(\n          ...[].map.call(element.querySelectorAll('option'), option =>\n            setAttributeWithUndo(option, 'disabled', 'disabled')\n          )\n        );\n      }\n\n      break;\n  }\n\n  return () => undoStack.forEach(undo => undo && undo());\n}\n\nfunction disableInputElementsWithUndo(element, observeSubtree = true) {\n  const undoStack = [].map.call(element.querySelectorAll('a, button, input, select, textarea'), element =>\n    disableElementWithUndo(element)\n  );\n\n  const tag = element.nodeName.toLowerCase();\n\n  // Only set tabindex=\"-1\" on focusable element. Otherwise, we will make <div> focusable by mouse.\n  (tag === 'a' || tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea') &&\n    undoStack.push(setAttributeWithUndo(element, 'tabindex', '-1'));\n\n  if (observeSubtree) {\n    const observer = new MutationObserver(mutations =>\n      mutations.forEach(({ addedNodes }) =>\n        undoStack.push(...addedNodes.map(addedNode => disableInputElementsWithUndo(addedNode, false)))\n      )\n    );\n\n    observer.observe(element, { childList: true, subtree: true });\n\n    undoStack.push(() => observer.disconnect());\n  }\n\n  return () => undoStack.forEach(undo => undo && undo());\n}\n\nfunction getFocusableElements(element) {\n  return [].filter.call(\n    element.querySelectorAll(\n      [\n        'a',\n        'body',\n        'button',\n        'frame',\n        'iframe',\n        'img',\n        'input',\n        'isindex',\n        'object',\n        'select',\n        'textarea',\n        '[tabindex]'\n      ].join(', ')\n    ),\n    element => {\n      const tabIndex = getTabIndex(element);\n\n      return typeof tabIndex === 'number' && tabIndex >= 0;\n    }\n  );\n}\n\nfunction restoreActiveElementIndex(element, activeElementIndex) {\n  const focusable = getFocusableElements(element)[activeElementIndex];\n\n  focusable && focusable.focus();\n}\n\nfunction saveActiveElementIndex(element) {\n  return getFocusableElements(element).indexOf(document.activeElement);\n}\n\nfunction restoreInputValues(element, inputValues) {\n  const inputs = element.querySelectorAll('input, select, textarea');\n\n  [].forEach.call(inputs, (input, index) => {\n    const value = inputValues[index];\n\n    if (typeof value !== 'undefined') {\n      const { tagName, type } = input;\n\n      if (tagName === 'INPUT' && (type === 'checkbox' || type === 'radio')) {\n        input.checked = value;\n      } else {\n        input.value = value;\n      }\n    }\n  });\n}\n\nfunction saveInputValues(element) {\n  const inputs = element.querySelectorAll('input, select, textarea');\n\n  return [].map.call(inputs, ({ checked, tagName, type, value }) => {\n    if (tagName === 'INPUT' && (type === 'checkbox' || type === 'radio')) {\n      return checked;\n    }\n\n    return value;\n  });\n}\n\nconst AdaptiveCardRenderer = ({ actionPerformedClassName, adaptiveCard, disabled: disabledFromProps, tapAction }) => {\n  const [{ adaptiveCardRenderer: adaptiveCardRendererStyleSet }] = useStyleSet();\n  const [{ GlobalSettings, HostConfig }] = useAdaptiveCardsPackage();\n  const [actionsPerformed, setActionsPerformed] = useState([]);\n  const [adaptiveCardsHostConfig] = useAdaptiveCardsHostConfig();\n  const [disabledFromComposer] = useDisabled();\n  const [errors, setErrors] = useState([]);\n  const [lastRender, setLastRender] = useState(0);\n  const activeElementIndexRef = useRef(-1);\n  const adaptiveCardElementRef = useRef();\n  const contentRef = useRef();\n  const inputValuesRef = useRef([]);\n  const localize = useLocalizer();\n  const performCardAction = usePerformCardAction();\n  const renderMarkdownAsHTML = useRenderMarkdownAsHTML();\n  const scrollToEnd = useScrollToEnd();\n\n  const disabled = disabledFromComposer || disabledFromProps;\n\n  // TODO: [P2] #3199 We should consider using `adaptiveCard.selectAction` instead.\n  // The null check for \"tapAction\" is in \"handleClickAndKeyPressForTapAction\".\n  const handleClickAndKeyPress = useCallback(\n    event => {\n      const { key, target, type } = event;\n\n      // Some items, e.g. tappable text, cannot be disabled thru DOM attributes\n      const { current } = contentRef;\n      const adaptiveCardRoot = current.querySelector('.ac-adaptiveCard[tabindex=\"0\"]');\n\n      if (!adaptiveCardRoot) {\n        return console.warn(\n          'botframework-webchat: No Adaptive Card root container can be found, probably on an unsupported Adaptive Card version.'\n        );\n      }\n\n      // For \"keypress\" event, we only listen to ENTER and SPACEBAR key.\n      if (type === 'keypress') {\n        if (key !== 'Enter' && key !== ' ') {\n          return;\n        }\n\n        event.preventDefault();\n      }\n\n      // We will call performCardAction if either:\n      // 1. We are on the target, or\n      // 2. The event-dispatching element is not interactive\n      if (target !== adaptiveCardRoot) {\n        const tabIndex = getTabIndex(target);\n\n        // If the user is clicking on something that is already clickable, do not allow them to click the card.\n        // E.g. a hero card can be tappable, and image and buttons inside the hero card can also be tappable.\n        if (typeof tabIndex === 'number' && tabIndex >= 0) {\n          return;\n        }\n      }\n\n      performCardAction(tapAction);\n      scrollToEnd();\n    },\n    [contentRef, performCardAction, scrollToEnd, tapAction]\n  );\n\n  // Only listen to event if it is not disabled and have \"tapAction\" prop.\n  const handleClickAndKeyPressForTapAction = !disabled && tapAction ? handleClickAndKeyPress : undefined;\n\n  const addActionsPerformed = useCallback(\n    action => !~actionsPerformed.indexOf(action) && setActionsPerformed([...actionsPerformed, action]),\n    [actionsPerformed, setActionsPerformed]\n  );\n\n  const handleExecuteAction = useCallback(\n    action => {\n      // Some items, e.g. tappable image, cannot be disabled thru DOM attributes\n      if (disabled) {\n        return;\n      }\n\n      addActionsPerformed(action);\n\n      const actionTypeName = action.getJsonTypeName();\n\n      if (actionTypeName === 'Action.OpenUrl') {\n        performCardAction({\n          type: 'openUrl',\n          value: action.url\n        });\n      } else if (actionTypeName === 'Action.Submit') {\n        if (typeof action.data !== 'undefined') {\n          const { data: actionData } = action;\n\n          if (actionData && actionData.__isBotFrameworkCardAction) {\n            const { cardAction } = actionData;\n            const { displayText, text, type, value } = cardAction;\n\n            performCardAction({ displayText, text, type, value });\n          } else {\n            performCardAction({\n              type: typeof action.data === 'string' ? 'imBack' : 'postBack',\n              value: action.data\n            });\n          }\n        }\n\n        scrollToEnd();\n      } else {\n        console.error(`Web Chat: received unknown action from Adaptive Cards`);\n        console.error(action);\n      }\n    },\n    [addActionsPerformed, disabled, performCardAction, scrollToEnd]\n  );\n\n  useLayoutEffect(() => {\n    const { current } = contentRef;\n\n    if (!current || !adaptiveCard) {\n      activeElementIndexRef.current = -1;\n      inputValuesRef.current = [];\n    }\n\n    // Currently, the only way to set the Markdown engine is to set it thru static member of AdaptiveCard class\n\n    // TODO: [P3] Checks if we could make the \"renderMarkdownAsHTML\" per card\n    //       This could be limitations from Adaptive Cards package (not supported as of 1.2.5)\n    //       Because there could be timing difference between .parse and .render, we could be using wrong Markdown engine\n\n    adaptiveCard.constructor.onProcessMarkdown = (text, result) => {\n      if (renderMarkdownAsHTML) {\n        result.outputHtml = renderMarkdownAsHTML(text);\n        result.didProcess = true;\n      }\n    };\n\n    if (adaptiveCardsHostConfig) {\n      adaptiveCard.hostConfig = isPlainObject(adaptiveCardsHostConfig)\n        ? new HostConfig(adaptiveCardsHostConfig)\n        : adaptiveCardsHostConfig;\n    }\n\n    // For accessibility issue #1340, `tabindex=\"0\"` must not be set for the root container if it is not interactive.\n    GlobalSettings.setTabIndexAtCardRoot = !!tapAction;\n\n    const { failures } = adaptiveCard.validateProperties();\n\n    if (failures.length) {\n      return setErrors(\n        failures.reduce((items, { errors }) => [...items, ...errors.map(({ message }) => new Error(message))], [])\n      );\n    }\n\n    let element;\n\n    try {\n      element = adaptiveCard.render();\n    } catch (error) {\n      return setErrors([error]);\n    }\n\n    if (!element) {\n      return setErrors([new Error('Adaptive Card rendered as empty element')]);\n    }\n\n    // Clear errors on next render\n    setErrors([]);\n\n    restoreInputValues(element, inputValuesRef.current);\n\n    current.appendChild(element);\n    adaptiveCardElementRef.current = element;\n\n    // Focus can only be restored after the DOM is attached.\n    restoreActiveElementIndex(element, activeElementIndexRef.current);\n\n    setLastRender(Date.now());\n\n    return () => {\n      activeElementIndexRef.current = saveActiveElementIndex(element);\n      inputValuesRef.current = saveInputValues(element);\n\n      current.removeChild(adaptiveCardElementRef.current);\n\n      adaptiveCardElementRef.current = undefined;\n    };\n  }, [\n    adaptiveCard,\n    adaptiveCardsHostConfig,\n    contentRef,\n    GlobalSettings,\n    HostConfig,\n    renderMarkdownAsHTML,\n    setErrors,\n    tapAction\n  ]);\n\n  useEffect(() => {\n    // Set onExecuteAction without causing unnecessary re-render.\n    adaptiveCard.onExecuteAction = disabled ? undefined : handleExecuteAction;\n  }, [adaptiveCard, disabled, handleExecuteAction]);\n\n  useEffect(() => {\n    // If the Adaptive Card get re-rendered, re-disable elements as needed.\n    if (disabled) {\n      return disableInputElementsWithUndo(adaptiveCardElementRef.current);\n    }\n  }, [disabled, lastRender]);\n\n  useEffect(() => {\n    // If the Adaptive Card changed, reset all actions performed.\n    setActionsPerformed([]);\n  }, [adaptiveCard]);\n\n  useEffect(() => {\n    // Add developers to highlight actions when they have been clicked.\n    if (!actionPerformedClassName) {\n      return;\n    }\n\n    const undoStack = actionsPerformed.map(\n      ({ renderedElement }) =>\n        renderedElement &&\n        adaptiveCardElementRef.current.contains(renderedElement) &&\n        addPersistentClassWithUndo(renderedElement, actionPerformedClassName)\n    );\n\n    return () => undoStack.forEach(undo => undo && undo());\n  }, [actionsPerformed, actionPerformedClassName, lastRender]);\n\n  return errors.length ? (\n    node_env === 'development' ? (\n      <ErrorBox error={errors[0]} type={localize('ADAPTIVE_CARD_ERROR_BOX_TITLE_RENDER')} />\n    ) : (\n      false\n    )\n  ) : (\n    <div\n      className={classNames(adaptiveCardRendererStyleSet + '', 'webchat__adaptive-card-renderer')}\n      onClick={handleClickAndKeyPressForTapAction}\n      onKeyPress={handleClickAndKeyPressForTapAction}\n      ref={contentRef}\n    />\n  );\n};\n\nAdaptiveCardRenderer.defaultProps = {\n  actionPerformedClassName: '',\n  disabled: undefined,\n  tapAction: undefined\n};\n\nAdaptiveCardRenderer.propTypes = {\n  actionPerformedClassName: PropTypes.string,\n  adaptiveCard: PropTypes.any.isRequired,\n  disabled: PropTypes.bool,\n  tapAction: PropTypes.shape({\n    type: PropTypes.string.isRequired,\n    value: PropTypes.string\n  })\n};\n\nexport default AdaptiveCardRenderer;\n"],"sourceRoot":"bundle:///"},"metadata":{},"sourceType":"script"}