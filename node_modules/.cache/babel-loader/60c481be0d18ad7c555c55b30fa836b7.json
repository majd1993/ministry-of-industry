{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nvar _a;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Exports_1 = require(\"../../common.speech/Exports\");\n\nvar Exports_2 = require(\"../../common/Exports\");\n\nvar AudioOutputFormat_1 = require(\"./AudioOutputFormat\");\n\nvar AudioOutputStream_1 = require(\"./AudioOutputStream\");\n\nvar MediaDurationPlaceholderSeconds = 60 * 30;\nvar AudioFormatToMimeType = (_a = {}, _a[AudioOutputFormat_1.AudioFormatTag.PCM] = \"audio/wav\", _a[AudioOutputFormat_1.AudioFormatTag.MP3] = \"audio/mpeg\", _a[AudioOutputFormat_1.AudioFormatTag.Opus] = \"audio/ogg\", _a);\n/**\n * Represents the speaker playback audio destination, which only works in browser.\n * Note: the SDK will try to use <a href=\"https://www.w3.org/TR/media-source/\">Media Source Extensions</a> to play audio.\n * Mp3 format has better supports on Microsoft Edge, Chrome and Safari (desktop), so, it's better to specify mp3 format for playback.\n * @class SpeakerAudioDestination\n * Updated in version 1.12.1\n */\n\nvar SpeakerAudioDestination =\n/** @class */\nfunction () {\n  function SpeakerAudioDestination(audioDestinationId) {\n    this.privPlaybackStarted = false;\n    this.privAppendingToBuffer = false;\n    this.privMediaSourceOpened = false;\n    this.privBytesReceived = 0;\n    this.privId = audioDestinationId ? audioDestinationId : Exports_2.createNoDashGuid();\n    this.privIsPaused = false;\n    this.privIsClosed = false;\n  }\n\n  SpeakerAudioDestination.prototype.id = function () {\n    return this.privId;\n  };\n\n  SpeakerAudioDestination.prototype.write = function (buffer) {\n    if (this.privAudioBuffer !== undefined) {\n      this.privAudioBuffer.push(buffer);\n      this.updateSourceBuffer();\n    } else if (this.privAudioOutputStream !== undefined) {\n      this.privAudioOutputStream.write(buffer);\n      this.privBytesReceived += buffer.byteLength;\n    }\n  };\n\n  SpeakerAudioDestination.prototype.close = function () {\n    this.privIsClosed = true;\n\n    if (this.privSourceBuffer !== undefined) {\n      this.handleSourceBufferUpdateEnd();\n    } else if (this.privAudioOutputStream !== undefined) {\n      var receivedAudio = new ArrayBuffer(this.privBytesReceived);\n      this.privAudioOutputStream.read(receivedAudio);\n\n      if (this.privFormat.hasHeader) {\n        receivedAudio = Exports_1.SynthesisAdapterBase.addHeader(receivedAudio, this.privFormat);\n      }\n\n      var audioBlob = new Blob([receivedAudio], {\n        type: AudioFormatToMimeType[this.privFormat.formatTag]\n      });\n      this.privAudio.src = window.URL.createObjectURL(audioBlob);\n      this.notifyPlayback();\n    }\n  };\n\n  Object.defineProperty(SpeakerAudioDestination.prototype, \"format\", {\n    set: function set(format) {\n      var _this = this;\n\n      if (typeof AudioContext !== \"undefined\" || typeof window.webkitAudioContext !== \"undefined\") {\n        this.privFormat = format;\n        var mimeType_1 = AudioFormatToMimeType[this.privFormat.formatTag];\n\n        if (mimeType_1 === undefined) {\n          // tslint:disable-next-line:no-console\n          console.warn(\"Unknown mimeType for format \" + AudioOutputFormat_1.AudioFormatTag[this.privFormat.formatTag] + \".\");\n        } else if (typeof MediaSource !== \"undefined\" && MediaSource.isTypeSupported(mimeType_1)) {\n          this.privAudio = new Audio();\n          this.privAudioBuffer = [];\n          this.privMediaSource = new MediaSource();\n          this.privAudio.src = URL.createObjectURL(this.privMediaSource);\n          this.privAudio.load();\n\n          this.privMediaSource.onsourceopen = function (event) {\n            _this.privMediaSourceOpened = true;\n            _this.privMediaSource.duration = MediaDurationPlaceholderSeconds;\n            _this.privSourceBuffer = _this.privMediaSource.addSourceBuffer(mimeType_1);\n\n            _this.privSourceBuffer.onupdate = function (_) {\n              _this.updateSourceBuffer();\n            };\n\n            _this.privSourceBuffer.onupdateend = function (_) {\n              _this.handleSourceBufferUpdateEnd();\n            };\n\n            _this.privSourceBuffer.onupdatestart = function (_) {\n              _this.privAppendingToBuffer = false;\n            };\n          };\n\n          this.updateSourceBuffer();\n        } else {\n          // tslint:disable-next-line:no-console\n          console.warn(\"Format \" + AudioOutputFormat_1.AudioFormatTag[this.privFormat.formatTag] + \" could not be played by MSE, streaming playback is not enabled.\");\n          this.privAudioOutputStream = new AudioOutputStream_1.PullAudioOutputStreamImpl();\n          this.privAudioOutputStream.format = this.privFormat;\n          this.privAudio = new Audio();\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SpeakerAudioDestination.prototype, \"isClosed\", {\n    get: function get() {\n      return this.privIsClosed;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SpeakerAudioDestination.prototype, \"currentTime\", {\n    get: function get() {\n      if (this.privAudio !== undefined) {\n        return this.privAudio.currentTime;\n      }\n\n      return -1;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  SpeakerAudioDestination.prototype.pause = function () {\n    if (!this.privIsPaused && this.privAudio !== undefined) {\n      this.privAudio.pause();\n      this.privIsPaused = true;\n    }\n  };\n\n  SpeakerAudioDestination.prototype.resume = function () {\n    if (this.privIsPaused && this.privAudio !== undefined) {\n      this.privAudio.play();\n      this.privIsPaused = false;\n    }\n  };\n\n  Object.defineProperty(SpeakerAudioDestination.prototype, \"internalAudio\", {\n    get: function get() {\n      return this.privAudio;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  SpeakerAudioDestination.prototype.updateSourceBuffer = function () {\n    if (this.privAudioBuffer !== undefined && this.privAudioBuffer.length > 0 && this.sourceBufferAvailable()) {\n      this.privAppendingToBuffer = true;\n      var binary = this.privAudioBuffer.shift();\n\n      try {\n        this.privSourceBuffer.appendBuffer(binary);\n      } catch (error) {\n        this.privAudioBuffer.unshift(binary); // tslint:disable-next-line:no-console\n\n        console.log(\"buffer filled, pausing addition of binaries until space is made\");\n        return;\n      }\n\n      this.notifyPlayback();\n    } else if (this.canEndStream()) {\n      this.handleSourceBufferUpdateEnd();\n    }\n  };\n\n  SpeakerAudioDestination.prototype.handleSourceBufferUpdateEnd = function () {\n    if (this.canEndStream() && this.sourceBufferAvailable()) {\n      this.privMediaSource.endOfStream();\n      this.notifyPlayback();\n    }\n  };\n\n  SpeakerAudioDestination.prototype.notifyPlayback = function () {\n    var _this = this;\n\n    if (!this.privPlaybackStarted && this.privAudio !== undefined) {\n      this.privAudio.onended = function () {\n        if (!!_this.onAudioEnd) {\n          _this.onAudioEnd(_this);\n        }\n      };\n\n      if (!this.privIsPaused) {\n        this.privAudio.play();\n      }\n\n      this.privPlaybackStarted = true;\n    }\n  };\n\n  SpeakerAudioDestination.prototype.canEndStream = function () {\n    return this.isClosed && this.privSourceBuffer !== undefined && this.privAudioBuffer.length === 0 && this.privMediaSourceOpened && !this.privAppendingToBuffer && this.privMediaSource.readyState === \"open\";\n  };\n\n  SpeakerAudioDestination.prototype.sourceBufferAvailable = function () {\n    return this.privSourceBuffer !== undefined && !this.privSourceBuffer.updating;\n  };\n\n  return SpeakerAudioDestination;\n}();\n\nexports.SpeakerAudioDestination = SpeakerAudioDestination;","map":{"version":3,"sources":["src/sdk/Audio/SpeakerAudioDestination.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { SynthesisAdapterBase } from \"../../common.speech/Exports\";\r\nimport {\r\n    createNoDashGuid,\r\n    IAudioDestination,\r\n    INumberDictionary\r\n} from \"../../common/Exports\";\r\nimport { AudioStreamFormat, IPlayer } from \"../Exports\";\r\nimport { AudioFormatTag, AudioOutputFormatImpl } from \"./AudioOutputFormat\";\r\nimport { PullAudioOutputStreamImpl } from \"./AudioOutputStream\";\r\n\r\nconst MediaDurationPlaceholderSeconds = 60 * 30;\r\n\r\nconst AudioFormatToMimeType: INumberDictionary<string> = {\r\n    [AudioFormatTag.PCM]: \"audio/wav\",\r\n    [AudioFormatTag.MP3]: \"audio/mpeg\",\r\n    [AudioFormatTag.Opus]: \"audio/ogg\",\r\n};\r\n\r\n/**\r\n * Represents the speaker playback audio destination, which only works in browser.\r\n * Note: the SDK will try to use <a href=\"https://www.w3.org/TR/media-source/\">Media Source Extensions</a> to play audio.\r\n * Mp3 format has better supports on Microsoft Edge, Chrome and Safari (desktop), so, it's better to specify mp3 format for playback.\r\n * @class SpeakerAudioDestination\r\n * Updated in version 1.12.1\r\n */\r\nexport class SpeakerAudioDestination implements IAudioDestination, IPlayer {\r\n    private readonly privId: string;\r\n    private privFormat: AudioOutputFormatImpl;\r\n    private privAudio: HTMLAudioElement;\r\n    private privMediaSource: MediaSource;\r\n    private privSourceBuffer: SourceBuffer;\r\n    private privPlaybackStarted: boolean = false;\r\n    private privAudioBuffer: ArrayBuffer[];\r\n    private privAppendingToBuffer: boolean = false;\r\n    private privMediaSourceOpened: boolean = false;\r\n    private privIsClosed: boolean;\r\n    private privIsPaused: boolean;\r\n    private privAudioOutputStream: PullAudioOutputStreamImpl;\r\n    private privBytesReceived: number = 0;\r\n\r\n    public constructor(audioDestinationId?: string) {\r\n        this.privId = audioDestinationId ? audioDestinationId : createNoDashGuid();\r\n        this.privIsPaused = false;\r\n        this.privIsClosed = false;\r\n    }\r\n\r\n    public id(): string {\r\n        return this.privId;\r\n    }\r\n\r\n    public write(buffer: ArrayBuffer): void {\r\n        if (this.privAudioBuffer !== undefined) {\r\n            this.privAudioBuffer.push(buffer);\r\n            this.updateSourceBuffer();\r\n        } else if (this.privAudioOutputStream !== undefined) {\r\n            this.privAudioOutputStream.write(buffer);\r\n            this.privBytesReceived += buffer.byteLength;\r\n        }\r\n    }\r\n\r\n    public close(): void {\r\n        this.privIsClosed = true;\r\n        if (this.privSourceBuffer !== undefined) {\r\n            this.handleSourceBufferUpdateEnd();\r\n        } else if (this.privAudioOutputStream !== undefined) {\r\n            let receivedAudio = new ArrayBuffer(this.privBytesReceived);\r\n            this.privAudioOutputStream.read(receivedAudio);\r\n            if (this.privFormat.hasHeader) {\r\n                receivedAudio = SynthesisAdapterBase.addHeader(receivedAudio, this.privFormat);\r\n            }\r\n            const audioBlob = new Blob([receivedAudio], { type: AudioFormatToMimeType[this.privFormat.formatTag] });\r\n            this.privAudio.src = window.URL.createObjectURL(audioBlob);\r\n            this.notifyPlayback();\r\n        }\r\n    }\r\n\r\n    set format(format: AudioStreamFormat) {\r\n        if (typeof (AudioContext) !== \"undefined\" || typeof ((window as any).webkitAudioContext) !== \"undefined\") {\r\n            this.privFormat = format as AudioOutputFormatImpl;\r\n            const mimeType: string = AudioFormatToMimeType[this.privFormat.formatTag];\r\n            if (mimeType === undefined) {\r\n                // tslint:disable-next-line:no-console\r\n                console.warn(\r\n                    `Unknown mimeType for format ${AudioFormatTag[this.privFormat.formatTag]}.`);\r\n\r\n            } else if (typeof(MediaSource) !== \"undefined\" && MediaSource.isTypeSupported(mimeType)) {\r\n                this.privAudio = new Audio();\r\n                this.privAudioBuffer = [];\r\n                this.privMediaSource = new MediaSource();\r\n                this.privAudio.src = URL.createObjectURL(this.privMediaSource);\r\n                this.privAudio.load();\r\n                this.privMediaSource.onsourceopen = (event: Event): void => {\r\n                    this.privMediaSourceOpened = true;\r\n                    this.privMediaSource.duration = MediaDurationPlaceholderSeconds;\r\n                    this.privSourceBuffer = this.privMediaSource.addSourceBuffer(mimeType);\r\n                    this.privSourceBuffer.onupdate = (_: Event) => {\r\n                        this.updateSourceBuffer();\r\n                    };\r\n                    this.privSourceBuffer.onupdateend = (_: Event) => {\r\n                        this.handleSourceBufferUpdateEnd();\r\n                    };\r\n                    this.privSourceBuffer.onupdatestart = (_: Event) => {\r\n                        this.privAppendingToBuffer = false;\r\n                    };\r\n                };\r\n                this.updateSourceBuffer();\r\n            } else {\r\n                // tslint:disable-next-line:no-console\r\n                console.warn(\r\n                    `Format ${AudioFormatTag[this.privFormat.formatTag]} could not be played by MSE, streaming playback is not enabled.`);\r\n                this.privAudioOutputStream = new PullAudioOutputStreamImpl();\r\n                this.privAudioOutputStream.format = this.privFormat;\r\n                this.privAudio = new Audio();\r\n            }\r\n        }\r\n    }\r\n\r\n    public get isClosed(): boolean {\r\n        return this.privIsClosed;\r\n    }\r\n\r\n    public get currentTime(): number {\r\n        if (this.privAudio !== undefined) {\r\n            return this.privAudio.currentTime;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    public pause(): void {\r\n        if (!this.privIsPaused && this.privAudio !== undefined) {\r\n            this.privAudio.pause();\r\n            this.privIsPaused = true;\r\n        }\r\n    }\r\n\r\n    public resume(): void {\r\n        if (this.privIsPaused && this.privAudio !== undefined) {\r\n            this.privAudio.play();\r\n            this.privIsPaused = false;\r\n        }\r\n    }\r\n\r\n    public onAudioEnd: (sender: IPlayer) => void;\r\n\r\n    public get internalAudio(): HTMLAudioElement {\r\n        return this.privAudio;\r\n    }\r\n\r\n    private updateSourceBuffer(): void {\r\n        if (this.privAudioBuffer !== undefined && (this.privAudioBuffer.length > 0) && this.sourceBufferAvailable()) {\r\n            this.privAppendingToBuffer = true;\r\n            const binary = this.privAudioBuffer.shift();\r\n            try {\r\n                this.privSourceBuffer.appendBuffer(binary);\r\n            } catch (error) {\r\n                this.privAudioBuffer.unshift(binary);\r\n                // tslint:disable-next-line:no-console\r\n                console.log(\r\n                    \"buffer filled, pausing addition of binaries until space is made\");\r\n                return;\r\n            }\r\n            this.notifyPlayback();\r\n        } else if (this.canEndStream()) {\r\n            this.handleSourceBufferUpdateEnd();\r\n        }\r\n    }\r\n\r\n    private handleSourceBufferUpdateEnd(): void {\r\n        if (this.canEndStream() && this.sourceBufferAvailable()) {\r\n            this.privMediaSource.endOfStream();\r\n            this.notifyPlayback();\r\n        }\r\n    }\r\n\r\n    private notifyPlayback(): void {\r\n        if (!this.privPlaybackStarted && this.privAudio !== undefined) {\r\n            this.privAudio.onended = (): void => {\r\n                if (!!this.onAudioEnd) {\r\n                    this.onAudioEnd(this);\r\n                }\r\n            };\r\n            if (!this.privIsPaused) {\r\n                this.privAudio.play();\r\n            }\r\n            this.privPlaybackStarted = true;\r\n        }\r\n    }\r\n\r\n    private canEndStream(): boolean {\r\n        return (this.isClosed && this.privSourceBuffer !== undefined && (this.privAudioBuffer.length === 0)\r\n            && this.privMediaSourceOpened && !this.privAppendingToBuffer && this.privMediaSource.readyState === \"open\");\r\n    }\r\n\r\n    private sourceBufferAvailable(): boolean {\r\n        return (this.privSourceBuffer !== undefined && !this.privSourceBuffer.updating);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}