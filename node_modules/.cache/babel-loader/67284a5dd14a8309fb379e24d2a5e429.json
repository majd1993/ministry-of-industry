{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = playCognitiveServicesStream;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _cognitiveServicesAsyncFunctionToESAsyncFunction = _interopRequireDefault(require(\"./cognitiveServicesAsyncFunctionToESAsyncFunction\"));\n\nvar _createMultiBufferingPlayer = _interopRequireDefault(require(\"./createMultiBufferingPlayer\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Safari requires an audio buffer with a sample rate of 22050 Hz.\n// Using a minimum sample rate of 44100 Hz as an example, the Speech SDK's default 16000 Hz will be upsampled to 48000 Hz.\n\n\nvar MIN_SAMPLE_RATE = 44100; // The Speech SDK is hardcoded to chop packets to 4096 bytes.\n// Web Chat's multi-buffering player is set up with 3 buffers; each is 4096 bytes (2048 16-bit samples).\n// For simplicity, the multi-buffer player currently does not support progressive buffering.\n// Progressive buffering allows queuing at any sample size and will be concatenated.\n// If 1000 samples are queued, then 1048 samples are queued, they will be concatenated into a single buffer of size 2048.\n// For simplicity, data will be queued to two buffers.\n// The first buffer is 1000 samples followed by 1048 zeroes, and the second buffer is 1048 samples followed by 1000 zeroes.\n// There is no plan to support progressive buffering until the Speech SDK chops data at dynamic size.\n\nvar DEFAULT_BUFFER_SIZE = 4096;\n\nfunction average(array) {\n  return array.reduce(function (sum, value) {\n    return sum + value;\n  }, 0) / array.length;\n}\n\nfunction formatTypedBitArrayToFloatArray(audioData, maxValue) {\n  var float32Data = new Float32Array(audioData.length);\n\n  for (var i = 0; i < audioData.length; i++) {\n    float32Data[i] = audioData[i] / maxValue;\n  }\n\n  return float32Data;\n}\n\nfunction formatAudioDataArrayBufferToFloatArray(_ref, arrayBuffer) {\n  var bitsPerSample = _ref.bitsPerSample;\n\n  switch (bitsPerSample) {\n    case 8:\n      return formatTypedBitArrayToFloatArray(new Int8Array(arrayBuffer), 128);\n\n    case 16:\n      return formatTypedBitArrayToFloatArray(new Int16Array(arrayBuffer), 32768);\n\n    case 32:\n      return formatTypedBitArrayToFloatArray(new Int32Array(arrayBuffer), 2147483648);\n\n    default:\n      throw new Error('Only WAVE_FORMAT_PCM (8/16/32 bps) format supported at this time');\n  }\n}\n\nfunction abortToReject(signal) {\n  return new Promise(function (_, reject) {\n    signal.onabort = function () {\n      return reject(new Error('aborted'));\n    };\n  });\n} // In a 2 channel audio (e.g. A/B), the data arrives as interleaved, like \"ABABABABAB\".\n// This function will take \"ABABABABAB\" and return an array [\"AAAAA\", \"BBBBB\"].\n\n\nfunction deinterleave(channelInterleavedAudioData, _ref2) {\n  var channels = _ref2.channels;\n  var multiChannelArrayBuffer = new Array(channels);\n  var frameSize = channelInterleavedAudioData.length / channels;\n\n  for (var channel = 0; channel < channels; channel++) {\n    var audioData = new Float32Array(frameSize);\n    multiChannelArrayBuffer[channel] = audioData;\n\n    for (var offset = 0; offset < frameSize; offset++) {\n      audioData[offset] = channelInterleavedAudioData[offset * channels + channel];\n    }\n  }\n\n  return multiChannelArrayBuffer;\n} // This function upsamples the audio data via an integer multiplier.\n// Web Chat uses simple anti-aliasing. For simplicity, the anti-aliasing does not roll over to next buffer.\n\n\nfunction multiplySampleRate(source, sampleRateMultiplier) {\n  if (sampleRateMultiplier === 1) {\n    return source;\n  }\n\n  var lastValues = new Array(sampleRateMultiplier).fill(source[0]);\n  var target = new Float32Array(source.length * sampleRateMultiplier);\n\n  for (var sourceOffset = 0; sourceOffset < source.length; sourceOffset++) {\n    var value = source[sourceOffset];\n    var targetOffset = sourceOffset * sampleRateMultiplier;\n\n    for (var multiplierIndex = 0; multiplierIndex < sampleRateMultiplier; multiplierIndex++) {\n      lastValues.shift();\n      lastValues.push(value);\n      target[targetOffset + multiplierIndex] = average(lastValues);\n    }\n  }\n\n  return target;\n}\n\nfunction playCognitiveServicesStream(_x, _x2) {\n  return _playCognitiveServicesStream.apply(this, arguments);\n}\n\nfunction _playCognitiveServicesStream() {\n  _playCognitiveServicesStream = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(audioContext, stream) {\n    var _ref3,\n        _ref3$signal,\n        signal,\n        queuedBufferSourceNodes,\n        _args2 = arguments;\n\n    return _regenerator.default.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _ref3 = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {}, _ref3$signal = _ref3.signal, signal = _ref3$signal === void 0 ? {} : _ref3$signal;\n\n            if (audioContext) {\n              _context2.next = 5;\n              break;\n            }\n\n            throw new Error('botframework-directlinespeech-sdk: audioContext must be specified.');\n\n          case 5:\n            if (stream) {\n              _context2.next = 9;\n              break;\n            }\n\n            throw new Error('botframework-directlinespeech-sdk: stream must be specified.');\n\n          case 9:\n            if (stream.format) {\n              _context2.next = 13;\n              break;\n            }\n\n            throw new Error('botframework-directlinespeech-sdk: stream is missing format.');\n\n          case 13:\n            if (!(typeof stream.read !== 'function')) {\n              _context2.next = 15;\n              break;\n            }\n\n            throw new Error('botframework-directlinespeech-sdk: stream is missing read().');\n\n          case 15:\n            queuedBufferSourceNodes = [];\n            _context2.prev = 16;\n            return _context2.delegateYield( /*#__PURE__*/_regenerator.default.mark(function _callee() {\n              var format, abortPromise, array, streamRead, read, newSamplesPerSec, sampleRateMultiplier, player, chunk, maxChunks, interleavedArray, multiChannelArray, upsampledMultiChannelArray;\n              return _regenerator.default.wrap(function _callee$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      format = stream.format;\n                      abortPromise = abortToReject(signal);\n                      array = new Uint8Array(DEFAULT_BUFFER_SIZE);\n                      streamRead = (0, _cognitiveServicesAsyncFunctionToESAsyncFunction.default)(stream.read.bind(stream));\n\n                      read = function read() {\n                        return Promise.race([// Abort will gracefully end the queue. We will check signal.aborted later to throw abort exception.\n                        // eslint-disable-next-line no-empty-function\n                        abortPromise.catch(function () {}), streamRead(array.buffer).then(function (numBytes) {\n                          return numBytes === array.byteLength ? array : numBytes ? array.slice(0, numBytes) : undefined;\n                        })]);\n                      };\n\n                      if (!signal.aborted) {\n                        _context.next = 7;\n                        break;\n                      }\n\n                      throw new Error('aborted');\n\n                    case 7:\n                      newSamplesPerSec = format.samplesPerSec;\n                      sampleRateMultiplier = 1; // Safari requires a minimum sample rate of 22100 Hz.\n                      // A multiplier is calculated the the data meets the minimum sample rate.\n                      // An integer-based multiplier to simplify our upsampler.\n                      // For security, data will only be upsampled up to 96000 Hz.\n\n                      while (newSamplesPerSec < MIN_SAMPLE_RATE && newSamplesPerSec < 96000) {\n                        sampleRateMultiplier++;\n                        newSamplesPerSec = format.samplesPerSec * sampleRateMultiplier;\n                      } // The third parameter is the sample size in bytes.\n                      // For example, if the Speech SDK sends Web Chat 4096 bytes of 16-bit samples, there will be 2048 samples per channel.\n                      // The multi-buffering player is set up to handle 2048 samples per buffer.\n                      // If the multiplier 3x, it will handle 6144 samples per buffer.\n\n\n                      player = (0, _createMultiBufferingPlayer.default)(audioContext, _objectSpread(_objectSpread({}, format), {}, {\n                        samplesPerSec: newSamplesPerSec\n                      }), DEFAULT_BUFFER_SIZE / (format.bitsPerSample / 8) * sampleRateMultiplier); // For security, the maximum number of chunks handled will be 1000.\n\n                      _context.next = 13;\n                      return read();\n\n                    case 13:\n                      chunk = _context.sent;\n                      maxChunks = 0;\n\n                    case 15:\n                      if (!(chunk && maxChunks < 1000 && !signal.aborted)) {\n                        _context.next = 28;\n                        break;\n                      }\n\n                      if (!signal.aborted) {\n                        _context.next = 18;\n                        break;\n                      }\n\n                      return _context.abrupt(\"break\", 28);\n\n                    case 18:\n                      // Data received from Speech SDK is interleaved; 2 channels (e.g. A and B) will be sent as \"ABABABABAB\"\n                      // And each sample (A/B) will be an 8 to 32-bit number.\n                      // Convert the 8 - 32-bit number into a floating-point number, as required by Web Audio API.\n                      interleavedArray = formatAudioDataArrayBufferToFloatArray(format, chunk.buffer); // Deinterleave data back into two array buffer, e.g. \"AAAAA\" and \"BBBBB\".\n\n                      multiChannelArray = deinterleave(interleavedArray, format); // Upsample data if necessary. If the multiplier is 2x, \"AAAAA\" will be upsampled to \"AAAAAAAAAA\" (with anti-alias).\n\n                      upsampledMultiChannelArray = multiChannelArray.map(function (array) {\n                        return multiplySampleRate(array, sampleRateMultiplier);\n                      }); // Queue to the buffering player.\n\n                      player.push(upsampledMultiChannelArray);\n\n                    case 22:\n                      _context.next = 24;\n                      return read();\n\n                    case 24:\n                      chunk = _context.sent;\n                      maxChunks++;\n                      _context.next = 15;\n                      break;\n\n                    case 28:\n                      abortPromise.catch(function () {\n                        return player.cancelAll();\n                      });\n\n                      if (!signal.aborted) {\n                        _context.next = 31;\n                        break;\n                      }\n\n                      throw new Error('aborted');\n\n                    case 31:\n                      _context.next = 33;\n                      return Promise.race([abortPromise, player.flush()]);\n\n                    case 33:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, _callee);\n            })(), \"t0\", 18);\n\n          case 18:\n            _context2.prev = 18;\n            queuedBufferSourceNodes.forEach(function (node) {\n              return node.stop();\n            });\n            return _context2.finish(18);\n\n          case 21:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[16,, 18, 21]]);\n  }));\n  return _playCognitiveServicesStream.apply(this, arguments);\n}","map":{"version":3,"sources":["../src/playCognitiveServicesStream.js"],"names":["MIN_SAMPLE_RATE","DEFAULT_BUFFER_SIZE","sum","array","float32Data","audioData","i","bitsPerSample","formatTypedBitArrayToFloatArray","signal","reject","channels","multiChannelArrayBuffer","frameSize","channelInterleavedAudioData","channel","offset","sampleRateMultiplier","lastValues","source","target","sourceOffset","value","targetOffset","multiplierIndex","average","playCognitiveServicesStream","stream","queuedBufferSourceNodes","format","abortPromise","abortToReject","streamRead","read","numBytes","newSamplesPerSec","player","samplesPerSec","chunk","maxChunks","interleavedArray","formatAudioDataArrayBufferToFloatArray","multiChannelArray","deinterleave","upsampledMultiChannelArray","multiplySampleRate","Promise","node"],"mappings":"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","sourcesContent":["/* eslint no-magic-numbers: [\"error\", { \"ignore\": [0, 1, 8, 16, 32, 128, 1000, 32768, 96000, 2147483648] }] */\n/* eslint no-await-in-loop: \"off\" */\n/* eslint prefer-destructuring: \"off\" */\n\nimport cognitiveServicesAsyncFunctionToESAsyncFunction from './cognitiveServicesAsyncFunctionToESAsyncFunction';\nimport createMultiBufferingPlayer from './createMultiBufferingPlayer';\n\n// Safari requires an audio buffer with a sample rate of 22050 Hz.\n// Using a minimum sample rate of 44100 Hz as an example, the Speech SDK's default 16000 Hz will be upsampled to 48000 Hz.\nconst MIN_SAMPLE_RATE = 44100;\n\n// The Speech SDK is hardcoded to chop packets to 4096 bytes.\n// Web Chat's multi-buffering player is set up with 3 buffers; each is 4096 bytes (2048 16-bit samples).\n// For simplicity, the multi-buffer player currently does not support progressive buffering.\n\n// Progressive buffering allows queuing at any sample size and will be concatenated.\n// If 1000 samples are queued, then 1048 samples are queued, they will be concatenated into a single buffer of size 2048.\n\n// For simplicity, data will be queued to two buffers.\n// The first buffer is 1000 samples followed by 1048 zeroes, and the second buffer is 1048 samples followed by 1000 zeroes.\n\n// There is no plan to support progressive buffering until the Speech SDK chops data at dynamic size.\nconst DEFAULT_BUFFER_SIZE = 4096;\n\nfunction average(array) {\n  return array.reduce((sum, value) => sum + value, 0) / array.length;\n}\n\nfunction formatTypedBitArrayToFloatArray(audioData, maxValue) {\n  const float32Data = new Float32Array(audioData.length);\n\n  for (let i = 0; i < audioData.length; i++) {\n    float32Data[i] = audioData[i] / maxValue;\n  }\n\n  return float32Data;\n}\n\nfunction formatAudioDataArrayBufferToFloatArray({ bitsPerSample }, arrayBuffer) {\n  switch (bitsPerSample) {\n    case 8:\n      return formatTypedBitArrayToFloatArray(new Int8Array(arrayBuffer), 128);\n\n    case 16:\n      return formatTypedBitArrayToFloatArray(new Int16Array(arrayBuffer), 32768);\n\n    case 32:\n      return formatTypedBitArrayToFloatArray(new Int32Array(arrayBuffer), 2147483648);\n\n    default:\n      throw new Error('Only WAVE_FORMAT_PCM (8/16/32 bps) format supported at this time');\n  }\n}\n\nfunction abortToReject(signal) {\n  return new Promise((_, reject) => {\n    signal.onabort = () => reject(new Error('aborted'));\n  });\n}\n\n// In a 2 channel audio (e.g. A/B), the data arrives as interleaved, like \"ABABABABAB\".\n// This function will take \"ABABABABAB\" and return an array [\"AAAAA\", \"BBBBB\"].\nfunction deinterleave(channelInterleavedAudioData, { channels }) {\n  const multiChannelArrayBuffer = new Array(channels);\n  const frameSize = channelInterleavedAudioData.length / channels;\n\n  for (let channel = 0; channel < channels; channel++) {\n    const audioData = new Float32Array(frameSize);\n\n    multiChannelArrayBuffer[channel] = audioData;\n\n    for (let offset = 0; offset < frameSize; offset++) {\n      audioData[offset] = channelInterleavedAudioData[offset * channels + channel];\n    }\n  }\n\n  return multiChannelArrayBuffer;\n}\n\n// This function upsamples the audio data via an integer multiplier.\n// Web Chat uses simple anti-aliasing. For simplicity, the anti-aliasing does not roll over to next buffer.\nfunction multiplySampleRate(source, sampleRateMultiplier) {\n  if (sampleRateMultiplier === 1) {\n    return source;\n  }\n\n  const lastValues = new Array(sampleRateMultiplier).fill(source[0]);\n  const target = new Float32Array(source.length * sampleRateMultiplier);\n\n  for (let sourceOffset = 0; sourceOffset < source.length; sourceOffset++) {\n    const value = source[sourceOffset];\n    const targetOffset = sourceOffset * sampleRateMultiplier;\n\n    for (let multiplierIndex = 0; multiplierIndex < sampleRateMultiplier; multiplierIndex++) {\n      lastValues.shift();\n      lastValues.push(value);\n      target[targetOffset + multiplierIndex] = average(lastValues);\n    }\n  }\n\n  return target;\n}\n\nexport default async function playCognitiveServicesStream(audioContext, stream, { signal = {} } = {}) {\n  if (!audioContext) {\n    throw new Error('botframework-directlinespeech-sdk: audioContext must be specified.');\n  } else if (!stream) {\n    throw new Error('botframework-directlinespeech-sdk: stream must be specified.');\n  } else if (!stream.format) {\n    throw new Error('botframework-directlinespeech-sdk: stream is missing format.');\n  } else if (typeof stream.read !== 'function') {\n    throw new Error('botframework-directlinespeech-sdk: stream is missing read().');\n  }\n\n  const queuedBufferSourceNodes = [];\n\n  try {\n    const { format } = stream;\n    const abortPromise = abortToReject(signal);\n    const array = new Uint8Array(DEFAULT_BUFFER_SIZE);\n    const streamRead = cognitiveServicesAsyncFunctionToESAsyncFunction(stream.read.bind(stream));\n\n    const read = () =>\n      Promise.race([\n        // Abort will gracefully end the queue. We will check signal.aborted later to throw abort exception.\n        // eslint-disable-next-line no-empty-function\n        abortPromise.catch(() => {}),\n        streamRead(array.buffer).then(numBytes =>\n          numBytes === array.byteLength ? array : numBytes ? array.slice(0, numBytes) : undefined\n        )\n      ]);\n\n    if (signal.aborted) {\n      throw new Error('aborted');\n    }\n\n    let newSamplesPerSec = format.samplesPerSec;\n    let sampleRateMultiplier = 1;\n\n    // Safari requires a minimum sample rate of 22100 Hz.\n    // A multiplier is calculated the the data meets the minimum sample rate.\n    // An integer-based multiplier to simplify our upsampler.\n    // For security, data will only be upsampled up to 96000 Hz.\n    while (newSamplesPerSec < MIN_SAMPLE_RATE && newSamplesPerSec < 96000) {\n      sampleRateMultiplier++;\n      newSamplesPerSec = format.samplesPerSec * sampleRateMultiplier;\n    }\n\n    // The third parameter is the sample size in bytes.\n    // For example, if the Speech SDK sends Web Chat 4096 bytes of 16-bit samples, there will be 2048 samples per channel.\n    // The multi-buffering player is set up to handle 2048 samples per buffer.\n    // If the multiplier 3x, it will handle 6144 samples per buffer.\n    const player = createMultiBufferingPlayer(\n      audioContext,\n      { ...format, samplesPerSec: newSamplesPerSec },\n      (DEFAULT_BUFFER_SIZE / (format.bitsPerSample / 8)) * sampleRateMultiplier\n    );\n\n    // For security, the maximum number of chunks handled will be 1000.\n    for (\n      let chunk = await read(), maxChunks = 0;\n      chunk && maxChunks < 1000 && !signal.aborted;\n      chunk = await read(), maxChunks++\n    ) {\n      if (signal.aborted) {\n        break;\n      }\n\n      // Data received from Speech SDK is interleaved; 2 channels (e.g. A and B) will be sent as \"ABABABABAB\"\n      // And each sample (A/B) will be an 8 to 32-bit number.\n\n      // Convert the 8 - 32-bit number into a floating-point number, as required by Web Audio API.\n      const interleavedArray = formatAudioDataArrayBufferToFloatArray(format, chunk.buffer);\n\n      // Deinterleave data back into two array buffer, e.g. \"AAAAA\" and \"BBBBB\".\n      const multiChannelArray = deinterleave(interleavedArray, format);\n\n      // Upsample data if necessary. If the multiplier is 2x, \"AAAAA\" will be upsampled to \"AAAAAAAAAA\" (with anti-alias).\n      const upsampledMultiChannelArray = multiChannelArray.map(array =>\n        multiplySampleRate(array, sampleRateMultiplier)\n      );\n\n      // Queue to the buffering player.\n      player.push(upsampledMultiChannelArray);\n    }\n\n    abortPromise.catch(() => player.cancelAll());\n\n    if (signal.aborted) {\n      throw new Error('aborted');\n    }\n\n    await Promise.race([abortPromise, player.flush()]);\n  } finally {\n    queuedBufferSourceNodes.forEach(node => node.stop());\n  }\n}\n"],"sourceRoot":"directlinespeech:///"},"metadata":{},"sourceType":"script"}