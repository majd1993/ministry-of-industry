{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = useObserveScrollPosition;\n\nvar _react = require(\"react\");\n\nvar _reactScrollToBottom = require(\"react-scroll-to-bottom\");\n\nvar _useGetTranscriptScrollableElement = _interopRequireDefault(require(\"./internal/useGetTranscriptScrollableElement\"));\n\nvar _useTranscriptActivityElementsRef = _interopRequireDefault(require(\"./internal/useTranscriptActivityElementsRef\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction useObserveScrollPosition(observer, deps) {\n  var getTranscriptScrollableElement = (0, _useGetTranscriptScrollableElement.default)();\n\n  var _useTranscriptActivit = (0, _useTranscriptActivityElementsRef.default)(),\n      _useTranscriptActivit2 = _slicedToArray(_useTranscriptActivit, 1),\n      activityElementsRef = _useTranscriptActivit2[0];\n\n  if (typeof observer !== 'function') {\n    observer = undefined;\n    console.warn('botframework-webchat: First argument passed to \"useObserveScrollPosition\" must be a function.');\n  } else if (typeof deps !== 'undefined' && !Array.isArray(deps)) {\n    console.warn('botframework-webchat: Second argument passed to \"useObserveScrollPosition\" must be an array if specified.');\n  }\n\n  var effectCallback = (0, _react.useCallback)(function (_ref) {\n    var scrollTop = _ref.scrollTop;\n    var scrollable = getTranscriptScrollableElement();\n\n    var _scrollable$getClient = scrollable.getClientRects(),\n        _scrollable$getClient2 = _slicedToArray(_scrollable$getClient, 1),\n        _scrollable$getClient3 = _scrollable$getClient2[0];\n\n    _scrollable$getClient3 = _scrollable$getClient3 === void 0 ? {} : _scrollable$getClient3;\n    var offsetHeight = _scrollable$getClient3.height; // Find the activity just above scroll view bottom.\n    // If the scroll view is already on top, get the first activity.\n\n    var entry = scrollable.scrollTop ? _toConsumableArray(activityElementsRef.current).reverse().find(function (_ref2) {\n      var element = _ref2.element;\n\n      if (!element) {\n        return false;\n      }\n\n      var _element$getClientRec = element.getClientRects(),\n          _element$getClientRec2 = _slicedToArray(_element$getClientRec, 1),\n          _element$getClientRec3 = _element$getClientRec2[0];\n\n      _element$getClientRec3 = _element$getClientRec3 === void 0 ? {} : _element$getClientRec3;\n      var y = _element$getClientRec3.y;\n      return y < offsetHeight;\n    }) : activityElementsRef.current[0];\n\n    var _ref3 = entry || {},\n        activityID = _ref3.activityID;\n\n    observer && observer(_objectSpread(_objectSpread({}, activityID ? {\n      activityID: activityID\n    } : {}), {}, {\n      scrollTop: scrollTop\n    }));\n  }, // This hook is very similar to useEffect, which internally use useCallback.\n  // The \"deps\" is treated as the dependencies for the useCallback.\n\n  /* eslint-disable-next-line react-hooks/exhaustive-deps */\n  [activityElementsRef, getTranscriptScrollableElement].concat(_toConsumableArray(deps || [])));\n  (0, _reactScrollToBottom.useObserveScrollPosition)(effectCallback);\n}","map":{"version":3,"sources":["../../src/hooks/useObserveScrollPosition.js"],"names":["getTranscriptScrollableElement","activityElementsRef","observer","console","Array","effectCallback","scrollTop","scrollable","offsetHeight","entry","element","y","activityID","deps"],"mappings":"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","sourcesContent":["import { useCallback } from 'react';\nimport { useObserveScrollPosition as useScrollToBottomObserveScrollPosition } from 'react-scroll-to-bottom';\n\nimport useGetTranscriptScrollableElement from './internal/useGetTranscriptScrollableElement';\nimport useTranscriptActivityElementsRef from './internal/useTranscriptActivityElementsRef';\n\nexport default function useObserveScrollPosition(observer, deps) {\n  const getTranscriptScrollableElement = useGetTranscriptScrollableElement();\n  const [activityElementsRef] = useTranscriptActivityElementsRef();\n\n  if (typeof observer !== 'function') {\n    observer = undefined;\n    console.warn('botframework-webchat: First argument passed to \"useObserveScrollPosition\" must be a function.');\n  } else if (typeof deps !== 'undefined' && !Array.isArray(deps)) {\n    console.warn(\n      'botframework-webchat: Second argument passed to \"useObserveScrollPosition\" must be an array if specified.'\n    );\n  }\n\n  const effectCallback = useCallback(\n    ({ scrollTop }) => {\n      const scrollable = getTranscriptScrollableElement();\n      const [{ height: offsetHeight } = {}] = scrollable.getClientRects();\n\n      // Find the activity just above scroll view bottom.\n      // If the scroll view is already on top, get the first activity.\n      const entry = scrollable.scrollTop\n        ? [...activityElementsRef.current].reverse().find(({ element }) => {\n            if (!element) {\n              return false;\n            }\n\n            const [{ y } = {}] = element.getClientRects();\n\n            return y < offsetHeight;\n          })\n        : activityElementsRef.current[0];\n\n      const { activityID } = entry || {};\n\n      observer && observer({ ...(activityID ? { activityID } : {}), scrollTop });\n    },\n    // This hook is very similar to useEffect, which internally use useCallback.\n    // The \"deps\" is treated as the dependencies for the useCallback.\n    /* eslint-disable-next-line react-hooks/exhaustive-deps */\n    [activityElementsRef, getTranscriptScrollableElement, ...(deps || [])]\n  );\n\n  useScrollToBottomObserveScrollPosition(effectCallback);\n}\n"],"sourceRoot":"component:///"},"metadata":{},"sourceType":"script"}