{"ast":null,"code":"\"use strict\";\n/**\n * @module botframework-streaming\n */\n\n/**\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar headerSerializer_1 = require(\"../payloads/headerSerializer\");\n\nvar payloadConstants_1 = require(\"../payloads/payloadConstants\");\n\nvar transportDisconnectedEvent_1 = require(\"./transportDisconnectedEvent\");\n/**\n * Streaming payload sender.\n */\n\n\nvar PayloadSender =\n/** @class */\nfunction () {\n  function PayloadSender() {}\n\n  Object.defineProperty(PayloadSender.prototype, \"isConnected\", {\n    /**\n     * Tests whether the transport sender is connected.\n     *\n     * @returns true if connected to a transport sender.\n     */\n    get: function get() {\n      return !!this.sender;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Connects to the given transport sender.\n   *\n   * @param sender The transport sender to connect this payload sender to.\n   */\n\n  PayloadSender.prototype.connect = function (sender) {\n    this.sender = sender;\n  };\n  /**\n   * Sends a payload out over the connected transport sender.\n   *\n   * @param header The header to attach to the outgoing payload.\n   * @param payload The stream of buffered data to send.\n   * @param sentCalback The function to execute when the send has completed.\n   */\n\n\n  PayloadSender.prototype.sendPayload = function (header, payload, sentCallback) {\n    var packet = {\n      header: header,\n      payload: payload,\n      sentCallback: sentCallback\n    };\n    this.writePacket(packet);\n  };\n  /**\n   * Disconnects this payload sender.\n   *\n   * @param e The disconnected event arguments to include in the disconnected event broadcast.\n   */\n\n\n  PayloadSender.prototype.disconnect = function (e) {\n    if (this.isConnected) {\n      this.sender.close();\n      this.sender = null;\n\n      if (this.disconnected) {\n        this.disconnected(this, e || transportDisconnectedEvent_1.TransportDisconnectedEvent.Empty);\n      }\n    }\n  };\n\n  PayloadSender.prototype.writePacket = function (packet) {\n    try {\n      if (packet.header.payloadLength > 0 && packet.payload) {\n        var leftOver = packet.header.payloadLength;\n\n        while (leftOver > 0) {\n          var count = leftOver <= payloadConstants_1.PayloadConstants.MaxPayloadLength ? leftOver : payloadConstants_1.PayloadConstants.MaxPayloadLength;\n          var chunk = packet.payload.read(count);\n          var header = packet.header;\n          header.payloadLength = count;\n          header.end = leftOver <= payloadConstants_1.PayloadConstants.MaxPayloadLength;\n          var sendHeaderBuffer = Buffer.alloc(payloadConstants_1.PayloadConstants.MaxHeaderLength);\n          headerSerializer_1.HeaderSerializer.serialize(header, sendHeaderBuffer);\n          this.sender.send(sendHeaderBuffer);\n          this.sender.send(chunk);\n          leftOver -= chunk.length;\n        }\n\n        if (packet.sentCallback) {\n          packet.sentCallback();\n        }\n      }\n    } catch (e) {\n      this.disconnect(new transportDisconnectedEvent_1.TransportDisconnectedEvent(e.message));\n    }\n  };\n\n  return PayloadSender;\n}();\n\nexports.PayloadSender = PayloadSender;","map":{"version":3,"sources":["../../src/payloadTransport/payloadSender.ts"],"names":[],"mappings":";AAAA;;AAEG;;AACH;;;AAGG;;;;;;AAEH,IAAA,kBAAA,GAAA,OAAA,CAAA,8BAAA,CAAA;;AAEA,IAAA,kBAAA,GAAA,OAAA,CAAA,8BAAA,CAAA;;AACA,IAAA,4BAAA,GAAA,OAAA,CAAA,8BAAA,CAAA;AAMA;;AAEG;;;AACH,IAAA,aAAA;AAAA;AAAA,YAAA;AAAA,WAAA,aAAA,GAAA,CAkFC;;AAzEG,EAAA,MAAA,CAAA,cAAA,CAAW,aAAA,CAAA,SAAX,EAAW,aAAX,EAAsB;AALtB;;;;AAIG;SACH,eAAA;AACI,aAAO,CAAC,CAAC,KAAK,MAAd;AACH,KAFqB;oBAAA;;AAAA,GAAtB;AAIA;;;;AAIG;;AACI,EAAA,aAAA,CAAA,SAAA,CAAA,OAAA,GAAP,UAAe,MAAf,EAAuC;AACnC,SAAK,MAAL,GAAc,MAAd;AACH,GAFM;AAIP;;;;;;AAMG;;;AACI,EAAA,aAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,MAAnB,EAAoC,OAApC,EAAkE,YAAlE,EAAoG;AAChG,QAAI,MAAM,GAAgB;AAAC,MAAA,MAAM,EAAA,MAAP;AAAS,MAAA,OAAO,EAAA,OAAhB;AAAkB,MAAA,YAAY,EAAA;AAA9B,KAA1B;AACA,SAAK,WAAL,CAAiB,MAAjB;AACH,GAHM;AAKP;;;;AAIG;;;AACI,EAAA,aAAA,CAAA,SAAA,CAAA,UAAA,GAAP,UAAkB,CAAlB,EAAgD;AAC5C,QAAI,KAAK,WAAT,EAAsB;AAClB,WAAK,MAAL,CAAY,KAAZ;AACA,WAAK,MAAL,GAAc,IAAd;;AAEA,UAAI,KAAK,YAAT,EAAuB;AACnB,aAAK,YAAL,CAAkB,IAAlB,EAAwB,CAAC,IAAI,4BAAA,CAAA,0BAAA,CAA2B,KAAxD;AACH;AACJ;AACJ,GATM;;AAWC,EAAA,aAAA,CAAA,SAAA,CAAA,WAAA,GAAR,UAAoB,MAApB,EAAuC;AACnC,QAAI;AACA,UAAI,MAAM,CAAC,MAAP,CAAc,aAAd,GAA8B,CAA9B,IAAmC,MAAM,CAAC,OAA9C,EAAuD;AAEnD,YAAI,QAAQ,GAAG,MAAM,CAAC,MAAP,CAAc,aAA7B;;AAEA,eAAO,QAAQ,GAAG,CAAlB,EAAqB;AACjB,cAAI,KAAK,GAAG,QAAQ,IAAI,kBAAA,CAAA,gBAAA,CAAiB,gBAA7B,GAAgD,QAAhD,GAA2D,kBAAA,CAAA,gBAAA,CAAiB,gBAAxF;AACA,cAAI,KAAK,GAAG,MAAM,CAAC,OAAP,CAAe,IAAf,CAAoB,KAApB,CAAZ;AAEA,cAAI,MAAM,GAAG,MAAM,CAAC,MAApB;AACA,UAAA,MAAM,CAAC,aAAP,GAAuB,KAAvB;AACA,UAAA,MAAM,CAAC,GAAP,GAAa,QAAQ,IAAI,kBAAA,CAAA,gBAAA,CAAiB,gBAA1C;AAEA,cAAI,gBAAgB,GAAW,MAAM,CAAC,KAAP,CAAa,kBAAA,CAAA,gBAAA,CAAiB,eAA9B,CAA/B;AAEA,UAAA,kBAAA,CAAA,gBAAA,CAAiB,SAAjB,CAA2B,MAA3B,EAAmC,gBAAnC;AAEA,eAAK,MAAL,CAAY,IAAZ,CAAiB,gBAAjB;AAEA,eAAK,MAAL,CAAY,IAAZ,CAAiB,KAAjB;AACA,UAAA,QAAQ,IAAG,KAAK,CAAC,MAAjB;AACH;;AAED,YAAI,MAAM,CAAC,YAAX,EAAyB;AACrB,UAAA,MAAM,CAAC,YAAP;AACH;AACJ;AACJ,KA3BD,CA2BE,OAAO,CAAP,EAAU;AACR,WAAK,UAAL,CAAgB,IAAI,4BAAA,CAAA,0BAAJ,CAA+B,CAAC,CAAC,OAAjC,CAAhB;AACH;AACJ,GA/BO;;AAgCZ,SAAA,aAAA;AAAC,CAlFD,EAAA;;AAAa,OAAA,CAAA,aAAA,GAAA,aAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * @module botframework-streaming\n */\n/**\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar headerSerializer_1 = require(\"../payloads/headerSerializer\");\nvar payloadConstants_1 = require(\"../payloads/payloadConstants\");\nvar transportDisconnectedEvent_1 = require(\"./transportDisconnectedEvent\");\n/**\n * Streaming payload sender.\n */\nvar PayloadSender = /** @class */ (function () {\n    function PayloadSender() {\n    }\n    Object.defineProperty(PayloadSender.prototype, \"isConnected\", {\n        /**\n         * Tests whether the transport sender is connected.\n         *\n         * @returns true if connected to a transport sender.\n         */\n        get: function () {\n            return !!this.sender;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Connects to the given transport sender.\n     *\n     * @param sender The transport sender to connect this payload sender to.\n     */\n    PayloadSender.prototype.connect = function (sender) {\n        this.sender = sender;\n    };\n    /**\n     * Sends a payload out over the connected transport sender.\n     *\n     * @param header The header to attach to the outgoing payload.\n     * @param payload The stream of buffered data to send.\n     * @param sentCalback The function to execute when the send has completed.\n     */\n    PayloadSender.prototype.sendPayload = function (header, payload, sentCallback) {\n        var packet = { header: header, payload: payload, sentCallback: sentCallback };\n        this.writePacket(packet);\n    };\n    /**\n     * Disconnects this payload sender.\n     *\n     * @param e The disconnected event arguments to include in the disconnected event broadcast.\n     */\n    PayloadSender.prototype.disconnect = function (e) {\n        if (this.isConnected) {\n            this.sender.close();\n            this.sender = null;\n            if (this.disconnected) {\n                this.disconnected(this, e || transportDisconnectedEvent_1.TransportDisconnectedEvent.Empty);\n            }\n        }\n    };\n    PayloadSender.prototype.writePacket = function (packet) {\n        try {\n            if (packet.header.payloadLength > 0 && packet.payload) {\n                var leftOver = packet.header.payloadLength;\n                while (leftOver > 0) {\n                    var count = leftOver <= payloadConstants_1.PayloadConstants.MaxPayloadLength ? leftOver : payloadConstants_1.PayloadConstants.MaxPayloadLength;\n                    var chunk = packet.payload.read(count);\n                    var header = packet.header;\n                    header.payloadLength = count;\n                    header.end = leftOver <= payloadConstants_1.PayloadConstants.MaxPayloadLength;\n                    var sendHeaderBuffer = Buffer.alloc(payloadConstants_1.PayloadConstants.MaxHeaderLength);\n                    headerSerializer_1.HeaderSerializer.serialize(header, sendHeaderBuffer);\n                    this.sender.send(sendHeaderBuffer);\n                    this.sender.send(chunk);\n                    leftOver -= chunk.length;\n                }\n                if (packet.sentCallback) {\n                    packet.sentCallback();\n                }\n            }\n        }\n        catch (e) {\n            this.disconnect(new transportDisconnectedEvent_1.TransportDisconnectedEvent(e.message));\n        }\n    };\n    return PayloadSender;\n}());\nexports.PayloadSender = PayloadSender;\n//# sourceMappingURL=payloadSender.js.map"]},"metadata":{},"sourceType":"script"}