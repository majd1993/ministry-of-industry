{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createTaskQueue;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _pDeferEs = _interopRequireDefault(require(\"p-defer-es5\"));\n\nfunction createTaskQueue() {\n  var queueWithCurrent = [];\n  var queue = {\n    cancelAll: function cancelAll() {\n      queueWithCurrent.forEach(function (_ref) {\n        var cancel = _ref.cancel;\n        return cancel();\n      });\n    },\n    push: function push(fn) {\n      var cancelDeferred = (0, _pDeferEs.default)();\n      var resultDeferred = (0, _pDeferEs.default)();\n      var entry = {\n        promise: resultDeferred.promise\n      };\n      var abort;\n\n      var cancel = entry.cancel = function () {\n        // Override the \"fn\" so we don't call the actual \"fn\" later.\n        // In this approach, we can reuse the logic inside \"start\" to handle post-cancellation.\n        fn = function fn() {\n          return {\n            result: Promise.reject(new Error('cancelled before start'))\n          };\n        }; // Abort the task if it is currently running.\n\n\n        abort && abort();\n        cancelDeferred.reject(new Error('cancelled in the midway'));\n      };\n\n      var start = /*#__PURE__*/function () {\n        var _ref2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {\n          var _fn, abortFn, result;\n\n          return _regenerator.default.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _fn = fn(), abortFn = _fn.abort, result = _fn.result;\n                  abort = abortFn;\n                  _context.prev = 2;\n                  _context.t0 = resultDeferred;\n                  _context.next = 6;\n                  return Promise.race([result, cancelDeferred.promise]);\n\n                case 6:\n                  _context.t1 = _context.sent;\n\n                  _context.t0.resolve.call(_context.t0, _context.t1);\n\n                  _context.next = 13;\n                  break;\n\n                case 10:\n                  _context.prev = 10;\n                  _context.t2 = _context[\"catch\"](2);\n                  resultDeferred.reject(_context.t2);\n\n                case 13:\n                  queueWithCurrent = queueWithCurrent.filter(function (e) {\n                    return e !== entry;\n                  });\n\n                case 14:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, null, [[2, 10]]);\n        }));\n\n        return function start() {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n\n      var lastEntry = queueWithCurrent[queueWithCurrent.length - 1];\n      var lastPromise = lastEntry && lastEntry.promise || Promise.resolve();\n      queueWithCurrent.push(entry); // After the last promise resolved/rejected, we will start this task.\n      // We will start even if the last promise rejected.\n\n      lastPromise.then(start, start);\n      return {\n        cancel: cancel,\n        result: resultDeferred.promise\n      };\n    }\n  };\n  Object.defineProperty(queue, 'length', {\n    get: function get() {\n      return queueWithCurrent.length;\n    }\n  });\n  return queue;\n}","map":{"version":3,"sources":["../src/createTaskQueue.js"],"names":["queueWithCurrent","queue","cancelAll","cancel","push","cancelDeferred","resultDeferred","entry","promise","fn","result","Promise","abort","start","abortFn","e","lastEntry","lastPromise","Object","get"],"mappings":"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","sourcesContent":["import createDeferred from 'p-defer-es5';\n\nexport default function createTaskQueue() {\n  let queueWithCurrent = [];\n\n  const queue = {\n    cancelAll: () => {\n      queueWithCurrent.forEach(({ cancel }) => cancel());\n    },\n    push: fn => {\n      const cancelDeferred = createDeferred();\n      const resultDeferred = createDeferred();\n      const entry = { promise: resultDeferred.promise };\n      let abort;\n\n      const cancel = (entry.cancel = () => {\n        // Override the \"fn\" so we don't call the actual \"fn\" later.\n        // In this approach, we can reuse the logic inside \"start\" to handle post-cancellation.\n        fn = () => ({ result: Promise.reject(new Error('cancelled before start')) });\n\n        // Abort the task if it is currently running.\n        abort && abort();\n        cancelDeferred.reject(new Error('cancelled in the midway'));\n      });\n\n      const start = async () => {\n        const { abort: abortFn, result } = fn();\n\n        abort = abortFn;\n\n        try {\n          // Either wait for the actual result, or the task is being cancelled.\n          resultDeferred.resolve(await Promise.race([result, cancelDeferred.promise]));\n        } catch (error) {\n          resultDeferred.reject(error);\n        }\n\n        queueWithCurrent = queueWithCurrent.filter(e => e !== entry);\n      };\n\n      const lastEntry = queueWithCurrent[queueWithCurrent.length - 1];\n      const lastPromise = (lastEntry && lastEntry.promise) || Promise.resolve();\n\n      queueWithCurrent.push(entry);\n\n      // After the last promise resolved/rejected, we will start this task.\n      // We will start even if the last promise rejected.\n      lastPromise.then(start, start);\n\n      return {\n        cancel,\n        result: resultDeferred.promise\n      };\n    }\n  };\n\n  Object.defineProperty(queue, 'length', { get: () => queueWithCurrent.length });\n\n  return queue;\n}\n"],"sourceRoot":"directlinespeech:///"},"metadata":{},"sourceType":"script"}