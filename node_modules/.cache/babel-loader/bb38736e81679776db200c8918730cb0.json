{"ast":null,"code":"import _classCallCheck from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { InvalidOperationError } from \"./Error\";\nimport { createNoDashGuid } from \"./Guid\";\nimport { Queue } from \"./Queue\";\nexport var Stream = /*#__PURE__*/function () {\n  function Stream(streamId) {\n    var _this = this;\n\n    _classCallCheck(this, Stream);\n\n    this.privIsWriteEnded = false;\n    this.privIsReadEnded = false;\n\n    this.read = function () {\n      if (_this.privIsReadEnded) {\n        throw new InvalidOperationError(\"Stream read has already finished\");\n      }\n\n      return _this.privReaderQueue.dequeue().onSuccessContinueWith(function (streamChunk) {\n        if (streamChunk === undefined || streamChunk.isEnd) {\n          _this.privReaderQueue.dispose(\"End of stream reached\");\n        }\n\n        return streamChunk;\n      });\n    };\n\n    this.readEnded = function () {\n      if (!_this.privIsReadEnded) {\n        _this.privIsReadEnded = true;\n        _this.privReaderQueue = new Queue();\n      }\n    };\n\n    this.throwIfClosed = function () {\n      if (_this.privIsWriteEnded) {\n        throw new InvalidOperationError(\"Stream closed\");\n      }\n    };\n\n    this.privId = streamId ? streamId : createNoDashGuid();\n    this.privReaderQueue = new Queue();\n  }\n\n  _createClass(Stream, [{\n    key: \"isClosed\",\n    get: function get() {\n      return this.privIsWriteEnded;\n    }\n  }, {\n    key: \"isReadEnded\",\n    get: function get() {\n      return this.privIsReadEnded;\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this.privId;\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (!this.privIsWriteEnded) {\n        this.writeStreamChunk({\n          buffer: null,\n          isEnd: true,\n          timeReceived: Date.now()\n        });\n        this.privIsWriteEnded = true;\n      }\n    }\n  }, {\n    key: \"writeStreamChunk\",\n    value: function writeStreamChunk(streamChunk) {\n      this.throwIfClosed();\n\n      if (!this.privReaderQueue.isDisposed()) {\n        try {\n          this.privReaderQueue.enqueue(streamChunk);\n        } catch (e) {// Do nothing\n        }\n      }\n    }\n  }]);\n\n  return Stream;\n}();","map":{"version":3,"sources":["src/common/Stream.ts"],"names":[],"mappings":";;AAAA;AACA;AAEA,SAAS,qBAAT,QAAsC,SAAtC;AACA,SAAS,gBAAT,QAAiC,QAAjC;AAEA,SAAS,KAAT,QAAsB,SAAtB;AAQA,WAAa,MAAb;AAMI,kBAAmB,QAAnB,EAAoC;AAAA;;AAAA;;AAJ5B,SAAA,gBAAA,GAA4B,KAA5B;AACA,SAAA,eAAA,GAA2B,KAA3B;;AA0CD,SAAA,IAAA,GAAO,YAAqC;AAC/C,UAAI,KAAI,CAAC,eAAT,EAA0B;AACtB,cAAM,IAAI,qBAAJ,CAA0B,kCAA1B,CAAN;AACH;;AAED,aAAO,KAAI,CAAC,eAAL,CACF,OADE,GAEF,qBAFE,CAEoB,UAAC,WAAD,EAAuC;AAC1D,YAAI,WAAW,KAAK,SAAhB,IAA6B,WAAW,CAAC,KAA7C,EAAoD;AAChD,UAAA,KAAI,CAAC,eAAL,CAAqB,OAArB,CAA6B,uBAA7B;AACH;;AAED,eAAO,WAAP;AACH,OARE,CAAP;AASH,KAdM;;AAgBA,SAAA,SAAA,GAAY,YAAW;AAC1B,UAAI,CAAC,KAAI,CAAC,eAAV,EAA2B;AACvB,QAAA,KAAI,CAAC,eAAL,GAAuB,IAAvB;AACA,QAAA,KAAI,CAAC,eAAL,GAAuB,IAAI,KAAJ,EAAvB;AACH;AACJ,KALM;;AAOC,SAAA,aAAA,GAAgB,YAAW;AAC/B,UAAI,KAAI,CAAC,gBAAT,EAA2B;AACvB,cAAM,IAAI,qBAAJ,CAA0B,eAA1B,CAAN;AACH;AACJ,KAJO;;AA7DJ,SAAK,MAAL,GAAc,QAAQ,GAAG,QAAH,GAAc,gBAAgB,EAApD;AACA,SAAK,eAAL,GAAuB,IAAI,KAAJ,EAAvB;AACH;;AATL;AAAA;AAAA,SAWI,eAAmB;AACf,aAAO,KAAK,gBAAZ;AACH;AAbL;AAAA;AAAA,SAeI,eAAsB;AAClB,aAAO,KAAK,eAAZ;AACH;AAjBL;AAAA;AAAA,SAmBI,eAAa;AACT,aAAO,KAAK,MAAZ;AACH;AArBL;AAAA;AAAA,WAuBW,iBAAK;AACR,UAAI,CAAC,KAAK,gBAAV,EAA4B;AACxB,aAAK,gBAAL,CAAsB;AAClB,UAAA,MAAM,EAAE,IADU;AAElB,UAAA,KAAK,EAAE,IAFW;AAGlB,UAAA,YAAY,EAAE,IAAI,CAAC,GAAL;AAHI,SAAtB;AAKA,aAAK,gBAAL,GAAwB,IAAxB;AACH;AACJ;AAhCL;AAAA;AAAA,WAkCW,0BAAiB,WAAjB,EAAmD;AACtD,WAAK,aAAL;;AACA,UAAI,CAAC,KAAK,eAAL,CAAqB,UAArB,EAAL,EAAwC;AACpC,YAAI;AACA,eAAK,eAAL,CAAqB,OAArB,CAA6B,WAA7B;AACH,SAFD,CAEE,OAAO,CAAP,EAAU,CACR;AACH;AACJ;AACJ;AA3CL;;AAAA;AAAA","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { InvalidOperationError } from \"./Error\";\r\nimport { createNoDashGuid } from \"./Guid\";\r\nimport { Promise } from \"./Promise\";\r\nimport { Queue } from \"./Queue\";\r\n\r\nexport interface IStreamChunk<TBuffer> {\r\n    isEnd: boolean;\r\n    buffer: TBuffer;\r\n    timeReceived: number;\r\n}\r\n\r\nexport class Stream<TBuffer> {\r\n    private privId: string;\r\n    private privIsWriteEnded: boolean = false;\r\n    private privIsReadEnded: boolean = false;\r\n    private privReaderQueue: Queue<IStreamChunk<TBuffer>>;\r\n\r\n    public constructor(streamId?: string) {\r\n        this.privId = streamId ? streamId : createNoDashGuid();\r\n        this.privReaderQueue = new Queue<IStreamChunk<TBuffer>>();\r\n    }\r\n\r\n    public get isClosed(): boolean {\r\n        return this.privIsWriteEnded;\r\n    }\r\n\r\n    public get isReadEnded(): boolean {\r\n        return this.privIsReadEnded;\r\n    }\r\n\r\n    public get id(): string {\r\n        return this.privId;\r\n    }\r\n\r\n    public close(): void {\r\n        if (!this.privIsWriteEnded) {\r\n            this.writeStreamChunk({\r\n                buffer: null,\r\n                isEnd: true,\r\n                timeReceived: Date.now(),\r\n            });\r\n            this.privIsWriteEnded = true;\r\n        }\r\n    }\r\n\r\n    public writeStreamChunk(streamChunk: IStreamChunk<TBuffer>): void {\r\n        this.throwIfClosed();\r\n        if (!this.privReaderQueue.isDisposed()) {\r\n            try {\r\n                this.privReaderQueue.enqueue(streamChunk);\r\n            } catch (e) {\r\n                // Do nothing\r\n            }\r\n        }\r\n    }\r\n\r\n    public read = (): Promise<IStreamChunk<TBuffer>> => {\r\n        if (this.privIsReadEnded) {\r\n            throw new InvalidOperationError(\"Stream read has already finished\");\r\n        }\r\n\r\n        return this.privReaderQueue\r\n            .dequeue()\r\n            .onSuccessContinueWith((streamChunk: IStreamChunk<TBuffer>) => {\r\n                if (streamChunk === undefined || streamChunk.isEnd) {\r\n                    this.privReaderQueue.dispose(\"End of stream reached\");\r\n                }\r\n\r\n                return streamChunk;\r\n            });\r\n    }\r\n\r\n    public readEnded = (): void => {\r\n        if (!this.privIsReadEnded) {\r\n            this.privIsReadEnded = true;\r\n            this.privReaderQueue = new Queue<IStreamChunk<TBuffer>>();\r\n        }\r\n    }\r\n\r\n    private throwIfClosed = (): void => {\r\n        if (this.privIsWriteEnded) {\r\n            throw new InvalidOperationError(\"Stream closed\");\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}