{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Exports_1 = require(\"../common.browser/Exports\");\n\nvar Exports_2 = require(\"../common/Exports\");\n\nvar Exports_3 = require(\"../sdk/Exports\");\n\nvar DialogServiceTurnStateManager_1 = require(\"./DialogServiceTurnStateManager\");\n\nvar Exports_4 = require(\"./Exports\");\n\nvar ActivityResponsePayload_1 = require(\"./ServiceMessages/ActivityResponsePayload\");\n\nvar SpeechConnectionMessage_Internal_1 = require(\"./SpeechConnectionMessage.Internal\");\n\nvar DialogServiceAdapter =\n/** @class */\nfunction (_super) {\n  __extends(DialogServiceAdapter, _super);\n\n  function DialogServiceAdapter(authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector) {\n    var _this = _super.call(this, authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector) || this;\n\n    _this.sendMessage = function (message) {\n      var interactionGuid = Exports_2.createGuid();\n      var requestId = Exports_2.createNoDashGuid();\n      var agentMessage = {\n        context: {\n          interactionId: interactionGuid\n        },\n        messagePayload: JSON.parse(message),\n        version: 0.5\n      };\n      var agentMessageJson = JSON.stringify(agentMessage);\n\n      _this.fetchDialogConnection().onSuccessContinueWith(function (connection) {\n        connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_2.MessageType.Text, \"agent\", requestId, \"application/json\", agentMessageJson));\n      });\n    };\n\n    _this.listenOnce = function (recoMode, successCallback, errorCallback) {\n      _this.privRecognizerConfig.recognitionMode = recoMode;\n      _this.privSuccessCallback = successCallback;\n      _this.privErrorCallback = errorCallback;\n\n      _this.privDialogRequestSession.startNewRecognition();\n\n      _this.privDialogRequestSession.listenForServiceTelemetry(_this.privDialogAudioSource.events); // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().\n\n\n      _this.dialogConnectImpl();\n\n      _this.sendPreAudioMessages();\n\n      return _this.privDialogAudioSource.attach(_this.privDialogRequestSession.audioNodeId).continueWithPromise(function (result) {\n        var audioNode;\n\n        if (result.isError) {\n          _this.cancelRecognition(_this.privDialogRequestSession.sessionId, _this.privDialogRequestSession.requestId, Exports_3.CancellationReason.Error, Exports_3.CancellationErrorCode.ConnectionFailure, result.error);\n\n          return Exports_2.PromiseHelper.fromError(result.error);\n        }\n\n        return _this.privDialogAudioSource.format.onSuccessContinueWithPromise(function (format) {\n          audioNode = new Exports_1.ReplayableAudioNode(result.result, format.avgBytesPerSec);\n\n          _this.privDialogRequestSession.onAudioSourceAttachCompleted(audioNode, false);\n\n          return _this.privDialogAudioSource.deviceInfo.onSuccessContinueWithPromise(function (deviceInfo) {\n            _this.privRecognizerConfig.SpeechServiceConfig.Context.audio = {\n              source: deviceInfo\n            };\n            return _this.configConnection().continueWithPromise(function (result) {\n              if (result.isError) {\n                _this.cancelRecognitionLocal(Exports_3.CancellationReason.Error, Exports_3.CancellationErrorCode.ConnectionFailure, result.error);\n\n                return Exports_2.PromiseHelper.fromError(result.error);\n              }\n\n              var sessionStartEventArgs = new Exports_3.SessionEventArgs(_this.privDialogRequestSession.sessionId);\n\n              if (!!_this.privRecognizer.sessionStarted) {\n                _this.privRecognizer.sessionStarted(_this.privRecognizer, sessionStartEventArgs);\n              }\n\n              var audioSendPromise = _this.sendAudio(audioNode); // /* tslint:disable:no-empty */\n\n\n              audioSendPromise.on(function (_) {}, function (error) {\n                _this.cancelRecognition(_this.privDialogRequestSession.sessionId, _this.privDialogRequestSession.requestId, Exports_3.CancellationReason.Error, Exports_3.CancellationErrorCode.RuntimeError, error);\n              });\n              return Exports_2.PromiseHelper.fromResult(true);\n            });\n          });\n        });\n      });\n    };\n\n    _this.sendAudio = function (audioStreamNode) {\n      return _this.privDialogAudioSource.format.onSuccessContinueWithPromise(function (audioFormat) {\n        // NOTE: Home-baked promises crash ios safari during the invocation\n        // of the error callback chain (looks like the recursion is way too deep, and\n        // it blows up the stack). The following construct is a stop-gap that does not\n        // bubble the error up the callback chain and hence circumvents this problem.\n        // TODO: rewrite with ES6 promises.\n        var deferred = new Exports_2.Deferred(); // The time we last sent data to the service.\n\n        var nextSendTime = Date.now(); // Max amount to send before we start to throttle\n\n        var fastLaneSizeMs = _this.privRecognizerConfig.parameters.getProperty(\"SPEECH-TransmitLengthBeforThrottleMs\", \"5000\");\n\n        var maxSendUnthrottledBytes = audioFormat.avgBytesPerSec / 1000 * parseInt(fastLaneSizeMs, 10);\n        var startRecogNumber = _this.privDialogRequestSession.recogNumber;\n\n        var readAndUploadCycle = function readAndUploadCycle() {\n          // If speech is done, stop sending audio.\n          if (!_this.privDialogIsDisposed && !_this.privDialogRequestSession.isSpeechEnded && _this.privDialogRequestSession.isRecognizing && _this.privDialogRequestSession.recogNumber === startRecogNumber) {\n            _this.fetchDialogConnection().on(function (connection) {\n              audioStreamNode.read().on(function (audioStreamChunk) {\n                // we have a new audio chunk to upload.\n                if (_this.privDialogRequestSession.isSpeechEnded) {\n                  // If service already recognized audio end then don't send any more audio\n                  deferred.resolve(true);\n                  return;\n                }\n\n                var payload;\n                var sendDelay;\n\n                if (!audioStreamChunk || audioStreamChunk.isEnd) {\n                  payload = null;\n                  sendDelay = 0;\n                } else {\n                  payload = audioStreamChunk.buffer;\n\n                  _this.privDialogRequestSession.onAudioSent(payload.byteLength);\n\n                  if (maxSendUnthrottledBytes >= _this.privDialogRequestSession.bytesSent) {\n                    sendDelay = 0;\n                  } else {\n                    sendDelay = Math.max(0, nextSendTime - Date.now());\n                  }\n                } // Are we ready to send, or need we delay more?\n\n\n                setTimeout(function () {\n                  if (payload !== null) {\n                    nextSendTime = Date.now() + payload.byteLength * 1000 / (audioFormat.avgBytesPerSec * 2);\n                  }\n\n                  var uploaded = connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_2.MessageType.Binary, \"audio\", _this.privDialogRequestSession.requestId, null, payload));\n\n                  if (audioStreamChunk && !audioStreamChunk.isEnd) {\n                    uploaded.continueWith(function (_) {\n                      // Regardless of success or failure, schedule the next upload.\n                      // If the underlying connection was broken, the next cycle will\n                      // get a new connection and re-transmit missing audio automatically.\n                      readAndUploadCycle();\n                    });\n                  } else {\n                    // the audio stream has been closed, no need to schedule next\n                    // read-upload cycle.\n                    _this.privDialogRequestSession.onSpeechEnded();\n\n                    deferred.resolve(true);\n                  }\n                }, sendDelay);\n              }, function (error) {\n                if (_this.privDialogRequestSession.isSpeechEnded) {\n                  // For whatever reason, Reject is used to remove queue subscribers inside\n                  // the Queue.DrainAndDispose invoked from DetachAudioNode down below, which\n                  // means that sometimes things can be rejected in normal circumstances, without\n                  // any errors.\n                  deferred.resolve(true); // TODO: remove the argument, it's is completely meaningless.\n                } else {\n                  // Only reject, if there was a proper error.\n                  deferred.reject(error);\n                }\n              });\n            }, function (error) {\n              deferred.reject(error);\n            });\n          }\n        };\n\n        readAndUploadCycle();\n        return deferred.promise();\n      });\n    };\n\n    _this.receiveDialogMessageOverride = function () {\n      // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\n      var communicationCustodian = new Exports_2.Deferred();\n\n      _this.fetchDialogConnection().on(function (connection) {\n        return connection.read().onSuccessContinueWithPromise(function (message) {\n          var isDisposed = _this.isDisposed();\n\n          var terminateMessageLoop = !_this.isDisposed() && _this.terminateMessageLoop;\n\n          if (isDisposed || terminateMessageLoop) {\n            // We're done.\n            communicationCustodian.resolve(undefined);\n            return Exports_2.PromiseHelper.fromResult(undefined);\n          }\n\n          if (!message) {\n            return _this.receiveDialogMessageOverride();\n          }\n\n          var connectionMessage = SpeechConnectionMessage_Internal_1.SpeechConnectionMessage.fromConnectionMessage(message);\n\n          switch (connectionMessage.path.toLowerCase()) {\n            case \"turn.start\":\n              {\n                var turnRequestId = connectionMessage.requestId.toUpperCase();\n\n                var audioSessionReqId = _this.privDialogRequestSession.requestId.toUpperCase(); // turn started by the service\n\n\n                if (turnRequestId !== audioSessionReqId) {\n                  _this.privTurnStateManager.StartTurn(turnRequestId);\n                } else {\n                  _this.privDialogRequestSession.onServiceTurnStartResponse();\n                }\n              }\n              break;\n\n            case \"speech.startdetected\":\n              var speechStartDetected = Exports_4.SpeechDetected.fromJSON(connectionMessage.textBody);\n              var speechStartEventArgs = new Exports_3.RecognitionEventArgs(speechStartDetected.Offset, _this.privDialogRequestSession.sessionId);\n\n              if (!!_this.privRecognizer.speechStartDetected) {\n                _this.privRecognizer.speechStartDetected(_this.privRecognizer, speechStartEventArgs);\n              }\n\n              break;\n\n            case \"speech.enddetected\":\n              var json = void 0;\n\n              if (connectionMessage.textBody.length > 0) {\n                json = connectionMessage.textBody;\n              } else {\n                // If the request was empty, the JSON returned is empty.\n                json = \"{ Offset: 0 }\";\n              }\n\n              var speechStopDetected = Exports_4.SpeechDetected.fromJSON(json);\n\n              _this.privDialogRequestSession.onServiceRecognized(speechStopDetected.Offset + _this.privDialogRequestSession.currentTurnAudioOffset);\n\n              var speechStopEventArgs = new Exports_3.RecognitionEventArgs(speechStopDetected.Offset + _this.privDialogRequestSession.currentTurnAudioOffset, _this.privDialogRequestSession.sessionId);\n\n              if (!!_this.privRecognizer.speechEndDetected) {\n                _this.privRecognizer.speechEndDetected(_this.privRecognizer, speechStopEventArgs);\n              }\n\n              break;\n\n            case \"turn.end\":\n              {\n                var turnEndRequestId = connectionMessage.requestId.toUpperCase();\n\n                var audioSessionReqId = _this.privDialogRequestSession.requestId.toUpperCase(); // turn started by the service\n\n\n                if (turnEndRequestId !== audioSessionReqId) {\n                  _this.privTurnStateManager.CompleteTurn(turnEndRequestId);\n                } else {\n                  // Audio session turn\n                  var sessionStopEventArgs = new Exports_3.SessionEventArgs(_this.privDialogRequestSession.sessionId);\n\n                  _this.privDialogRequestSession.onServiceTurnEndResponse(false);\n\n                  if (_this.privDialogRequestSession.isSpeechEnded) {\n                    if (!!_this.privRecognizer.sessionStopped) {\n                      _this.privRecognizer.sessionStopped(_this.privRecognizer, sessionStopEventArgs);\n                    }\n                  } // report result to promise.\n\n\n                  if (!!_this.privSuccessCallback && _this.privLastResult) {\n                    try {\n                      _this.privSuccessCallback(_this.privLastResult);\n\n                      _this.privLastResult = null;\n                    } catch (e) {\n                      if (!!_this.privErrorCallback) {\n                        _this.privErrorCallback(e);\n                      }\n                    } // Only invoke the call back once.\n                    // and if it's successful don't invoke the\n                    // error after that.\n\n\n                    _this.privSuccessCallback = undefined;\n                    _this.privErrorCallback = undefined;\n                  }\n                }\n              }\n              break;\n\n            default:\n              if (!_this.processTypeSpecificMessages(connectionMessage)) {\n                if (!!_this.serviceEvents) {\n                  _this.serviceEvents.onEvent(new Exports_2.ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\n                }\n              }\n\n          }\n\n          return _this.receiveDialogMessageOverride();\n        });\n      }, function (error) {\n        _this.terminateMessageLoop = true;\n        communicationCustodian.resolve(undefined);\n        return Exports_2.PromiseHelper.fromResult(undefined);\n      });\n\n      return communicationCustodian.promise();\n    };\n\n    _this.fetchDialogConnection = function () {\n      return _this.configConnection();\n    };\n\n    _this.sendAgentConfig = function (connection) {\n      if (_this.agentConfig && !_this.agentConfigSent) {\n        if (_this.privRecognizerConfig.parameters.getProperty(Exports_3.PropertyId.Conversation_DialogType) === \"custom_commands\") {\n          var config = _this.agentConfig.get();\n\n          config.botInfo.commandsCulture = _this.privRecognizerConfig.parameters.getProperty(Exports_3.PropertyId.SpeechServiceConnection_RecoLanguage, \"en-us\");\n\n          _this.agentConfig.set(config);\n        }\n\n        var agentConfigJson = _this.agentConfig.toJsonString(); // guard against sending this multiple times on one connection\n\n\n        _this.agentConfigSent = true;\n        return connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_2.MessageType.Text, \"agent.config\", _this.privDialogRequestSession.requestId, \"application/json\", agentConfigJson));\n      }\n\n      return Exports_2.PromiseHelper.fromResult(true);\n    };\n\n    _this.sendAgentContext = function (connection) {\n      var guid = Exports_2.createGuid();\n\n      var speechActivityTemplate = _this.privDialogServiceConnector.properties.getProperty(Exports_3.PropertyId.Conversation_Speech_Activity_Template);\n\n      var agentContext = {\n        channelData: \"\",\n        context: {\n          interactionId: guid\n        },\n        messagePayload: typeof speechActivityTemplate === undefined ? undefined : speechActivityTemplate,\n        version: 0.5\n      };\n      var agentContextJson = JSON.stringify(agentContext);\n      return connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_2.MessageType.Text, \"speech.agent.context\", _this.privDialogRequestSession.requestId, \"application/json\", agentContextJson));\n    };\n\n    _this.privDialogServiceConnector = dialogServiceConnector;\n    _this.privDialogAuthentication = authentication;\n    _this.receiveMessageOverride = _this.receiveDialogMessageOverride;\n    _this.privTurnStateManager = new DialogServiceTurnStateManager_1.DialogServiceTurnStateManager();\n    _this.recognizeOverride = _this.listenOnce;\n    _this.connectImplOverride = _this.dialogConnectImpl;\n    _this.configConnectionOverride = _this.configConnection;\n    _this.fetchConnectionOverride = _this.fetchDialogConnection;\n    _this.disconnectOverride = _this.privDisconnect;\n    _this.privDialogAudioSource = audioSource;\n    _this.privDialogRequestSession = new Exports_4.RequestSession(audioSource.id());\n    _this.privDialogConnectionFactory = connectionFactory;\n    _this.privDialogIsDisposed = false;\n    _this.agentConfigSent = false;\n    _this.privLastResult = null;\n    return _this;\n  }\n\n  DialogServiceAdapter.prototype.isDisposed = function () {\n    return this.privDialogIsDisposed;\n  };\n\n  DialogServiceAdapter.prototype.dispose = function (reason) {\n    this.privDialogIsDisposed = true;\n\n    if (this.privConnectionConfigPromise) {\n      this.privConnectionConfigPromise.onSuccessContinueWith(function (connection) {\n        connection.dispose(reason);\n      });\n    }\n  };\n\n  DialogServiceAdapter.prototype.privDisconnect = function () {\n    this.cancelRecognition(this.privDialogRequestSession.sessionId, this.privDialogRequestSession.requestId, Exports_3.CancellationReason.Error, Exports_3.CancellationErrorCode.NoError, \"Disconnecting\");\n    this.terminateMessageLoop = true;\n    this.agentConfigSent = false;\n\n    if (this.privDialogConnectionPromise.result().isCompleted) {\n      if (!this.privDialogConnectionPromise.result().isError) {\n        this.privDialogConnectionPromise.result().result.dispose();\n        this.privDialogConnectionPromise = null;\n      }\n    } else {\n      this.privDialogConnectionPromise.onSuccessContinueWith(function (connection) {\n        connection.dispose();\n      });\n    }\n  };\n\n  DialogServiceAdapter.prototype.processTypeSpecificMessages = function (connectionMessage) {\n    var resultProps = new Exports_3.PropertyCollection();\n\n    if (connectionMessage.messageType === Exports_2.MessageType.Text) {\n      resultProps.setProperty(Exports_3.PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\n    }\n\n    var result;\n    var processed;\n\n    switch (connectionMessage.path.toLowerCase()) {\n      case \"speech.phrase\":\n        var speechPhrase = Exports_4.SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);\n        this.privDialogRequestSession.onPhraseRecognized(this.privDialogRequestSession.currentTurnAudioOffset + speechPhrase.Offset + speechPhrase.Duration);\n\n        if (speechPhrase.RecognitionStatus === Exports_4.RecognitionStatus.Success) {\n          var args = this.fireEventForResult(speechPhrase, resultProps);\n          this.privLastResult = args.result;\n\n          if (!!this.privDialogServiceConnector.recognized) {\n            try {\n              this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, args);\n              /* tslint:disable:no-empty */\n            } catch (error) {// Not going to let errors in the event handler\n              // trip things up.\n            }\n          }\n        }\n\n        processed = true;\n        break;\n\n      case \"speech.hypothesis\":\n        var hypothesis = Exports_4.SpeechHypothesis.fromJSON(connectionMessage.textBody);\n        var offset = hypothesis.Offset + this.privDialogRequestSession.currentTurnAudioOffset;\n        result = new Exports_3.SpeechRecognitionResult(this.privDialogRequestSession.requestId, Exports_3.ResultReason.RecognizingSpeech, hypothesis.Text, hypothesis.Duration, offset, hypothesis.Language, hypothesis.LanguageDetectionConfidence, undefined, connectionMessage.textBody, resultProps);\n        this.privDialogRequestSession.onHypothesis(offset);\n        var ev = new Exports_3.SpeechRecognitionEventArgs(result, hypothesis.Duration, this.privDialogRequestSession.sessionId);\n\n        if (!!this.privDialogServiceConnector.recognizing) {\n          try {\n            this.privDialogServiceConnector.recognizing(this.privDialogServiceConnector, ev);\n            /* tslint:disable:no-empty */\n          } catch (error) {// Not going to let errors in the event handler\n            // trip things up.\n          }\n        }\n\n        processed = true;\n        break;\n\n      case \"audio\":\n        {\n          var audioRequestId = connectionMessage.requestId.toUpperCase();\n          var turn = this.privTurnStateManager.GetTurn(audioRequestId);\n\n          try {\n            // Empty binary message signals end of stream.\n            if (!connectionMessage.binaryBody) {\n              turn.endAudioStream();\n            } else {\n              turn.audioStream.write(connectionMessage.binaryBody);\n            }\n          } catch (error) {// Not going to let errors in the event handler\n            // trip things up.\n          }\n        }\n        processed = true;\n        break;\n\n      case \"response\":\n        {\n          var responseRequestId = connectionMessage.requestId.toUpperCase();\n          var activityPayload = ActivityResponsePayload_1.ActivityPayloadResponse.fromJSON(connectionMessage.textBody);\n          var turn = this.privTurnStateManager.GetTurn(responseRequestId); // update the conversation Id\n\n          if (activityPayload.conversationId) {\n            var updateAgentConfig = this.agentConfig.get();\n            updateAgentConfig.botInfo.conversationId = activityPayload.conversationId;\n            this.agentConfig.set(updateAgentConfig);\n          }\n\n          var pullAudioOutputStream = turn.processActivityPayload(activityPayload, Exports_3.SpeechSynthesisOutputFormat[this.privDialogServiceConnector.properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)]);\n          var activity = new Exports_3.ActivityReceivedEventArgs(activityPayload.messagePayload, pullAudioOutputStream);\n\n          if (!!this.privDialogServiceConnector.activityReceived) {\n            try {\n              this.privDialogServiceConnector.activityReceived(this.privDialogServiceConnector, activity);\n              /* tslint:disable:no-empty */\n            } catch (error) {// Not going to let errors in the event handler\n              // trip things up.\n            }\n          }\n        }\n        processed = true;\n        break;\n\n      default:\n        break;\n    }\n\n    return processed;\n  }; // Cancels recognition.\n\n\n  DialogServiceAdapter.prototype.cancelRecognition = function (sessionId, requestId, cancellationReason, errorCode, error) {\n    this.terminateMessageLoop = true;\n\n    if (!!this.privDialogRequestSession.isRecognizing) {\n      this.privDialogRequestSession.onStopRecognizing();\n    }\n\n    if (!!this.privDialogServiceConnector.canceled) {\n      var properties = new Exports_3.PropertyCollection();\n      properties.setProperty(Exports_4.CancellationErrorCodePropertyName, Exports_3.CancellationErrorCode[errorCode]);\n      var cancelEvent = new Exports_3.SpeechRecognitionCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);\n\n      try {\n        this.privDialogServiceConnector.canceled(this.privDialogServiceConnector, cancelEvent);\n        /* tslint:disable:no-empty */\n      } catch (_a) {}\n\n      if (!!this.privSuccessCallback) {\n        var result = new Exports_3.SpeechRecognitionResult(undefined, // ResultId\n        Exports_3.ResultReason.Canceled, undefined, // Text\n        undefined, // Druation\n        undefined, // Offset\n        undefined, // Language\n        undefined, // Language Detection Confidence\n        error, undefined, // Json\n        properties);\n\n        try {\n          this.privSuccessCallback(result);\n          this.privSuccessCallback = undefined;\n          /* tslint:disable:no-empty */\n        } catch (_b) {}\n      }\n    }\n  };\n\n  DialogServiceAdapter.prototype.sendWaveHeader = function (connection) {\n    var _this = this;\n\n    return this.audioSource.format.onSuccessContinueWithPromise(function (format) {\n      return connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_2.MessageType.Binary, \"audio\", _this.privDialogRequestSession.requestId, \"audio/x-wav\", format.header));\n    });\n  }; // Establishes a websocket connection to the end point.\n\n\n  DialogServiceAdapter.prototype.dialogConnectImpl = function (isUnAuthorized) {\n    var _this = this;\n\n    if (isUnAuthorized === void 0) {\n      isUnAuthorized = false;\n    }\n\n    if (this.privDialogConnectionPromise) {\n      if (this.privDialogConnectionPromise.result().isCompleted && (this.privDialogConnectionPromise.result().isError || this.privDialogConnectionPromise.result().result.state() === Exports_2.ConnectionState.Disconnected)) {\n        this.agentConfigSent = false;\n        this.privDialogConnectionPromise = null;\n        this.terminateMessageLoop = true;\n        return this.configConnection();\n      } else {\n        return this.privDialogConnectionPromise;\n      }\n    }\n\n    this.privDialogAuthFetchEventId = Exports_2.createNoDashGuid(); // keep the connectionId for reconnect events\n\n    if (this.privConnectionId === undefined) {\n      this.privConnectionId = Exports_2.createNoDashGuid();\n    }\n\n    this.privDialogRequestSession.onPreConnectionStart(this.privDialogAuthFetchEventId, this.privConnectionId);\n    var authPromise = isUnAuthorized ? this.privDialogAuthentication.fetchOnExpiry(this.privDialogAuthFetchEventId) : this.privDialogAuthentication.fetch(this.privDialogAuthFetchEventId);\n    this.privDialogConnectionPromise = authPromise.continueWithPromise(function (result) {\n      if (result.isError) {\n        _this.privDialogRequestSession.onAuthCompleted(true, result.error);\n\n        throw new Error(result.error);\n      } else {\n        _this.privDialogRequestSession.onAuthCompleted(false);\n      }\n\n      var connection = _this.privDialogConnectionFactory.create(_this.privRecognizerConfig, result.result, _this.privConnectionId);\n\n      _this.privDialogRequestSession.listenForServiceTelemetry(connection.events); // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\n      // it'll stop sending events.\n\n\n      connection.events.attach(function (event) {\n        _this.connectionEvents.onEvent(event);\n      });\n      return connection.open().onSuccessContinueWithPromise(function (response) {\n        if (response.statusCode === 200) {\n          _this.privDialogRequestSession.onPreConnectionStart(_this.privDialogAuthFetchEventId, _this.privConnectionId);\n\n          _this.privDialogRequestSession.onConnectionEstablishCompleted(response.statusCode);\n\n          return Exports_2.PromiseHelper.fromResult(connection);\n        } else if (response.statusCode === 403 && !isUnAuthorized) {\n          return _this.dialogConnectImpl(true);\n        } else {\n          _this.privDialogRequestSession.onConnectionEstablishCompleted(response.statusCode, response.reason);\n\n          return Exports_2.PromiseHelper.fromError(\"Unable to contact server. StatusCode: \" + response.statusCode + \", \" + _this.privRecognizerConfig.parameters.getProperty(Exports_3.PropertyId.SpeechServiceConnection_Endpoint) + \" Reason: \" + response.reason);\n        }\n      });\n    });\n    this.privConnectionLoop = this.startMessageLoop();\n    return this.privDialogConnectionPromise;\n  };\n\n  DialogServiceAdapter.prototype.startMessageLoop = function () {\n    var _this = this;\n\n    this.terminateMessageLoop = false;\n    var messageRetrievalPromise = this.receiveDialogMessageOverride();\n    return messageRetrievalPromise.on(function (r) {\n      return true;\n    }, function (error) {\n      _this.cancelRecognition(_this.privDialogRequestSession.sessionId, _this.privDialogRequestSession.requestId, Exports_3.CancellationReason.Error, Exports_3.CancellationErrorCode.RuntimeError, error);\n    });\n  }; // Takes an established websocket connection to the endpoint and sends speech configuration information.\n\n\n  DialogServiceAdapter.prototype.configConnection = function () {\n    var _this = this;\n\n    if (this.privConnectionConfigPromise) {\n      if (this.privConnectionConfigPromise.result().isCompleted && (this.privConnectionConfigPromise.result().isError || this.privConnectionConfigPromise.result().result.state() === Exports_2.ConnectionState.Disconnected)) {\n        this.privConnectionConfigPromise = null;\n        return this.configConnection();\n      } else {\n        return this.privConnectionConfigPromise;\n      }\n    }\n\n    if (this.terminateMessageLoop) {\n      this.terminateMessageLoop = false;\n      return Exports_2.PromiseHelper.fromError(\"Connection to service terminated.\");\n    }\n\n    this.privConnectionConfigPromise = this.dialogConnectImpl().onSuccessContinueWithPromise(function (connection) {\n      return _this.sendSpeechServiceConfig(connection, _this.privDialogRequestSession, _this.privRecognizerConfig.SpeechServiceConfig.serialize()).onSuccessContinueWithPromise(function (_) {\n        return _this.sendAgentConfig(connection).onSuccessContinueWith(function (_) {\n          return connection;\n        });\n      });\n    });\n    return this.privConnectionConfigPromise;\n  };\n\n  DialogServiceAdapter.prototype.sendPreAudioMessages = function () {\n    var _this = this;\n\n    this.fetchDialogConnection().onSuccessContinueWith(function (connection) {\n      _this.sendAgentContext(connection);\n\n      _this.sendWaveHeader(connection);\n    });\n  };\n\n  DialogServiceAdapter.prototype.fireEventForResult = function (serviceResult, properties) {\n    var resultReason = Exports_4.EnumTranslation.implTranslateRecognitionResult(serviceResult.RecognitionStatus);\n    var offset = serviceResult.Offset + this.privDialogRequestSession.currentTurnAudioOffset;\n    var result = new Exports_3.SpeechRecognitionResult(this.privDialogRequestSession.requestId, resultReason, serviceResult.DisplayText, serviceResult.Duration, offset, serviceResult.Language, serviceResult.LanguageDetectionConfidence, undefined, JSON.stringify(serviceResult), properties);\n    var ev = new Exports_3.SpeechRecognitionEventArgs(result, offset, this.privDialogRequestSession.sessionId);\n    return ev;\n  };\n\n  return DialogServiceAdapter;\n}(Exports_4.ServiceRecognizerBase);\n\nexports.DialogServiceAdapter = DialogServiceAdapter;","map":{"version":3,"sources":["src/common.speech/DialogServiceAdapter.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { ReplayableAudioNode } from \"../common.browser/Exports\";\r\nimport {\r\n    ConnectionEvent,\r\n    ConnectionMessage,\r\n    ConnectionOpenResponse,\r\n    ConnectionState,\r\n    createGuid,\r\n    createNoDashGuid,\r\n    Deferred,\r\n    IAudioSource,\r\n    IAudioStreamNode,\r\n    IConnection,\r\n    IStreamChunk,\r\n    MessageType,\r\n    Promise,\r\n    PromiseHelper,\r\n    PromiseResult,\r\n    ServiceEvent,\r\n} from \"../common/Exports\";\r\nimport { AudioOutputFormatImpl } from \"../sdk/Audio/AudioOutputFormat\";\r\nimport { PullAudioOutputStreamImpl } from \"../sdk/Audio/AudioOutputStream\";\r\nimport { AudioStreamFormatImpl } from \"../sdk/Audio/AudioStreamFormat\";\r\nimport {\r\n    ActivityReceivedEventArgs,\r\n    AudioOutputStream,\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    DialogServiceConnector,\r\n    PropertyCollection,\r\n    PropertyId,\r\n    PullAudioOutputStream,\r\n    RecognitionEventArgs,\r\n    ResultReason,\r\n    SessionEventArgs,\r\n    SpeechRecognitionCanceledEventArgs,\r\n    SpeechRecognitionEventArgs,\r\n    SpeechRecognitionResult,\r\n    SpeechSynthesisOutputFormat,\r\n} from \"../sdk/Exports\";\r\nimport { DialogServiceTurnStateManager } from \"./DialogServiceTurnStateManager\";\r\nimport {\r\n    AgentConfig,\r\n    CancellationErrorCodePropertyName,\r\n    EnumTranslation,\r\n    ISpeechConfigAudioDevice,\r\n    RecognitionStatus,\r\n    RequestSession,\r\n    ServiceRecognizerBase,\r\n    SimpleSpeechPhrase,\r\n    SpeechDetected,\r\n    SpeechHypothesis,\r\n} from \"./Exports\";\r\nimport { AuthInfo, IAuthentication } from \"./IAuthentication\";\r\nimport { IConnectionFactory } from \"./IConnectionFactory\";\r\nimport { RecognitionMode, RecognizerConfig } from \"./RecognizerConfig\";\r\nimport { ActivityPayloadResponse } from \"./ServiceMessages/ActivityResponsePayload\";\r\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\r\n\r\nexport class DialogServiceAdapter extends ServiceRecognizerBase {\r\n    private privDialogServiceConnector: DialogServiceConnector;\r\n    private privDialogConnectionFactory: IConnectionFactory;\r\n    private privDialogAuthFetchEventId: string;\r\n    private privDialogIsDisposed: boolean;\r\n    private privDialogAuthentication: IAuthentication;\r\n    private privDialogAudioSource: IAudioSource;\r\n    private privDialogRequestSession: RequestSession;\r\n\r\n    // A promise for a configured connection.\r\n    // Do not consume directly, call fetchDialogConnection instead.\r\n    private privConnectionConfigPromise: Promise<IConnection>;\r\n\r\n    // A promise for a connection, but one that has not had the speech context sent yet.\r\n    // Do not consume directly, call fetchDialogConnection instead.\r\n    private privDialogConnectionPromise: Promise<IConnection>;\r\n\r\n    private privConnectionLoop: Promise<IConnection>;\r\n    private terminateMessageLoop: boolean;\r\n    private agentConfigSent: boolean;\r\n    private privLastResult: SpeechRecognitionResult;\r\n\r\n    // Turns are of two kinds:\r\n    // 1: SR turns, end when the SR result is returned and then turn end.\r\n    // 2: Service turns where an activity is sent by the service along with the audio.\r\n    private privTurnStateManager: DialogServiceTurnStateManager;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: IConnectionFactory,\r\n        audioSource: IAudioSource,\r\n        recognizerConfig: RecognizerConfig,\r\n        dialogServiceConnector: DialogServiceConnector) {\r\n\r\n        super(authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector);\r\n\r\n        this.privDialogServiceConnector = dialogServiceConnector;\r\n        this.privDialogAuthentication = authentication;\r\n        this.receiveMessageOverride = this.receiveDialogMessageOverride;\r\n        this.privTurnStateManager = new DialogServiceTurnStateManager();\r\n        this.recognizeOverride = this.listenOnce;\r\n        this.connectImplOverride = this.dialogConnectImpl;\r\n        this.configConnectionOverride = this.configConnection;\r\n        this.fetchConnectionOverride = this.fetchDialogConnection;\r\n        this.disconnectOverride = this.privDisconnect;\r\n        this.privDialogAudioSource = audioSource;\r\n        this.privDialogRequestSession = new RequestSession(audioSource.id());\r\n        this.privDialogConnectionFactory = connectionFactory;\r\n        this.privDialogIsDisposed = false;\r\n        this.agentConfigSent = false;\r\n        this.privLastResult = null;\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return this.privDialogIsDisposed;\r\n    }\r\n\r\n    public dispose(reason?: string): void {\r\n        this.privDialogIsDisposed = true;\r\n        if (this.privConnectionConfigPromise) {\r\n            this.privConnectionConfigPromise.onSuccessContinueWith((connection: IConnection) => {\r\n                connection.dispose(reason);\r\n            });\r\n        }\r\n    }\r\n\r\n    public sendMessage = (message: string): void => {\r\n        const interactionGuid: string = createGuid();\r\n        const requestId: string = createNoDashGuid();\r\n\r\n        const agentMessage: any = {\r\n            context: {\r\n                interactionId: interactionGuid\r\n            },\r\n            messagePayload: JSON.parse(message),\r\n            version: 0.5\r\n        };\r\n\r\n        const agentMessageJson = JSON.stringify(agentMessage);\r\n\r\n        this.fetchDialogConnection().onSuccessContinueWith((connection: IConnection) => {\r\n            connection.send(new SpeechConnectionMessage(\r\n                MessageType.Text,\r\n                \"agent\",\r\n                requestId,\r\n                \"application/json\",\r\n                agentMessageJson));\r\n        });\r\n    }\r\n\r\n    protected privDisconnect(): void {\r\n        this.cancelRecognition(this.privDialogRequestSession.sessionId,\r\n            this.privDialogRequestSession.requestId,\r\n            CancellationReason.Error,\r\n            CancellationErrorCode.NoError,\r\n            \"Disconnecting\");\r\n\r\n        this.terminateMessageLoop = true;\r\n        this.agentConfigSent = false;\r\n        if (this.privDialogConnectionPromise.result().isCompleted) {\r\n            if (!this.privDialogConnectionPromise.result().isError) {\r\n                this.privDialogConnectionPromise.result().result.dispose();\r\n                this.privDialogConnectionPromise = null;\r\n            }\r\n        } else {\r\n            this.privDialogConnectionPromise.onSuccessContinueWith((connection: IConnection) => {\r\n                connection.dispose();\r\n            });\r\n        }\r\n    }\r\n\r\n    protected processTypeSpecificMessages(connectionMessage: SpeechConnectionMessage): boolean {\r\n\r\n        const resultProps: PropertyCollection = new PropertyCollection();\r\n        if (connectionMessage.messageType === MessageType.Text) {\r\n            resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\r\n        }\r\n\r\n        let result: SpeechRecognitionResult;\r\n        let processed: boolean;\r\n\r\n        switch (connectionMessage.path.toLowerCase()) {\r\n            case \"speech.phrase\":\r\n                const speechPhrase: SimpleSpeechPhrase = SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);\r\n\r\n                this.privDialogRequestSession.onPhraseRecognized(this.privDialogRequestSession.currentTurnAudioOffset + speechPhrase.Offset + speechPhrase.Duration);\r\n\r\n                if (speechPhrase.RecognitionStatus === RecognitionStatus.Success) {\r\n                    const args: SpeechRecognitionEventArgs = this.fireEventForResult(speechPhrase, resultProps);\r\n                    this.privLastResult = args.result;\r\n\r\n                    if (!!this.privDialogServiceConnector.recognized) {\r\n                        try {\r\n                            this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, args);\r\n                            /* tslint:disable:no-empty */\r\n                        } catch (error) {\r\n                            // Not going to let errors in the event handler\r\n                            // trip things up.\r\n                        }\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n            case \"speech.hypothesis\":\r\n                const hypothesis: SpeechHypothesis = SpeechHypothesis.fromJSON(connectionMessage.textBody);\r\n                const offset: number = hypothesis.Offset + this.privDialogRequestSession.currentTurnAudioOffset;\r\n\r\n                result = new SpeechRecognitionResult(\r\n                    this.privDialogRequestSession.requestId,\r\n                    ResultReason.RecognizingSpeech,\r\n                    hypothesis.Text,\r\n                    hypothesis.Duration,\r\n                    offset,\r\n                    hypothesis.Language,\r\n                    hypothesis.LanguageDetectionConfidence,\r\n                    undefined,\r\n                    connectionMessage.textBody,\r\n                    resultProps);\r\n\r\n                this.privDialogRequestSession.onHypothesis(offset);\r\n\r\n                const ev = new SpeechRecognitionEventArgs(result, hypothesis.Duration, this.privDialogRequestSession.sessionId);\r\n\r\n                if (!!this.privDialogServiceConnector.recognizing) {\r\n                    try {\r\n                        this.privDialogServiceConnector.recognizing(this.privDialogServiceConnector, ev);\r\n                        /* tslint:disable:no-empty */\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n\r\n            case \"audio\":\r\n                {\r\n                    const audioRequestId = connectionMessage.requestId.toUpperCase();\r\n                    const turn = this.privTurnStateManager.GetTurn(audioRequestId);\r\n                    try {\r\n                        // Empty binary message signals end of stream.\r\n                        if (!connectionMessage.binaryBody) {\r\n                            turn.endAudioStream();\r\n                        } else {\r\n                            turn.audioStream.write(connectionMessage.binaryBody);\r\n                        }\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n\r\n            case \"response\":\r\n                {\r\n                    const responseRequestId = connectionMessage.requestId.toUpperCase();\r\n                    const activityPayload: ActivityPayloadResponse = ActivityPayloadResponse.fromJSON(connectionMessage.textBody);\r\n                    const turn = this.privTurnStateManager.GetTurn(responseRequestId);\r\n\r\n                    // update the conversation Id\r\n                    if (activityPayload.conversationId) {\r\n                        const updateAgentConfig = this.agentConfig.get();\r\n                        updateAgentConfig.botInfo.conversationId = activityPayload.conversationId;\r\n                        this.agentConfig.set(updateAgentConfig);\r\n                    }\r\n\r\n                    const pullAudioOutputStream: PullAudioOutputStreamImpl = turn.processActivityPayload(activityPayload, (SpeechSynthesisOutputFormat as any)[this.privDialogServiceConnector.properties.getProperty(PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)]);\r\n                    const activity = new ActivityReceivedEventArgs(activityPayload.messagePayload, pullAudioOutputStream);\r\n                    if (!!this.privDialogServiceConnector.activityReceived) {\r\n                        try {\r\n                            this.privDialogServiceConnector.activityReceived(this.privDialogServiceConnector, activity);\r\n                            /* tslint:disable:no-empty */\r\n                        } catch (error) {\r\n                            // Not going to let errors in the event handler\r\n                            // trip things up.\r\n                        }\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n\r\n            default:\r\n                break;\r\n        }\r\n        return processed;\r\n    }\r\n\r\n    // Cancels recognition.\r\n    protected cancelRecognition(\r\n        sessionId: string,\r\n        requestId: string,\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void {\r\n\r\n        this.terminateMessageLoop = true;\r\n\r\n        if (!!this.privDialogRequestSession.isRecognizing) {\r\n            this.privDialogRequestSession.onStopRecognizing();\r\n        }\r\n\r\n        if (!!this.privDialogServiceConnector.canceled) {\r\n            const properties: PropertyCollection = new PropertyCollection();\r\n            properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\r\n\r\n            const cancelEvent: SpeechRecognitionCanceledEventArgs = new SpeechRecognitionCanceledEventArgs(\r\n                cancellationReason,\r\n                error,\r\n                errorCode,\r\n                undefined,\r\n                sessionId);\r\n\r\n            try {\r\n                this.privDialogServiceConnector.canceled(this.privDialogServiceConnector, cancelEvent);\r\n                /* tslint:disable:no-empty */\r\n            } catch { }\r\n\r\n            if (!!this.privSuccessCallback) {\r\n                const result: SpeechRecognitionResult = new SpeechRecognitionResult(\r\n                    undefined, // ResultId\r\n                    ResultReason.Canceled,\r\n                    undefined, // Text\r\n                    undefined, // Druation\r\n                    undefined, // Offset\r\n                    undefined, // Language\r\n                    undefined, // Language Detection Confidence\r\n                    error,\r\n                    undefined, // Json\r\n                    properties);\r\n                try {\r\n                    this.privSuccessCallback(result);\r\n                    this.privSuccessCallback = undefined;\r\n                    /* tslint:disable:no-empty */\r\n                } catch { }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected listenOnce = (\r\n        recoMode: RecognitionMode,\r\n        successCallback: (e: SpeechRecognitionResult) => void,\r\n        errorCallback: (e: string) => void\r\n    ): Promise<boolean> => {\r\n        this.privRecognizerConfig.recognitionMode = recoMode;\r\n\r\n        this.privSuccessCallback = successCallback;\r\n        this.privErrorCallback = errorCallback;\r\n\r\n        this.privDialogRequestSession.startNewRecognition();\r\n        this.privDialogRequestSession.listenForServiceTelemetry(this.privDialogAudioSource.events);\r\n\r\n        // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().\r\n        this.dialogConnectImpl();\r\n\r\n        this.sendPreAudioMessages();\r\n\r\n        return this.privDialogAudioSource\r\n            .attach(this.privDialogRequestSession.audioNodeId)\r\n            .continueWithPromise<boolean>((result: PromiseResult<IAudioStreamNode>) => {\r\n                let audioNode: ReplayableAudioNode;\r\n\r\n                if (result.isError) {\r\n                    this.cancelRecognition(this.privDialogRequestSession.sessionId, this.privDialogRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.ConnectionFailure, result.error);\r\n                    return PromiseHelper.fromError<boolean>(result.error);\r\n                }\r\n\r\n                return this.privDialogAudioSource.format.onSuccessContinueWithPromise<boolean>((format: AudioStreamFormatImpl) => {\r\n                    audioNode = new ReplayableAudioNode(result.result, format.avgBytesPerSec);\r\n                    this.privDialogRequestSession.onAudioSourceAttachCompleted(audioNode, false);\r\n\r\n                    return this.privDialogAudioSource.deviceInfo.onSuccessContinueWithPromise<boolean>((deviceInfo: ISpeechConfigAudioDevice): Promise<boolean> => {\r\n                        this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: deviceInfo };\r\n\r\n                        return this.configConnection()\r\n                            .continueWithPromise<boolean>((result: PromiseResult<IConnection>): Promise<boolean> => {\r\n                                if (result.isError) {\r\n                                    this.cancelRecognitionLocal(CancellationReason.Error, CancellationErrorCode.ConnectionFailure, result.error);\r\n                                    return PromiseHelper.fromError(result.error);\r\n                                }\r\n\r\n                                const sessionStartEventArgs: SessionEventArgs = new SessionEventArgs(this.privDialogRequestSession.sessionId);\r\n\r\n                                if (!!this.privRecognizer.sessionStarted) {\r\n                                    this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);\r\n                                }\r\n\r\n                                const audioSendPromise = this.sendAudio(audioNode);\r\n\r\n                                // /* tslint:disable:no-empty */\r\n                                audioSendPromise.on((_: boolean) => { /*add? return true;*/ }, (error: string) => {\r\n                                    this.cancelRecognition(this.privDialogRequestSession.sessionId, this.privDialogRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\r\n                                });\r\n\r\n                                return PromiseHelper.fromResult(true);\r\n                            });\r\n                    });\r\n                });\r\n            });\r\n    }\r\n\r\n    protected sendAudio = (audioStreamNode: IAudioStreamNode): Promise<boolean> => {\r\n        return this.privDialogAudioSource.format.onSuccessContinueWithPromise<boolean>((audioFormat: AudioStreamFormatImpl) => {\r\n            // NOTE: Home-baked promises crash ios safari during the invocation\r\n            // of the error callback chain (looks like the recursion is way too deep, and\r\n            // it blows up the stack). The following construct is a stop-gap that does not\r\n            // bubble the error up the callback chain and hence circumvents this problem.\r\n            // TODO: rewrite with ES6 promises.\r\n            const deferred = new Deferred<boolean>();\r\n\r\n            // The time we last sent data to the service.\r\n            let nextSendTime: number = Date.now();\r\n\r\n            // Max amount to send before we start to throttle\r\n            const fastLaneSizeMs: string = this.privRecognizerConfig.parameters.getProperty(\"SPEECH-TransmitLengthBeforThrottleMs\", \"5000\");\r\n            const maxSendUnthrottledBytes: number = audioFormat.avgBytesPerSec / 1000 * parseInt(fastLaneSizeMs, 10);\r\n            const startRecogNumber: number = this.privDialogRequestSession.recogNumber;\r\n\r\n            const readAndUploadCycle = () => {\r\n\r\n                // If speech is done, stop sending audio.\r\n                if (!this.privDialogIsDisposed &&\r\n                    !this.privDialogRequestSession.isSpeechEnded &&\r\n                    this.privDialogRequestSession.isRecognizing &&\r\n                    this.privDialogRequestSession.recogNumber === startRecogNumber) {\r\n                    this.fetchDialogConnection().on((connection: IConnection) => {\r\n                        audioStreamNode.read().on(\r\n                            (audioStreamChunk: IStreamChunk<ArrayBuffer>) => {\r\n                                // we have a new audio chunk to upload.\r\n                                if (this.privDialogRequestSession.isSpeechEnded) {\r\n                                    // If service already recognized audio end then don't send any more audio\r\n                                    deferred.resolve(true);\r\n                                    return;\r\n                                }\r\n\r\n                                let payload: ArrayBuffer;\r\n                                let sendDelay: number;\r\n\r\n                                if (!audioStreamChunk || audioStreamChunk.isEnd) {\r\n                                    payload = null;\r\n                                    sendDelay = 0;\r\n                                } else {\r\n                                    payload = audioStreamChunk.buffer;\r\n                                    this.privDialogRequestSession.onAudioSent(payload.byteLength);\r\n\r\n                                    if (maxSendUnthrottledBytes >= this.privDialogRequestSession.bytesSent) {\r\n                                        sendDelay = 0;\r\n                                    } else {\r\n                                        sendDelay = Math.max(0, nextSendTime - Date.now());\r\n                                    }\r\n                                }\r\n\r\n                                // Are we ready to send, or need we delay more?\r\n                                setTimeout(() => {\r\n                                    if (payload !== null) {\r\n                                        nextSendTime = Date.now() + (payload.byteLength * 1000 / (audioFormat.avgBytesPerSec * 2));\r\n                                    }\r\n\r\n                                    const uploaded: Promise<boolean> = connection.send(\r\n                                        new SpeechConnectionMessage(\r\n                                            MessageType.Binary, \"audio\", this.privDialogRequestSession.requestId, null, payload));\r\n\r\n                                    if (audioStreamChunk && !audioStreamChunk.isEnd) {\r\n                                        uploaded.continueWith((_: PromiseResult<boolean>) => {\r\n\r\n                                            // Regardless of success or failure, schedule the next upload.\r\n                                            // If the underlying connection was broken, the next cycle will\r\n                                            // get a new connection and re-transmit missing audio automatically.\r\n                                            readAndUploadCycle();\r\n                                        });\r\n                                    } else {\r\n                                        // the audio stream has been closed, no need to schedule next\r\n                                        // read-upload cycle.\r\n                                        this.privDialogRequestSession.onSpeechEnded();\r\n                                        deferred.resolve(true);\r\n                                    }\r\n                                }, sendDelay);\r\n                            },\r\n                            (error: string) => {\r\n                                if (this.privDialogRequestSession.isSpeechEnded) {\r\n                                    // For whatever reason, Reject is used to remove queue subscribers inside\r\n                                    // the Queue.DrainAndDispose invoked from DetachAudioNode down below, which\r\n                                    // means that sometimes things can be rejected in normal circumstances, without\r\n                                    // any errors.\r\n                                    deferred.resolve(true); // TODO: remove the argument, it's is completely meaningless.\r\n                                } else {\r\n                                    // Only reject, if there was a proper error.\r\n                                    deferred.reject(error);\r\n                                }\r\n                            });\r\n                    }, (error: string) => {\r\n                        deferred.reject(error);\r\n                    });\r\n                }\r\n            };\r\n\r\n            readAndUploadCycle();\r\n\r\n            return deferred.promise();\r\n        });\r\n    }\r\n\r\n    protected sendWaveHeader(connection: IConnection): Promise<boolean> {\r\n        return this.audioSource.format.onSuccessContinueWithPromise<boolean>((format: AudioStreamFormatImpl) => {\r\n            return connection.send(new SpeechConnectionMessage(\r\n                MessageType.Binary,\r\n                \"audio\",\r\n                this.privDialogRequestSession.requestId,\r\n                \"audio/x-wav\",\r\n                format.header));\r\n        });\r\n    }\r\n\r\n    // Establishes a websocket connection to the end point.\r\n    private dialogConnectImpl(isUnAuthorized: boolean = false): Promise<IConnection> {\r\n        if (this.privDialogConnectionPromise) {\r\n            if (this.privDialogConnectionPromise.result().isCompleted &&\r\n                (this.privDialogConnectionPromise.result().isError\r\n                    || this.privDialogConnectionPromise.result().result.state() === ConnectionState.Disconnected)) {\r\n                this.agentConfigSent = false;\r\n                this.privDialogConnectionPromise = null;\r\n                this.terminateMessageLoop = true;\r\n                return this.configConnection();\r\n            } else {\r\n                return this.privDialogConnectionPromise;\r\n            }\r\n        }\r\n\r\n        this.privDialogAuthFetchEventId = createNoDashGuid();\r\n\r\n        // keep the connectionId for reconnect events\r\n        if (this.privConnectionId === undefined) {\r\n            this.privConnectionId = createNoDashGuid();\r\n        }\r\n\r\n        this.privDialogRequestSession.onPreConnectionStart(this.privDialogAuthFetchEventId, this.privConnectionId);\r\n\r\n        const authPromise = isUnAuthorized ? this.privDialogAuthentication.fetchOnExpiry(this.privDialogAuthFetchEventId) : this.privDialogAuthentication.fetch(this.privDialogAuthFetchEventId);\r\n\r\n        this.privDialogConnectionPromise = authPromise\r\n            .continueWithPromise((result: PromiseResult<AuthInfo>) => {\r\n                if (result.isError) {\r\n                    this.privDialogRequestSession.onAuthCompleted(true, result.error);\r\n                    throw new Error(result.error);\r\n                } else {\r\n                    this.privDialogRequestSession.onAuthCompleted(false);\r\n                }\r\n\r\n                const connection: IConnection = this.privDialogConnectionFactory.create(this.privRecognizerConfig, result.result, this.privConnectionId);\r\n\r\n                this.privDialogRequestSession.listenForServiceTelemetry(connection.events);\r\n\r\n                // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\r\n                // it'll stop sending events.\r\n                connection.events.attach((event: ConnectionEvent) => {\r\n                    this.connectionEvents.onEvent(event);\r\n                });\r\n\r\n                return connection.open().onSuccessContinueWithPromise((response: ConnectionOpenResponse): Promise<IConnection> => {\r\n                    if (response.statusCode === 200) {\r\n                        this.privDialogRequestSession.onPreConnectionStart(this.privDialogAuthFetchEventId, this.privConnectionId);\r\n                        this.privDialogRequestSession.onConnectionEstablishCompleted(response.statusCode);\r\n\r\n                        return PromiseHelper.fromResult<IConnection>(connection);\r\n                    } else if (response.statusCode === 403 && !isUnAuthorized) {\r\n                        return this.dialogConnectImpl(true);\r\n                    } else {\r\n                        this.privDialogRequestSession.onConnectionEstablishCompleted(response.statusCode, response.reason);\r\n                        return PromiseHelper.fromError<IConnection>(`Unable to contact server. StatusCode: ${response.statusCode}, ${this.privRecognizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${response.reason}`);\r\n                    }\r\n                });\r\n            });\r\n\r\n        this.privConnectionLoop = this.startMessageLoop();\r\n        return this.privDialogConnectionPromise;\r\n    }\r\n\r\n    private receiveDialogMessageOverride = (): Promise<IConnection> => {\r\n\r\n        // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\r\n        const communicationCustodian: Deferred<IConnection> = new Deferred<IConnection>();\r\n\r\n        this.fetchDialogConnection().on((connection: IConnection): Promise<IConnection> => {\r\n            return connection.read()\r\n                .onSuccessContinueWithPromise((message: ConnectionMessage): Promise<IConnection> => {\r\n                    const isDisposed: boolean = this.isDisposed();\r\n                    const terminateMessageLoop = (!this.isDisposed() && this.terminateMessageLoop);\r\n                    if (isDisposed || terminateMessageLoop) {\r\n                        // We're done.\r\n                        communicationCustodian.resolve(undefined);\r\n                        return PromiseHelper.fromResult<IConnection>(undefined);\r\n                    }\r\n\r\n                    if (!message) {\r\n                        return this.receiveDialogMessageOverride();\r\n                    }\r\n\r\n                    const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\r\n\r\n                    switch (connectionMessage.path.toLowerCase()) {\r\n                        case \"turn.start\":\r\n                            {\r\n                                const turnRequestId = connectionMessage.requestId.toUpperCase();\r\n                                const audioSessionReqId = this.privDialogRequestSession.requestId.toUpperCase();\r\n\r\n                                // turn started by the service\r\n                                if (turnRequestId !== audioSessionReqId) {\r\n                                    this.privTurnStateManager.StartTurn(turnRequestId);\r\n                                } else {\r\n                                    this.privDialogRequestSession.onServiceTurnStartResponse();\r\n                                }\r\n                            }\r\n                            break;\r\n                        case \"speech.startdetected\":\r\n                            const speechStartDetected: SpeechDetected = SpeechDetected.fromJSON(connectionMessage.textBody);\r\n\r\n                            const speechStartEventArgs = new RecognitionEventArgs(speechStartDetected.Offset, this.privDialogRequestSession.sessionId);\r\n\r\n                            if (!!this.privRecognizer.speechStartDetected) {\r\n                                this.privRecognizer.speechStartDetected(this.privRecognizer, speechStartEventArgs);\r\n                            }\r\n\r\n                            break;\r\n                        case \"speech.enddetected\":\r\n\r\n                            let json: string;\r\n\r\n                            if (connectionMessage.textBody.length > 0) {\r\n                                json = connectionMessage.textBody;\r\n                            } else {\r\n                                // If the request was empty, the JSON returned is empty.\r\n                                json = \"{ Offset: 0 }\";\r\n                            }\r\n\r\n                            const speechStopDetected: SpeechDetected = SpeechDetected.fromJSON(json);\r\n\r\n                            this.privDialogRequestSession.onServiceRecognized(speechStopDetected.Offset + this.privDialogRequestSession.currentTurnAudioOffset);\r\n\r\n                            const speechStopEventArgs = new RecognitionEventArgs(speechStopDetected.Offset + this.privDialogRequestSession.currentTurnAudioOffset, this.privDialogRequestSession.sessionId);\r\n\r\n                            if (!!this.privRecognizer.speechEndDetected) {\r\n                                this.privRecognizer.speechEndDetected(this.privRecognizer, speechStopEventArgs);\r\n                            }\r\n                            break;\r\n\r\n                        case \"turn.end\":\r\n                            {\r\n                                const turnEndRequestId = connectionMessage.requestId.toUpperCase();\r\n\r\n                                const audioSessionReqId = this.privDialogRequestSession.requestId.toUpperCase();\r\n\r\n                                // turn started by the service\r\n                                if (turnEndRequestId !== audioSessionReqId) {\r\n                                    this.privTurnStateManager.CompleteTurn(turnEndRequestId);\r\n                                } else {\r\n                                    // Audio session turn\r\n\r\n                                    const sessionStopEventArgs: SessionEventArgs = new SessionEventArgs(this.privDialogRequestSession.sessionId);\r\n                                    this.privDialogRequestSession.onServiceTurnEndResponse(false);\r\n\r\n                                    if (this.privDialogRequestSession.isSpeechEnded) {\r\n                                        if (!!this.privRecognizer.sessionStopped) {\r\n                                            this.privRecognizer.sessionStopped(this.privRecognizer, sessionStopEventArgs);\r\n                                        }\r\n                                    }\r\n\r\n                                    // report result to promise.\r\n                                    if (!!this.privSuccessCallback && this.privLastResult) {\r\n                                        try {\r\n                                            this.privSuccessCallback(this.privLastResult);\r\n                                            this.privLastResult = null;\r\n                                        } catch (e) {\r\n                                            if (!!this.privErrorCallback) {\r\n                                                this.privErrorCallback(e);\r\n                                            }\r\n                                        }\r\n                                        // Only invoke the call back once.\r\n                                        // and if it's successful don't invoke the\r\n                                        // error after that.\r\n                                        this.privSuccessCallback = undefined;\r\n                                        this.privErrorCallback = undefined;\r\n                                    }\r\n                                }\r\n                            }\r\n                            break;\r\n\r\n                        default:\r\n                            if (!this.processTypeSpecificMessages(connectionMessage)) {\r\n                                if (!!this.serviceEvents) {\r\n                                    this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\r\n                                }\r\n                            }\r\n                    }\r\n\r\n                    return this.receiveDialogMessageOverride();\r\n                });\r\n        }, (error: string) => {\r\n            this.terminateMessageLoop = true;\r\n            communicationCustodian.resolve(undefined);\r\n            return PromiseHelper.fromResult<IConnection>(undefined);\r\n        });\r\n\r\n        return communicationCustodian.promise();\r\n    }\r\n\r\n    private startMessageLoop(): Promise<IConnection> {\r\n\r\n        this.terminateMessageLoop = false;\r\n\r\n        const messageRetrievalPromise = this.receiveDialogMessageOverride();\r\n\r\n        return messageRetrievalPromise.on((r: IConnection) => {\r\n            return true;\r\n        }, (error: string) => {\r\n            this.cancelRecognition(this.privDialogRequestSession.sessionId, this.privDialogRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\r\n        });\r\n    }\r\n\r\n    // Takes an established websocket connection to the endpoint and sends speech configuration information.\r\n    private configConnection(): Promise<IConnection> {\r\n        if (this.privConnectionConfigPromise) {\r\n            if (this.privConnectionConfigPromise.result().isCompleted &&\r\n                (this.privConnectionConfigPromise.result().isError\r\n                    || this.privConnectionConfigPromise.result().result.state() === ConnectionState.Disconnected)) {\r\n\r\n                this.privConnectionConfigPromise = null;\r\n                return this.configConnection();\r\n            } else {\r\n                return this.privConnectionConfigPromise;\r\n            }\r\n        }\r\n\r\n        if (this.terminateMessageLoop) {\r\n            this.terminateMessageLoop = false;\r\n            return PromiseHelper.fromError(`Connection to service terminated.`);\r\n        }\r\n\r\n        this.privConnectionConfigPromise = this.dialogConnectImpl().onSuccessContinueWithPromise((connection: IConnection): Promise<IConnection> => {\r\n            return this.sendSpeechServiceConfig(connection, this.privDialogRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize())\r\n                .onSuccessContinueWithPromise((_: boolean) => {\r\n                    return this.sendAgentConfig(connection).onSuccessContinueWith((_: boolean) => {\r\n                        return connection;\r\n                    });\r\n                });\r\n        });\r\n\r\n        return this.privConnectionConfigPromise;\r\n    }\r\n\r\n    private fetchDialogConnection = (): Promise<IConnection> => {\r\n        return this.configConnection();\r\n    }\r\n\r\n    private sendPreAudioMessages(): void {\r\n        this.fetchDialogConnection().onSuccessContinueWith((connection: IConnection): void => {\r\n            this.sendAgentContext(connection);\r\n            this.sendWaveHeader(connection);\r\n        });\r\n    }\r\n\r\n    private sendAgentConfig = (connection: IConnection): Promise<boolean> => {\r\n        if (this.agentConfig && !this.agentConfigSent) {\r\n\r\n            if (this.privRecognizerConfig.parameters.getProperty(PropertyId.Conversation_DialogType) === \"custom_commands\") {\r\n                const config = this.agentConfig.get();\r\n                config.botInfo.commandsCulture = this.privRecognizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage, \"en-us\");\r\n                this.agentConfig.set(config);\r\n            }\r\n            const agentConfigJson = this.agentConfig.toJsonString();\r\n\r\n            // guard against sending this multiple times on one connection\r\n            this.agentConfigSent = true;\r\n\r\n            return connection.send(new SpeechConnectionMessage(\r\n                MessageType.Text,\r\n                \"agent.config\",\r\n                this.privDialogRequestSession.requestId,\r\n                \"application/json\",\r\n                agentConfigJson));\r\n        }\r\n\r\n        return PromiseHelper.fromResult(true);\r\n    }\r\n\r\n    private sendAgentContext = (connection: IConnection): Promise<boolean> => {\r\n        const guid: string = createGuid();\r\n\r\n        const speechActivityTemplate = this.privDialogServiceConnector.properties.getProperty(PropertyId.Conversation_Speech_Activity_Template);\r\n\r\n        const agentContext: any = {\r\n            channelData: \"\",\r\n            context: {\r\n                interactionId: guid\r\n            },\r\n            messagePayload: typeof speechActivityTemplate === undefined ? undefined : speechActivityTemplate,\r\n            version: 0.5\r\n        };\r\n\r\n        const agentContextJson = JSON.stringify(agentContext);\r\n\r\n        return connection.send(new SpeechConnectionMessage(\r\n            MessageType.Text,\r\n            \"speech.agent.context\",\r\n            this.privDialogRequestSession.requestId,\r\n            \"application/json\",\r\n            agentContextJson));\r\n    }\r\n\r\n    private fireEventForResult(serviceResult: SimpleSpeechPhrase, properties: PropertyCollection): SpeechRecognitionEventArgs {\r\n        const resultReason: ResultReason = EnumTranslation.implTranslateRecognitionResult(serviceResult.RecognitionStatus);\r\n\r\n        const offset: number = serviceResult.Offset + this.privDialogRequestSession.currentTurnAudioOffset;\r\n\r\n        const result = new SpeechRecognitionResult(\r\n            this.privDialogRequestSession.requestId,\r\n            resultReason,\r\n            serviceResult.DisplayText,\r\n            serviceResult.Duration,\r\n            offset,\r\n            serviceResult.Language,\r\n            serviceResult.LanguageDetectionConfidence,\r\n            undefined,\r\n            JSON.stringify(serviceResult),\r\n            properties);\r\n\r\n        const ev = new SpeechRecognitionEventArgs(result, offset, this.privDialogRequestSession.sessionId);\r\n        return ev;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}