{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = playWhiteNoise;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _base64Arraybuffer = require(\"base64-arraybuffer\");\n\nvar _eventAsPromise = _interopRequireDefault(require(\"event-as-promise\"));\n\nvar EMPTY_MP3_BASE64 = 'SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU3LjU2LjEwMQAAAAAAAAAAAAAA//tAwAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAACAAABhgC7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7//////////////////////////////////////////////////////////////////8AAAAATGF2YzU3LjY0AAAAAAAAAAAAAAAAJAUHAAAAAAAAAYYoRBqpAAAAAAD/+xDEAAPAAAGkAAAAIAAANIAAAARMQU1FMy45OS41VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7EMQpg8AAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV';\n\nfunction subscribeEvent(target, name, handler) {\n  target.addEventListener(name, handler);\n  return function () {\n    return target.removeEventListener(name, handler);\n  };\n}\n\nfunction asyncDecodeAudioData(audioContext, arrayBuffer) {\n  return new Promise(function (resolve, reject) {\n    var promise = audioContext.decodeAudioData(arrayBuffer, resolve, reject); // Newer implementation of \"decodeAudioData\" will return a Promise\n\n    promise && typeof promise.then === 'function' && resolve(promise);\n  });\n}\n\nfunction playDecoded(audioContext, audioBuffer, source) {\n  return new Promise(function (resolve, reject) {\n    var audioContextClosed = new _eventAsPromise.default();\n    var sourceEnded = new _eventAsPromise.default();\n    var unsubscribe = subscribeEvent(audioContext, 'statechange', function (_ref) {\n      var state = _ref.target.state;\n      return state === 'closed' && audioContextClosed.eventListener();\n    });\n\n    try {\n      source.buffer = audioBuffer; // \"ended\" may not fire if the underlying AudioContext is closed prematurely\n\n      source.onended = sourceEnded.eventListener;\n      source.connect(audioContext.destination);\n      source.start(0);\n      Promise.race([audioContextClosed.upcoming(), sourceEnded.upcoming()]).then(resolve);\n    } catch (err) {\n      reject(err);\n    } finally {\n      unsubscribe();\n    }\n  });\n}\n\nfunction playWhiteNoise(_x) {\n  return _playWhiteNoise.apply(this, arguments);\n}\n\nfunction _playWhiteNoise() {\n  _playWhiteNoise = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(audioContext) {\n    var source, audioBuffer;\n    return _regenerator.default.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            source = audioContext.createBufferSource();\n            _context.next = 3;\n            return asyncDecodeAudioData(audioContext, (0, _base64Arraybuffer.decode)(EMPTY_MP3_BASE64));\n\n          case 3:\n            audioBuffer = _context.sent;\n            _context.next = 6;\n            return playDecoded(audioContext, audioBuffer, source);\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _playWhiteNoise.apply(this, arguments);\n}","map":{"version":3,"sources":["../src/playWhiteNoise.js"],"names":["EMPTY_MP3_BASE64","target","promise","audioContext","resolve","audioContextClosed","EventAsPromise","sourceEnded","unsubscribe","subscribeEvent","state","source","Promise","reject","playWhiteNoise","audioBuffer","asyncDecodeAudioData","playDecoded"],"mappings":"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","sourcesContent":["import { decode } from 'base64-arraybuffer';\nimport EventAsPromise from 'event-as-promise';\n\nconst EMPTY_MP3_BASE64 =\n  'SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU3LjU2LjEwMQAAAAAAAAAAAAAA//tAwAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAACAAABhgC7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7//////////////////////////////////////////////////////////////////8AAAAATGF2YzU3LjY0AAAAAAAAAAAAAAAAJAUHAAAAAAAAAYYoRBqpAAAAAAD/+xDEAAPAAAGkAAAAIAAANIAAAARMQU1FMy45OS41VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7EMQpg8AAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV';\n\nfunction subscribeEvent(target, name, handler) {\n  target.addEventListener(name, handler);\n\n  return () => target.removeEventListener(name, handler);\n}\n\nfunction asyncDecodeAudioData(audioContext, arrayBuffer) {\n  return new Promise((resolve, reject) => {\n    const promise = audioContext.decodeAudioData(arrayBuffer, resolve, reject);\n\n    // Newer implementation of \"decodeAudioData\" will return a Promise\n    promise && typeof promise.then === 'function' && resolve(promise);\n  });\n}\n\nfunction playDecoded(audioContext, audioBuffer, source) {\n  return new Promise((resolve, reject) => {\n    const audioContextClosed = new EventAsPromise();\n    const sourceEnded = new EventAsPromise();\n    const unsubscribe = subscribeEvent(\n      audioContext,\n      'statechange',\n      ({ target: { state } }) => state === 'closed' && audioContextClosed.eventListener()\n    );\n\n    try {\n      source.buffer = audioBuffer;\n      // \"ended\" may not fire if the underlying AudioContext is closed prematurely\n      source.onended = sourceEnded.eventListener;\n\n      source.connect(audioContext.destination);\n      source.start(0);\n\n      Promise.race([audioContextClosed.upcoming(), sourceEnded.upcoming()]).then(resolve);\n    } catch (err) {\n      reject(err);\n    } finally {\n      unsubscribe();\n    }\n  });\n}\n\nexport default async function playWhiteNoise(audioContext) {\n  const source = audioContext.createBufferSource();\n  const audioBuffer = await asyncDecodeAudioData(audioContext, decode(EMPTY_MP3_BASE64));\n\n  await playDecoded(audioContext, audioBuffer, source);\n}\n"],"sourceRoot":"directlinespeech:///"},"metadata":{},"sourceType":"script"}