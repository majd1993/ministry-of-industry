{"ast":null,"code":"'use strict';\n\nvar visit = require('unist-util-visit');\n\nmodule.exports = compact; // Make an mdast tree compact by merging adjacent text nodes.\n\nfunction compact(tree, commonmark) {\n  visit(tree, visitor);\n  return tree;\n\n  function visitor(child, index, parent) {\n    var siblings = parent ? parent.children : [];\n    var prev = index && siblings[index - 1];\n\n    if (prev && child.type === prev.type && mergeable(prev, commonmark) && mergeable(child, commonmark)) {\n      if (child.value) {\n        prev.value += child.value;\n      }\n\n      if (child.children) {\n        prev.children = prev.children.concat(child.children);\n      }\n\n      siblings.splice(index, 1);\n\n      if (prev.position && child.position) {\n        prev.position.end = child.position.end;\n      }\n\n      return index;\n    }\n  }\n}\n\nfunction mergeable(node, commonmark) {\n  var start;\n  var end;\n\n  if (node.type === 'text') {\n    if (!node.position) {\n      return true;\n    }\n\n    start = node.position.start;\n    end = node.position.end; // Only merge nodes which occupy the same size as their `value`.\n\n    return start.line !== end.line || end.column - start.column === node.value.length;\n  }\n\n  return commonmark && node.type === 'blockquote';\n}","map":{"version":3,"sources":["/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/mdast-util-compact/index.js"],"names":["visit","require","module","exports","compact","tree","commonmark","visitor","child","index","parent","siblings","children","prev","type","mergeable","value","concat","splice","position","end","node","start","line","column","length"],"mappings":"AAAA;;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,kBAAD,CAAnB;;AAEAC,MAAM,CAACC,OAAP,GAAiBC,OAAjB,C,CAEA;;AACA,SAASA,OAAT,CAAiBC,IAAjB,EAAuBC,UAAvB,EAAmC;AACjCN,EAAAA,KAAK,CAACK,IAAD,EAAOE,OAAP,CAAL;AAEA,SAAOF,IAAP;;AAEA,WAASE,OAAT,CAAiBC,KAAjB,EAAwBC,KAAxB,EAA+BC,MAA/B,EAAuC;AACrC,QAAIC,QAAQ,GAAGD,MAAM,GAAGA,MAAM,CAACE,QAAV,GAAqB,EAA1C;AACA,QAAIC,IAAI,GAAGJ,KAAK,IAAIE,QAAQ,CAACF,KAAK,GAAG,CAAT,CAA5B;;AAEA,QACEI,IAAI,IACJL,KAAK,CAACM,IAAN,KAAeD,IAAI,CAACC,IADpB,IAEAC,SAAS,CAACF,IAAD,EAAOP,UAAP,CAFT,IAGAS,SAAS,CAACP,KAAD,EAAQF,UAAR,CAJX,EAKE;AACA,UAAIE,KAAK,CAACQ,KAAV,EAAiB;AACfH,QAAAA,IAAI,CAACG,KAAL,IAAcR,KAAK,CAACQ,KAApB;AACD;;AAED,UAAIR,KAAK,CAACI,QAAV,EAAoB;AAClBC,QAAAA,IAAI,CAACD,QAAL,GAAgBC,IAAI,CAACD,QAAL,CAAcK,MAAd,CAAqBT,KAAK,CAACI,QAA3B,CAAhB;AACD;;AAEDD,MAAAA,QAAQ,CAACO,MAAT,CAAgBT,KAAhB,EAAuB,CAAvB;;AAEA,UAAII,IAAI,CAACM,QAAL,IAAiBX,KAAK,CAACW,QAA3B,EAAqC;AACnCN,QAAAA,IAAI,CAACM,QAAL,CAAcC,GAAd,GAAoBZ,KAAK,CAACW,QAAN,CAAeC,GAAnC;AACD;;AAED,aAAOX,KAAP;AACD;AACF;AACF;;AAED,SAASM,SAAT,CAAmBM,IAAnB,EAAyBf,UAAzB,EAAqC;AACnC,MAAIgB,KAAJ;AACA,MAAIF,GAAJ;;AAEA,MAAIC,IAAI,CAACP,IAAL,KAAc,MAAlB,EAA0B;AACxB,QAAI,CAACO,IAAI,CAACF,QAAV,EAAoB;AAClB,aAAO,IAAP;AACD;;AAEDG,IAAAA,KAAK,GAAGD,IAAI,CAACF,QAAL,CAAcG,KAAtB;AACAF,IAAAA,GAAG,GAAGC,IAAI,CAACF,QAAL,CAAcC,GAApB,CANwB,CAQxB;;AACA,WACEE,KAAK,CAACC,IAAN,KAAeH,GAAG,CAACG,IAAnB,IAA2BH,GAAG,CAACI,MAAJ,GAAaF,KAAK,CAACE,MAAnB,KAA8BH,IAAI,CAACL,KAAL,CAAWS,MADtE;AAGD;;AAED,SAAOnB,UAAU,IAAIe,IAAI,CAACP,IAAL,KAAc,YAAnC;AACD","sourcesContent":["'use strict'\n\nvar visit = require('unist-util-visit')\n\nmodule.exports = compact\n\n// Make an mdast tree compact by merging adjacent text nodes.\nfunction compact(tree, commonmark) {\n  visit(tree, visitor)\n\n  return tree\n\n  function visitor(child, index, parent) {\n    var siblings = parent ? parent.children : []\n    var prev = index && siblings[index - 1]\n\n    if (\n      prev &&\n      child.type === prev.type &&\n      mergeable(prev, commonmark) &&\n      mergeable(child, commonmark)\n    ) {\n      if (child.value) {\n        prev.value += child.value\n      }\n\n      if (child.children) {\n        prev.children = prev.children.concat(child.children)\n      }\n\n      siblings.splice(index, 1)\n\n      if (prev.position && child.position) {\n        prev.position.end = child.position.end\n      }\n\n      return index\n    }\n  }\n}\n\nfunction mergeable(node, commonmark) {\n  var start\n  var end\n\n  if (node.type === 'text') {\n    if (!node.position) {\n      return true\n    }\n\n    start = node.position.start\n    end = node.position.end\n\n    // Only merge nodes which occupy the same size as their `value`.\n    return (\n      start.line !== end.line || end.column - start.column === node.value.length\n    )\n  }\n\n  return commonmark && node.type === 'blockquote'\n}\n"]},"metadata":{},"sourceType":"script"}