{"ast":null,"code":"import _classCallCheck from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n//\n// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.\n//\nimport { ServiceRecognizerBase, SynthesisAdapterBase } from \"../common.speech/Exports\";\nimport { ConnectionMessageImpl } from \"./ConnectionMessage\";\nimport { Contracts } from \"./Contracts\";\nimport { ConnectionEventArgs, ConnectionMessageEventArgs, ServiceEventArgs } from \"./Exports\";\n/**\n * Connection is a proxy class for managing connection to the speech service of the specified Recognizer.\n * By default, a Recognizer autonomously manages connection to service when needed.\n * The Connection class provides additional methods for users to explicitly open or close a connection and\n * to subscribe to connection status changes.\n * The use of Connection is optional, and mainly for scenarios where fine tuning of application\n * behavior based on connection status is needed. Users can optionally call Open() to manually set up a connection\n * in advance before starting recognition on the Recognizer associated with this Connection.\n * If the Recognizer needs to connect or disconnect to service, it will\n * setup or shutdown the connection independently. In this case the Connection will be notified by change of connection\n * status via Connected/Disconnected events.\n * Added in version 1.2.1.\n */\n\nexport var Connection = /*#__PURE__*/function () {\n  function Connection() {\n    _classCallCheck(this, Connection);\n  }\n\n  _createClass(Connection, [{\n    key: \"openConnection\",\n    value:\n    /**\n     * Starts to set up connection to the service.\n     * Users can optionally call openConnection() to manually set up a connection in advance before starting recognition on the\n     * Recognizer associated with this Connection. After starting recognition, calling Open() will have no effect\n     *\n     * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to\n     * be notified when the connection is established.\n     */\n    function openConnection() {\n      this.privInternalData.connect();\n    }\n    /**\n     * Closes the connection the service.\n     * Users can optionally call closeConnection() to manually shutdown the connection of the associated Recognizer.\n     *\n     * If closeConnection() is called during recognition, recognition will fail and cancel with an error.\n     */\n\n  }, {\n    key: \"closeConnection\",\n    value: function closeConnection() {\n      if (this.privInternalData instanceof SynthesisAdapterBase) {\n        throw new Error(\"Disconnecting a synthesizer's connection is currently not supported\");\n      } else {\n        this.privInternalData.disconnect();\n      }\n    }\n    /**\n     * Appends a parameter in a message to service.\n     * Added in version 1.12.1.\n     * @param path The path of the network message.\n     * @param propertyName Name of the property\n     * @param propertyValue Value of the property. This is a json string.\n     */\n\n  }, {\n    key: \"setMessageProperty\",\n    value: function setMessageProperty(path, propertyName, propertyValue) {\n      Contracts.throwIfNullOrWhitespace(propertyName, \"propertyName\");\n\n      if (this.privInternalData instanceof ServiceRecognizerBase) {\n        if (path.toLowerCase() !== \"speech.context\") {\n          throw new Error(\"Only speech.context message property sets are currently supported for recognizer\");\n        } else {\n          this.privInternalData.speechContext.setSection(propertyName, propertyValue);\n        }\n      } else if (this.privInternalData instanceof SynthesisAdapterBase) {\n        if (path.toLowerCase() !== \"synthesis.context\") {\n          throw new Error(\"Only synthesis.context message property sets are currently supported for synthesizer\");\n        } else {\n          this.privInternalData.synthesisContext.setSection(propertyName, propertyValue);\n        }\n      }\n    }\n    /**\n     * Sends a message to the speech service.\n     * Added in version 1.13.0.\n     * @param path The WebSocket path of the message\n     * @param payload The payload of the message. This is a json string or a ArrayBuffer.\n     * @param success A callback to indicate success.\n     * @param error A callback to indicate an error.\n     */\n\n  }, {\n    key: \"sendMessageAsync\",\n    value: function sendMessageAsync(path, payload, success, error) {\n      this.privInternalData.sendNetworkMessage(path, payload, success, error);\n    }\n    /**\n     * Dispose of associated resources.\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      /* tslint:disable:no-empty */\n    }\n  }, {\n    key: \"setupEvents\",\n    value: function setupEvents() {\n      var _this = this;\n\n      this.privEventListener = this.privInternalData.connectionEvents.attach(function (connectionEvent) {\n        if (connectionEvent.name === \"ConnectionEstablishedEvent\") {\n          if (!!_this.connected) {\n            _this.connected(new ConnectionEventArgs(connectionEvent.connectionId));\n          }\n        } else if (connectionEvent.name === \"ConnectionClosedEvent\") {\n          if (!!_this.disconnected) {\n            _this.disconnected(new ConnectionEventArgs(connectionEvent.connectionId));\n          }\n        } else if (connectionEvent.name === \"ConnectionMessageSentEvent\") {\n          if (!!_this.messageSent) {\n            _this.messageSent(new ConnectionMessageEventArgs(new ConnectionMessageImpl(connectionEvent.message)));\n          }\n        } else if (connectionEvent.name === \"ConnectionMessageReceivedEvent\") {\n          if (!!_this.messageReceived) {\n            _this.messageReceived(new ConnectionMessageEventArgs(new ConnectionMessageImpl(connectionEvent.message)));\n          }\n        }\n      });\n      this.privServiceEventListener = this.privInternalData.serviceEvents.attach(function (e) {\n        if (!!_this.receivedServiceMessage) {\n          _this.receivedServiceMessage(new ServiceEventArgs(e.jsonString, e.name));\n        }\n      });\n    }\n  }], [{\n    key: \"fromRecognizer\",\n    value:\n    /**\n     * Gets the Connection instance from the specified recognizer.\n     * @param recognizer The recognizer associated with the connection.\n     * @return The Connection instance of the recognizer.\n     */\n    function fromRecognizer(recognizer) {\n      var recoBase = recognizer.internalData;\n      var ret = new Connection();\n      ret.privInternalData = recoBase;\n      ret.setupEvents();\n      return ret;\n    }\n    /**\n     * Gets the Connection instance from the specified synthesizer.\n     * @param synthesizer The synthesizer associated with the connection.\n     * @return The Connection instance of the synthesizer.\n     */\n\n  }, {\n    key: \"fromSynthesizer\",\n    value: function fromSynthesizer(synthesizer) {\n      var synthBase = synthesizer.internalData;\n      var ret = new Connection();\n      ret.privInternalData = synthBase;\n      ret.setupEvents();\n      return ret;\n    }\n  }]);\n\n  return Connection;\n}();","map":{"version":3,"sources":["src/sdk/Connection.ts"],"names":[],"mappings":"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","sourcesContent":["//\r\n// Copyright (c) Microsoft. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.\r\n//\r\n\r\nimport {\r\n    ServiceRecognizerBase,\r\n    SynthesisAdapterBase,\r\n} from \"../common.speech/Exports\";\r\nimport {\r\n    ConnectionEvent,\r\n    ConnectionMessageReceivedEvent,\r\n    ConnectionMessageSentEvent,\r\n    IDetachable,\r\n    ServiceEvent,\r\n} from \"../common/Exports\";\r\nimport {\r\n    ConnectionMessageImpl\r\n} from \"./ConnectionMessage\";\r\nimport { Contracts } from \"./Contracts\";\r\nimport {\r\n    ConnectionEventArgs,\r\n    ConnectionMessageEventArgs,\r\n    Recognizer,\r\n    ServiceEventArgs,\r\n    SpeechSynthesizer,\r\n} from \"./Exports\";\r\n\r\n/**\r\n * Connection is a proxy class for managing connection to the speech service of the specified Recognizer.\r\n * By default, a Recognizer autonomously manages connection to service when needed.\r\n * The Connection class provides additional methods for users to explicitly open or close a connection and\r\n * to subscribe to connection status changes.\r\n * The use of Connection is optional, and mainly for scenarios where fine tuning of application\r\n * behavior based on connection status is needed. Users can optionally call Open() to manually set up a connection\r\n * in advance before starting recognition on the Recognizer associated with this Connection.\r\n * If the Recognizer needs to connect or disconnect to service, it will\r\n * setup or shutdown the connection independently. In this case the Connection will be notified by change of connection\r\n * status via Connected/Disconnected events.\r\n * Added in version 1.2.1.\r\n */\r\nexport class Connection {\r\n    private privInternalData: ServiceRecognizerBase | SynthesisAdapterBase;\r\n    private privEventListener: IDetachable;\r\n    private privServiceEventListener: IDetachable;\r\n\r\n    /**\r\n     * Gets the Connection instance from the specified recognizer.\r\n     * @param recognizer The recognizer associated with the connection.\r\n     * @return The Connection instance of the recognizer.\r\n     */\r\n    public static fromRecognizer(recognizer: Recognizer): Connection {\r\n        const recoBase: ServiceRecognizerBase = recognizer.internalData as ServiceRecognizerBase;\r\n\r\n        const ret: Connection = new Connection();\r\n\r\n        ret.privInternalData = recoBase;\r\n        ret.setupEvents();\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Gets the Connection instance from the specified synthesizer.\r\n     * @param synthesizer The synthesizer associated with the connection.\r\n     * @return The Connection instance of the synthesizer.\r\n     */\r\n    public static fromSynthesizer(synthesizer: SpeechSynthesizer): Connection {\r\n        const synthBase: SynthesisAdapterBase = synthesizer.internalData as SynthesisAdapterBase;\r\n\r\n        const ret: Connection = new Connection();\r\n\r\n        ret.privInternalData = synthBase;\r\n        ret.setupEvents();\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Starts to set up connection to the service.\r\n     * Users can optionally call openConnection() to manually set up a connection in advance before starting recognition on the\r\n     * Recognizer associated with this Connection. After starting recognition, calling Open() will have no effect\r\n     *\r\n     * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to\r\n     * be notified when the connection is established.\r\n     */\r\n    public openConnection(): void {\r\n        this.privInternalData.connect();\r\n    }\r\n\r\n    /**\r\n     * Closes the connection the service.\r\n     * Users can optionally call closeConnection() to manually shutdown the connection of the associated Recognizer.\r\n     *\r\n     * If closeConnection() is called during recognition, recognition will fail and cancel with an error.\r\n     */\r\n    public closeConnection(): void {\r\n        if (this.privInternalData instanceof SynthesisAdapterBase) {\r\n            throw new Error(\"Disconnecting a synthesizer's connection is currently not supported\");\r\n        } else {\r\n            (this.privInternalData as ServiceRecognizerBase).disconnect();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Appends a parameter in a message to service.\r\n     * Added in version 1.12.1.\r\n     * @param path The path of the network message.\r\n     * @param propertyName Name of the property\r\n     * @param propertyValue Value of the property. This is a json string.\r\n     */\r\n    public setMessageProperty(path: string, propertyName: string, propertyValue: string): void {\r\n        Contracts.throwIfNullOrWhitespace(propertyName, \"propertyName\");\r\n\r\n        if (this.privInternalData instanceof ServiceRecognizerBase) {\r\n            if (path.toLowerCase() !== \"speech.context\") {\r\n                throw new Error(\"Only speech.context message property sets are currently supported for recognizer\");\r\n            } else {\r\n                (this.privInternalData as ServiceRecognizerBase).speechContext.setSection(propertyName, propertyValue);\r\n            }\r\n        } else if (this.privInternalData instanceof SynthesisAdapterBase) {\r\n            if (path.toLowerCase() !== \"synthesis.context\") {\r\n                throw new Error(\"Only synthesis.context message property sets are currently supported for synthesizer\");\r\n            } else {\r\n                (this.privInternalData as SynthesisAdapterBase).synthesisContext.setSection(propertyName, propertyValue);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sends a message to the speech service.\r\n     * Added in version 1.13.0.\r\n     * @param path The WebSocket path of the message\r\n     * @param payload The payload of the message. This is a json string or a ArrayBuffer.\r\n     * @param success A callback to indicate success.\r\n     * @param error A callback to indicate an error.\r\n     */\r\n    public sendMessageAsync(path: string, payload: string | ArrayBuffer, success?: () => void, error?: (error: string) => void): void {\r\n        this.privInternalData.sendNetworkMessage(path, payload, success, error);\r\n    }\r\n\r\n    /**\r\n     * Any message from service that is not being processed by any other top level recognizers.\r\n     *\r\n     * Will be removed in 2.0.\r\n     */\r\n    public receivedServiceMessage: (args: ServiceEventArgs) => void;\r\n\r\n    /**\r\n     * Any message received from the Speech Service.\r\n     */\r\n    public messageReceived: (args: ConnectionMessageEventArgs) => void;\r\n\r\n    /**\r\n     * Any message sent to the Speech Service.\r\n     */\r\n    public messageSent: (args: ConnectionMessageEventArgs) => void;\r\n\r\n    /**\r\n     * The Connected event to indicate that the recognizer is connected to service.\r\n     */\r\n    public connected: (args: ConnectionEventArgs) => void;\r\n\r\n    /**\r\n     * The Disconnected event to indicate that the recognizer is disconnected from service.\r\n     */\r\n    public disconnected: (args: ConnectionEventArgs) => void;\r\n\r\n    /**\r\n     * Dispose of associated resources.\r\n     */\r\n    public close(): void {\r\n        /* tslint:disable:no-empty */\r\n    }\r\n\r\n    private setupEvents(): void {\r\n        this.privEventListener = this.privInternalData.connectionEvents.attach((connectionEvent: ConnectionEvent): void => {\r\n            if (connectionEvent.name === \"ConnectionEstablishedEvent\") {\r\n                if (!!this.connected) {\r\n                    this.connected(new ConnectionEventArgs(connectionEvent.connectionId));\r\n                }\r\n            } else if (connectionEvent.name === \"ConnectionClosedEvent\") {\r\n                if (!!this.disconnected) {\r\n                    this.disconnected(new ConnectionEventArgs(connectionEvent.connectionId));\r\n                }\r\n            } else if (connectionEvent.name === \"ConnectionMessageSentEvent\") {\r\n                if (!!this.messageSent) {\r\n                    this.messageSent(new ConnectionMessageEventArgs(new ConnectionMessageImpl((connectionEvent as ConnectionMessageSentEvent).message)));\r\n                }\r\n            } else if (connectionEvent.name === \"ConnectionMessageReceivedEvent\") {\r\n                if (!!this.messageReceived) {\r\n                    this.messageReceived(new ConnectionMessageEventArgs(new ConnectionMessageImpl((connectionEvent as ConnectionMessageReceivedEvent).message)));\r\n                }\r\n            }\r\n        });\r\n\r\n        this.privServiceEventListener = this.privInternalData.serviceEvents.attach((e: ServiceEvent): void => {\r\n            if (!!this.receivedServiceMessage) {\r\n                this.receivedServiceMessage(new ServiceEventArgs(e.jsonString, e.name));\r\n            }\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}