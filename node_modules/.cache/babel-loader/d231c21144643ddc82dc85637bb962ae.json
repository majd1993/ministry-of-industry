{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { InvalidOperationError, ObjectDisposedError } from \"./Error\";\nimport { List } from \"./List\";\nimport { Deferred, PromiseHelper } from \"./Promise\";\nvar SubscriberType;\n\n(function (SubscriberType) {\n  SubscriberType[SubscriberType[\"Dequeue\"] = 0] = \"Dequeue\";\n  SubscriberType[SubscriberType[\"Peek\"] = 1] = \"Peek\";\n})(SubscriberType || (SubscriberType = {}));\n\nexport var Queue = function Queue(list) {\n  var _this = this;\n\n  _classCallCheck(this, Queue);\n\n  this.privPromiseStore = new List();\n  this.privIsDrainInProgress = false;\n  this.privIsDisposing = false;\n  this.privDisposeReason = null;\n\n  this.enqueue = function (item) {\n    _this.throwIfDispose();\n\n    _this.enqueueFromPromise(PromiseHelper.fromResult(item));\n  };\n\n  this.enqueueFromPromise = function (promise) {\n    _this.throwIfDispose();\n\n    _this.privPromiseStore.add(promise);\n\n    promise.finally(function () {\n      while (_this.privPromiseStore.length() > 0) {\n        if (!_this.privPromiseStore.first().result().isCompleted) {\n          break;\n        } else {\n          var p = _this.privPromiseStore.removeFirst();\n\n          if (!p.result().isError) {\n            _this.privList.add(p.result().result);\n          } else {// TODO: Log as warning.\n          }\n        }\n      }\n    });\n  };\n\n  this.dequeue = function () {\n    _this.throwIfDispose();\n\n    var deferredSubscriber = new Deferred();\n\n    if (_this.privSubscribers) {\n      _this.privSubscribers.add({\n        deferral: deferredSubscriber,\n        type: SubscriberType.Dequeue\n      });\n\n      _this.drain();\n    }\n\n    return deferredSubscriber.promise();\n  };\n\n  this.peek = function () {\n    _this.throwIfDispose();\n\n    var deferredSubscriber = new Deferred();\n    var subs = _this.privSubscribers;\n\n    if (subs) {\n      _this.privSubscribers.add({\n        deferral: deferredSubscriber,\n        type: SubscriberType.Peek\n      });\n\n      _this.drain();\n    }\n\n    return deferredSubscriber.promise();\n  };\n\n  this.length = function () {\n    _this.throwIfDispose();\n\n    return _this.privList.length();\n  };\n\n  this.isDisposed = function () {\n    return _this.privSubscribers == null;\n  };\n\n  this.drainAndDispose = function (pendingItemProcessor, reason) {\n    if (!_this.isDisposed() && !_this.privIsDisposing) {\n      _this.privDisposeReason = reason;\n      _this.privIsDisposing = true;\n      var subs = _this.privSubscribers;\n\n      if (subs) {\n        while (subs.length() > 0) {\n          var subscriber = subs.removeFirst(); // TODO: this needs work (Resolve(null) instead?).\n\n          subscriber.deferral.resolve(undefined); // subscriber.deferral.reject(\"Disposed\");\n        } // note: this block assumes cooperative multitasking, i.e.,\n        // between the if-statement and the assignment there are no\n        // thread switches.\n        // Reason is that between the initial const = this.; and this\n        // point there is the derral.resolve() operation that might have\n        // caused recursive calls to the Queue, especially, calling\n        // Dispose() on the queue alredy (which would reset the var\n        // here to null!).\n        // That should generally hold true for javascript...\n\n\n        if (_this.privSubscribers === subs) {\n          _this.privSubscribers = subs;\n        }\n      }\n\n      var _iterator = _createForOfIteratorHelper(_this.privDetachables),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var detachable = _step.value;\n          detachable.detach();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (_this.privPromiseStore.length() > 0 && pendingItemProcessor) {\n        return PromiseHelper.whenAll(_this.privPromiseStore.toArray()).continueWith(function () {\n          _this.privSubscribers = null;\n\n          _this.privList.forEach(function (item, index) {\n            pendingItemProcessor(item);\n          });\n\n          _this.privList = null;\n          return true;\n        });\n      } else {\n        _this.privSubscribers = null;\n        _this.privList = null;\n      }\n    }\n\n    return PromiseHelper.fromResult(true);\n  };\n\n  this.dispose = function (reason) {\n    _this.drainAndDispose(null, reason);\n  };\n\n  this.drain = function () {\n    if (!_this.privIsDrainInProgress && !_this.privIsDisposing) {\n      _this.privIsDrainInProgress = true;\n      var subs = _this.privSubscribers;\n      var lists = _this.privList;\n\n      if (subs && lists) {\n        while (lists.length() > 0 && subs.length() > 0 && !_this.privIsDisposing) {\n          var subscriber = subs.removeFirst();\n\n          if (subscriber.type === SubscriberType.Peek) {\n            subscriber.deferral.resolve(lists.first());\n          } else {\n            var dequeuedItem = lists.removeFirst();\n            subscriber.deferral.resolve(dequeuedItem);\n          }\n        } // note: this block assumes cooperative multitasking, i.e.,\n        // between the if-statement and the assignment there are no\n        // thread switches.\n        // Reason is that between the initial const = this.; and this\n        // point there is the derral.resolve() operation that might have\n        // caused recursive calls to the Queue, especially, calling\n        // Dispose() on the queue alredy (which would reset the var\n        // here to null!).\n        // That should generally hold true for javascript...\n\n\n        if (_this.privSubscribers === subs) {\n          _this.privSubscribers = subs;\n        } // note: this block assumes cooperative multitasking, i.e.,\n        // between the if-statement and the assignment there are no\n        // thread switches.\n        // Reason is that between the initial const = this.; and this\n        // point there is the derral.resolve() operation that might have\n        // caused recursive calls to the Queue, especially, calling\n        // Dispose() on the queue alredy (which would reset the var\n        // here to null!).\n        // That should generally hold true for javascript...\n\n\n        if (_this.privList === lists) {\n          _this.privList = lists;\n        }\n      }\n\n      _this.privIsDrainInProgress = false;\n    }\n  };\n\n  this.throwIfDispose = function () {\n    if (_this.isDisposed()) {\n      if (_this.privDisposeReason) {\n        throw new InvalidOperationError(_this.privDisposeReason);\n      }\n\n      throw new ObjectDisposedError(\"Queue\");\n    } else if (_this.privIsDisposing) {\n      throw new InvalidOperationError(\"Queue disposing\");\n    }\n  };\n\n  this.privList = list ? list : new List();\n  this.privDetachables = [];\n  this.privSubscribers = new List();\n  this.privDetachables.push(this.privList.onAdded(this.drain));\n};","map":{"version":3,"sources":["src/common/Queue.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { InvalidOperationError, ObjectDisposedError } from \"./Error\";\r\nimport { IDetachable } from \"./IDetachable\";\r\nimport { IDisposable } from \"./IDisposable\";\r\nimport { List } from \"./List\";\r\nimport { Deferred, Promise, PromiseHelper } from \"./Promise\";\r\n\r\nexport interface IQueue<TItem> extends IDisposable {\r\n    enqueue(item: TItem): void;\r\n    enqueueFromPromise(promise: Promise<TItem>): void;\r\n    dequeue(): Promise<TItem>;\r\n    peek(): Promise<TItem>;\r\n    length(): number;\r\n}\r\n\r\nenum SubscriberType {\r\n    Dequeue,\r\n    Peek,\r\n}\r\n\r\nexport class Queue<TItem> implements IQueue<TItem> {\r\n    private privPromiseStore: List<Promise<TItem>> = new List<Promise<TItem>>();\r\n    private privList: List<TItem>;\r\n    private privDetachables: IDetachable[];\r\n    private privSubscribers: List<{ type: SubscriberType, deferral: Deferred<TItem> }>;\r\n    private privIsDrainInProgress: boolean = false;\r\n    private privIsDisposing: boolean = false;\r\n    private privDisposeReason: string = null;\r\n\r\n    public constructor(list?: List<TItem>) {\r\n        this.privList = list ? list : new List<TItem>();\r\n        this.privDetachables = [];\r\n        this.privSubscribers = new List<{ type: SubscriberType, deferral: Deferred<TItem> }>();\r\n        this.privDetachables.push(this.privList.onAdded(this.drain));\r\n    }\r\n\r\n    public enqueue = (item: TItem): void => {\r\n        this.throwIfDispose();\r\n        this.enqueueFromPromise(PromiseHelper.fromResult(item));\r\n    }\r\n\r\n    public enqueueFromPromise = (promise: Promise<TItem>): void => {\r\n        this.throwIfDispose();\r\n        this.privPromiseStore.add(promise);\r\n        promise.finally(() => {\r\n            while (this.privPromiseStore.length() > 0) {\r\n                if (!this.privPromiseStore.first().result().isCompleted) {\r\n                    break;\r\n                } else {\r\n                    const p = this.privPromiseStore.removeFirst();\r\n                    if (!p.result().isError) {\r\n                        this.privList.add(p.result().result);\r\n                    } else {\r\n                        // TODO: Log as warning.\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    public dequeue = (): Promise<TItem> => {\r\n        this.throwIfDispose();\r\n        const deferredSubscriber = new Deferred<TItem>();\r\n\r\n        if (this.privSubscribers) {\r\n            this.privSubscribers.add({ deferral: deferredSubscriber, type: SubscriberType.Dequeue });\r\n            this.drain();\r\n        }\r\n\r\n        return deferredSubscriber.promise();\r\n    }\r\n\r\n    public peek = (): Promise<TItem> => {\r\n        this.throwIfDispose();\r\n        const deferredSubscriber = new Deferred<TItem>();\r\n\r\n        const subs = this.privSubscribers;\r\n        if (subs) {\r\n            this.privSubscribers.add({ deferral: deferredSubscriber, type: SubscriberType.Peek });\r\n            this.drain();\r\n        }\r\n\r\n        return deferredSubscriber.promise();\r\n    }\r\n\r\n    public length = (): number => {\r\n        this.throwIfDispose();\r\n        return this.privList.length();\r\n    }\r\n\r\n    public isDisposed = (): boolean => {\r\n        return this.privSubscribers == null;\r\n    }\r\n\r\n    public drainAndDispose = (pendingItemProcessor: (pendingItemInQueue: TItem) => void, reason?: string): Promise<boolean> => {\r\n        if (!this.isDisposed() && !this.privIsDisposing) {\r\n            this.privDisposeReason = reason;\r\n            this.privIsDisposing = true;\r\n\r\n            const subs = this.privSubscribers;\r\n            if (subs) {\r\n                while (subs.length() > 0) {\r\n                    const subscriber = subs.removeFirst();\r\n                    // TODO: this needs work (Resolve(null) instead?).\r\n                    subscriber.deferral.resolve(undefined);\r\n                    // subscriber.deferral.reject(\"Disposed\");\r\n                }\r\n\r\n                // note: this block assumes cooperative multitasking, i.e.,\r\n                // between the if-statement and the assignment there are no\r\n                // thread switches.\r\n                // Reason is that between the initial const = this.; and this\r\n                // point there is the derral.resolve() operation that might have\r\n                // caused recursive calls to the Queue, especially, calling\r\n                // Dispose() on the queue alredy (which would reset the var\r\n                // here to null!).\r\n                // That should generally hold true for javascript...\r\n                if (this.privSubscribers === subs) {\r\n                    this.privSubscribers = subs;\r\n                }\r\n            }\r\n\r\n            for (const detachable of this.privDetachables) {\r\n                detachable.detach();\r\n            }\r\n\r\n            if (this.privPromiseStore.length() > 0 && pendingItemProcessor) {\r\n                return PromiseHelper\r\n                    .whenAll(this.privPromiseStore.toArray())\r\n                    .continueWith(() => {\r\n                        this.privSubscribers = null;\r\n                        this.privList.forEach((item: TItem, index: number): void => {\r\n                            pendingItemProcessor(item);\r\n                        });\r\n                        this.privList = null;\r\n                        return true;\r\n                    });\r\n            } else {\r\n                this.privSubscribers = null;\r\n                this.privList = null;\r\n            }\r\n        }\r\n\r\n        return PromiseHelper.fromResult(true);\r\n    }\r\n\r\n    public dispose = (reason?: string): void => {\r\n        this.drainAndDispose(null, reason);\r\n    }\r\n\r\n    private drain = (): void => {\r\n        if (!this.privIsDrainInProgress && !this.privIsDisposing) {\r\n            this.privIsDrainInProgress = true;\r\n\r\n            const subs = this.privSubscribers;\r\n            const lists = this.privList;\r\n            if (subs && lists) {\r\n                while (lists.length() > 0 && subs.length() > 0 && !this.privIsDisposing) {\r\n                    const subscriber = subs.removeFirst();\r\n                    if (subscriber.type === SubscriberType.Peek) {\r\n                        subscriber.deferral.resolve(lists.first());\r\n                    } else {\r\n                        const dequeuedItem = lists.removeFirst();\r\n                        subscriber.deferral.resolve(dequeuedItem);\r\n                    }\r\n                }\r\n\r\n                // note: this block assumes cooperative multitasking, i.e.,\r\n                // between the if-statement and the assignment there are no\r\n                // thread switches.\r\n                // Reason is that between the initial const = this.; and this\r\n                // point there is the derral.resolve() operation that might have\r\n                // caused recursive calls to the Queue, especially, calling\r\n                // Dispose() on the queue alredy (which would reset the var\r\n                // here to null!).\r\n                // That should generally hold true for javascript...\r\n                if (this.privSubscribers === subs) {\r\n                    this.privSubscribers = subs;\r\n                }\r\n\r\n                // note: this block assumes cooperative multitasking, i.e.,\r\n                // between the if-statement and the assignment there are no\r\n                // thread switches.\r\n                // Reason is that between the initial const = this.; and this\r\n                // point there is the derral.resolve() operation that might have\r\n                // caused recursive calls to the Queue, especially, calling\r\n                // Dispose() on the queue alredy (which would reset the var\r\n                // here to null!).\r\n                // That should generally hold true for javascript...\r\n                if (this.privList === lists) {\r\n                    this.privList = lists;\r\n                }\r\n            }\r\n\r\n            this.privIsDrainInProgress = false;\r\n        }\r\n    }\r\n\r\n    private throwIfDispose = (): void => {\r\n        if (this.isDisposed()) {\r\n            if (this.privDisposeReason) {\r\n                throw new InvalidOperationError(this.privDisposeReason);\r\n            }\r\n\r\n            throw new ObjectDisposedError(\"Queue\");\r\n        } else if (this.privIsDisposing) {\r\n            throw new InvalidOperationError(\"Queue disposing\");\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}