{"ast":null,"code":"import _classCallCheck from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { SynthesisAdapterBase } from \"../../common.speech/Exports\";\nimport { createNoDashGuid } from \"../../common/Exports\";\nimport { AudioFormatTag } from \"./AudioOutputFormat\";\nimport { PullAudioOutputStreamImpl } from \"./AudioOutputStream\";\nvar MediaDurationPlaceholderSeconds = 60 * 30;\nvar AudioFormatToMimeType = {\n  [AudioFormatTag.PCM]: \"audio/wav\",\n  [AudioFormatTag.MP3]: \"audio/mpeg\",\n  [AudioFormatTag.Opus]: \"audio/ogg\"\n};\n/**\n * Represents the speaker playback audio destination, which only works in browser.\n * Note: the SDK will try to use <a href=\"https://www.w3.org/TR/media-source/\">Media Source Extensions</a> to play audio.\n * Mp3 format has better supports on Microsoft Edge, Chrome and Safari (desktop), so, it's better to specify mp3 format for playback.\n * @class SpeakerAudioDestination\n * Updated in version 1.12.1\n */\n\nexport var SpeakerAudioDestination = /*#__PURE__*/function () {\n  function SpeakerAudioDestination(audioDestinationId) {\n    _classCallCheck(this, SpeakerAudioDestination);\n\n    this.privPlaybackStarted = false;\n    this.privAppendingToBuffer = false;\n    this.privMediaSourceOpened = false;\n    this.privBytesReceived = 0;\n    this.privId = audioDestinationId ? audioDestinationId : createNoDashGuid();\n    this.privIsPaused = false;\n    this.privIsClosed = false;\n  }\n\n  _createClass(SpeakerAudioDestination, [{\n    key: \"id\",\n    value: function id() {\n      return this.privId;\n    }\n  }, {\n    key: \"write\",\n    value: function write(buffer) {\n      if (this.privAudioBuffer !== undefined) {\n        this.privAudioBuffer.push(buffer);\n        this.updateSourceBuffer();\n      } else if (this.privAudioOutputStream !== undefined) {\n        this.privAudioOutputStream.write(buffer);\n        this.privBytesReceived += buffer.byteLength;\n      }\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      this.privIsClosed = true;\n\n      if (this.privSourceBuffer !== undefined) {\n        this.handleSourceBufferUpdateEnd();\n      } else if (this.privAudioOutputStream !== undefined) {\n        var receivedAudio = new ArrayBuffer(this.privBytesReceived);\n        this.privAudioOutputStream.read(receivedAudio);\n\n        if (this.privFormat.hasHeader) {\n          receivedAudio = SynthesisAdapterBase.addHeader(receivedAudio, this.privFormat);\n        }\n\n        var audioBlob = new Blob([receivedAudio], {\n          type: AudioFormatToMimeType[this.privFormat.formatTag]\n        });\n        this.privAudio.src = window.URL.createObjectURL(audioBlob);\n        this.notifyPlayback();\n      }\n    }\n  }, {\n    key: \"format\",\n    set: function set(format) {\n      var _this = this;\n\n      if (typeof AudioContext !== \"undefined\" || typeof window.webkitAudioContext !== \"undefined\") {\n        this.privFormat = format;\n        var mimeType = AudioFormatToMimeType[this.privFormat.formatTag];\n\n        if (mimeType === undefined) {\n          // tslint:disable-next-line:no-console\n          console.warn(\"Unknown mimeType for format \".concat(AudioFormatTag[this.privFormat.formatTag], \".\"));\n        } else if (typeof MediaSource !== \"undefined\" && MediaSource.isTypeSupported(mimeType)) {\n          this.privAudio = new Audio();\n          this.privAudioBuffer = [];\n          this.privMediaSource = new MediaSource();\n          this.privAudio.src = URL.createObjectURL(this.privMediaSource);\n          this.privAudio.load();\n\n          this.privMediaSource.onsourceopen = function (event) {\n            _this.privMediaSourceOpened = true;\n            _this.privMediaSource.duration = MediaDurationPlaceholderSeconds;\n            _this.privSourceBuffer = _this.privMediaSource.addSourceBuffer(mimeType);\n\n            _this.privSourceBuffer.onupdate = function (_) {\n              _this.updateSourceBuffer();\n            };\n\n            _this.privSourceBuffer.onupdateend = function (_) {\n              _this.handleSourceBufferUpdateEnd();\n            };\n\n            _this.privSourceBuffer.onupdatestart = function (_) {\n              _this.privAppendingToBuffer = false;\n            };\n          };\n\n          this.updateSourceBuffer();\n        } else {\n          // tslint:disable-next-line:no-console\n          console.warn(\"Format \".concat(AudioFormatTag[this.privFormat.formatTag], \" could not be played by MSE, streaming playback is not enabled.\"));\n          this.privAudioOutputStream = new PullAudioOutputStreamImpl();\n          this.privAudioOutputStream.format = this.privFormat;\n          this.privAudio = new Audio();\n        }\n      }\n    }\n  }, {\n    key: \"isClosed\",\n    get: function get() {\n      return this.privIsClosed;\n    }\n  }, {\n    key: \"currentTime\",\n    get: function get() {\n      if (this.privAudio !== undefined) {\n        return this.privAudio.currentTime;\n      }\n\n      return -1;\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      if (!this.privIsPaused && this.privAudio !== undefined) {\n        this.privAudio.pause();\n        this.privIsPaused = true;\n      }\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      if (this.privIsPaused && this.privAudio !== undefined) {\n        this.privAudio.play();\n        this.privIsPaused = false;\n      }\n    }\n  }, {\n    key: \"internalAudio\",\n    get: function get() {\n      return this.privAudio;\n    }\n  }, {\n    key: \"updateSourceBuffer\",\n    value: function updateSourceBuffer() {\n      if (this.privAudioBuffer !== undefined && this.privAudioBuffer.length > 0 && this.sourceBufferAvailable()) {\n        this.privAppendingToBuffer = true;\n        var binary = this.privAudioBuffer.shift();\n\n        try {\n          this.privSourceBuffer.appendBuffer(binary);\n        } catch (error) {\n          this.privAudioBuffer.unshift(binary); // tslint:disable-next-line:no-console\n\n          console.log(\"buffer filled, pausing addition of binaries until space is made\");\n          return;\n        }\n\n        this.notifyPlayback();\n      } else if (this.canEndStream()) {\n        this.handleSourceBufferUpdateEnd();\n      }\n    }\n  }, {\n    key: \"handleSourceBufferUpdateEnd\",\n    value: function handleSourceBufferUpdateEnd() {\n      if (this.canEndStream() && this.sourceBufferAvailable()) {\n        this.privMediaSource.endOfStream();\n        this.notifyPlayback();\n      }\n    }\n  }, {\n    key: \"notifyPlayback\",\n    value: function notifyPlayback() {\n      var _this2 = this;\n\n      if (!this.privPlaybackStarted && this.privAudio !== undefined) {\n        this.privAudio.onended = function () {\n          if (!!_this2.onAudioEnd) {\n            _this2.onAudioEnd(_this2);\n          }\n        };\n\n        if (!this.privIsPaused) {\n          this.privAudio.play();\n        }\n\n        this.privPlaybackStarted = true;\n      }\n    }\n  }, {\n    key: \"canEndStream\",\n    value: function canEndStream() {\n      return this.isClosed && this.privSourceBuffer !== undefined && this.privAudioBuffer.length === 0 && this.privMediaSourceOpened && !this.privAppendingToBuffer && this.privMediaSource.readyState === \"open\";\n    }\n  }, {\n    key: \"sourceBufferAvailable\",\n    value: function sourceBufferAvailable() {\n      return this.privSourceBuffer !== undefined && !this.privSourceBuffer.updating;\n    }\n  }]);\n\n  return SpeakerAudioDestination;\n}();","map":{"version":3,"sources":["src/sdk/Audio/SpeakerAudioDestination.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { SynthesisAdapterBase } from \"../../common.speech/Exports\";\r\nimport {\r\n    createNoDashGuid,\r\n    IAudioDestination,\r\n    INumberDictionary\r\n} from \"../../common/Exports\";\r\nimport { AudioStreamFormat, IPlayer } from \"../Exports\";\r\nimport { AudioFormatTag, AudioOutputFormatImpl } from \"./AudioOutputFormat\";\r\nimport { PullAudioOutputStreamImpl } from \"./AudioOutputStream\";\r\n\r\nconst MediaDurationPlaceholderSeconds = 60 * 30;\r\n\r\nconst AudioFormatToMimeType: INumberDictionary<string> = {\r\n    [AudioFormatTag.PCM]: \"audio/wav\",\r\n    [AudioFormatTag.MP3]: \"audio/mpeg\",\r\n    [AudioFormatTag.Opus]: \"audio/ogg\",\r\n};\r\n\r\n/**\r\n * Represents the speaker playback audio destination, which only works in browser.\r\n * Note: the SDK will try to use <a href=\"https://www.w3.org/TR/media-source/\">Media Source Extensions</a> to play audio.\r\n * Mp3 format has better supports on Microsoft Edge, Chrome and Safari (desktop), so, it's better to specify mp3 format for playback.\r\n * @class SpeakerAudioDestination\r\n * Updated in version 1.12.1\r\n */\r\nexport class SpeakerAudioDestination implements IAudioDestination, IPlayer {\r\n    private readonly privId: string;\r\n    private privFormat: AudioOutputFormatImpl;\r\n    private privAudio: HTMLAudioElement;\r\n    private privMediaSource: MediaSource;\r\n    private privSourceBuffer: SourceBuffer;\r\n    private privPlaybackStarted: boolean = false;\r\n    private privAudioBuffer: ArrayBuffer[];\r\n    private privAppendingToBuffer: boolean = false;\r\n    private privMediaSourceOpened: boolean = false;\r\n    private privIsClosed: boolean;\r\n    private privIsPaused: boolean;\r\n    private privAudioOutputStream: PullAudioOutputStreamImpl;\r\n    private privBytesReceived: number = 0;\r\n\r\n    public constructor(audioDestinationId?: string) {\r\n        this.privId = audioDestinationId ? audioDestinationId : createNoDashGuid();\r\n        this.privIsPaused = false;\r\n        this.privIsClosed = false;\r\n    }\r\n\r\n    public id(): string {\r\n        return this.privId;\r\n    }\r\n\r\n    public write(buffer: ArrayBuffer): void {\r\n        if (this.privAudioBuffer !== undefined) {\r\n            this.privAudioBuffer.push(buffer);\r\n            this.updateSourceBuffer();\r\n        } else if (this.privAudioOutputStream !== undefined) {\r\n            this.privAudioOutputStream.write(buffer);\r\n            this.privBytesReceived += buffer.byteLength;\r\n        }\r\n    }\r\n\r\n    public close(): void {\r\n        this.privIsClosed = true;\r\n        if (this.privSourceBuffer !== undefined) {\r\n            this.handleSourceBufferUpdateEnd();\r\n        } else if (this.privAudioOutputStream !== undefined) {\r\n            let receivedAudio = new ArrayBuffer(this.privBytesReceived);\r\n            this.privAudioOutputStream.read(receivedAudio);\r\n            if (this.privFormat.hasHeader) {\r\n                receivedAudio = SynthesisAdapterBase.addHeader(receivedAudio, this.privFormat);\r\n            }\r\n            const audioBlob = new Blob([receivedAudio], { type: AudioFormatToMimeType[this.privFormat.formatTag] });\r\n            this.privAudio.src = window.URL.createObjectURL(audioBlob);\r\n            this.notifyPlayback();\r\n        }\r\n    }\r\n\r\n    set format(format: AudioStreamFormat) {\r\n        if (typeof (AudioContext) !== \"undefined\" || typeof ((window as any).webkitAudioContext) !== \"undefined\") {\r\n            this.privFormat = format as AudioOutputFormatImpl;\r\n            const mimeType: string = AudioFormatToMimeType[this.privFormat.formatTag];\r\n            if (mimeType === undefined) {\r\n                // tslint:disable-next-line:no-console\r\n                console.warn(\r\n                    `Unknown mimeType for format ${AudioFormatTag[this.privFormat.formatTag]}.`);\r\n\r\n            } else if (typeof(MediaSource) !== \"undefined\" && MediaSource.isTypeSupported(mimeType)) {\r\n                this.privAudio = new Audio();\r\n                this.privAudioBuffer = [];\r\n                this.privMediaSource = new MediaSource();\r\n                this.privAudio.src = URL.createObjectURL(this.privMediaSource);\r\n                this.privAudio.load();\r\n                this.privMediaSource.onsourceopen = (event: Event): void => {\r\n                    this.privMediaSourceOpened = true;\r\n                    this.privMediaSource.duration = MediaDurationPlaceholderSeconds;\r\n                    this.privSourceBuffer = this.privMediaSource.addSourceBuffer(mimeType);\r\n                    this.privSourceBuffer.onupdate = (_: Event) => {\r\n                        this.updateSourceBuffer();\r\n                    };\r\n                    this.privSourceBuffer.onupdateend = (_: Event) => {\r\n                        this.handleSourceBufferUpdateEnd();\r\n                    };\r\n                    this.privSourceBuffer.onupdatestart = (_: Event) => {\r\n                        this.privAppendingToBuffer = false;\r\n                    };\r\n                };\r\n                this.updateSourceBuffer();\r\n            } else {\r\n                // tslint:disable-next-line:no-console\r\n                console.warn(\r\n                    `Format ${AudioFormatTag[this.privFormat.formatTag]} could not be played by MSE, streaming playback is not enabled.`);\r\n                this.privAudioOutputStream = new PullAudioOutputStreamImpl();\r\n                this.privAudioOutputStream.format = this.privFormat;\r\n                this.privAudio = new Audio();\r\n            }\r\n        }\r\n    }\r\n\r\n    public get isClosed(): boolean {\r\n        return this.privIsClosed;\r\n    }\r\n\r\n    public get currentTime(): number {\r\n        if (this.privAudio !== undefined) {\r\n            return this.privAudio.currentTime;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    public pause(): void {\r\n        if (!this.privIsPaused && this.privAudio !== undefined) {\r\n            this.privAudio.pause();\r\n            this.privIsPaused = true;\r\n        }\r\n    }\r\n\r\n    public resume(): void {\r\n        if (this.privIsPaused && this.privAudio !== undefined) {\r\n            this.privAudio.play();\r\n            this.privIsPaused = false;\r\n        }\r\n    }\r\n\r\n    public onAudioEnd: (sender: IPlayer) => void;\r\n\r\n    public get internalAudio(): HTMLAudioElement {\r\n        return this.privAudio;\r\n    }\r\n\r\n    private updateSourceBuffer(): void {\r\n        if (this.privAudioBuffer !== undefined && (this.privAudioBuffer.length > 0) && this.sourceBufferAvailable()) {\r\n            this.privAppendingToBuffer = true;\r\n            const binary = this.privAudioBuffer.shift();\r\n            try {\r\n                this.privSourceBuffer.appendBuffer(binary);\r\n            } catch (error) {\r\n                this.privAudioBuffer.unshift(binary);\r\n                // tslint:disable-next-line:no-console\r\n                console.log(\r\n                    \"buffer filled, pausing addition of binaries until space is made\");\r\n                return;\r\n            }\r\n            this.notifyPlayback();\r\n        } else if (this.canEndStream()) {\r\n            this.handleSourceBufferUpdateEnd();\r\n        }\r\n    }\r\n\r\n    private handleSourceBufferUpdateEnd(): void {\r\n        if (this.canEndStream() && this.sourceBufferAvailable()) {\r\n            this.privMediaSource.endOfStream();\r\n            this.notifyPlayback();\r\n        }\r\n    }\r\n\r\n    private notifyPlayback(): void {\r\n        if (!this.privPlaybackStarted && this.privAudio !== undefined) {\r\n            this.privAudio.onended = (): void => {\r\n                if (!!this.onAudioEnd) {\r\n                    this.onAudioEnd(this);\r\n                }\r\n            };\r\n            if (!this.privIsPaused) {\r\n                this.privAudio.play();\r\n            }\r\n            this.privPlaybackStarted = true;\r\n        }\r\n    }\r\n\r\n    private canEndStream(): boolean {\r\n        return (this.isClosed && this.privSourceBuffer !== undefined && (this.privAudioBuffer.length === 0)\r\n            && this.privMediaSourceOpened && !this.privAppendingToBuffer && this.privMediaSource.readyState === \"open\");\r\n    }\r\n\r\n    private sourceBufferAvailable(): boolean {\r\n        return (this.privSourceBuffer !== undefined && !this.privSourceBuffer.updating);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}