{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/Ubility/Desktop/ministry-of-industry-and-advanced-technology/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { connectivity, type } from \"../common.speech/Exports\";\nimport { AudioSourceErrorEvent, AudioSourceInitializingEvent, AudioSourceOffEvent, AudioSourceReadyEvent, AudioStreamNodeAttachedEvent, AudioStreamNodeAttachingEvent, AudioStreamNodeDetachedEvent, AudioStreamNodeErrorEvent, ChunkedArrayBufferStream, createNoDashGuid, Deferred, Events, EventSource, PromiseHelper } from \"../common/Exports\";\nimport { AudioStreamFormat } from \"../sdk/Audio/AudioStreamFormat\";\nexport var AudioWorkletSourceURLPropertyName = \"MICROPHONE-WorkletSourceUrl\";\nexport var MicAudioSource = /*#__PURE__*/function () {\n  function MicAudioSource(privRecorder, deviceId, audioSourceId) {\n    var _this = this;\n\n    _classCallCheck(this, MicAudioSource);\n\n    this.privRecorder = privRecorder;\n    this.deviceId = deviceId;\n    this.privStreams = {};\n\n    this.turnOn = function () {\n      if (_this.privInitializeDeferral) {\n        return _this.privInitializeDeferral.promise();\n      }\n\n      _this.privInitializeDeferral = new Deferred();\n\n      try {\n        _this.createAudioContext();\n      } catch (error) {\n        if (error instanceof Error) {\n          var typedError = error;\n\n          _this.privInitializeDeferral.reject(typedError.name + \": \" + typedError.message);\n        } else {\n          _this.privInitializeDeferral.reject(error);\n        }\n\n        return _this.privInitializeDeferral.promise();\n      }\n\n      var nav = window.navigator;\n      var getUserMedia = nav.getUserMedia || nav.webkitGetUserMedia || nav.mozGetUserMedia || nav.msGetUserMedia;\n\n      if (!!nav.mediaDevices) {\n        getUserMedia = function getUserMedia(constraints, successCallback, errorCallback) {\n          nav.mediaDevices.getUserMedia(constraints).then(successCallback).catch(errorCallback);\n        };\n      }\n\n      if (!getUserMedia) {\n        var errorMsg = \"Browser does not support getUserMedia.\";\n\n        _this.privInitializeDeferral.reject(errorMsg);\n\n        _this.onEvent(new AudioSourceErrorEvent(errorMsg, \"\")); // mic initialized error - no streamid at this point\n\n      } else {\n        var next = function next() {\n          _this.onEvent(new AudioSourceInitializingEvent(_this.privId)); // no stream id\n\n\n          getUserMedia({\n            audio: _this.deviceId ? {\n              deviceId: _this.deviceId\n            } : true,\n            video: false\n          }, function (mediaStream) {\n            _this.privMediaStream = mediaStream;\n\n            _this.onEvent(new AudioSourceReadyEvent(_this.privId));\n\n            _this.privInitializeDeferral.resolve(true);\n          }, function (error) {\n            var errorMsg = \"Error occurred during microphone initialization: \".concat(error);\n            var tmp = _this.privInitializeDeferral; // HACK: this should be handled through onError callbacks of all promises up the stack.\n            // Unfortunately, the current implementation does not provide an easy way to reject promises\n            // without a lot of code replication.\n            // TODO: fix promise implementation, allow for a graceful reject chaining.\n\n            _this.privInitializeDeferral = null;\n            tmp.reject(errorMsg); // this will bubble up through the whole chain of promises,\n            // with each new level adding extra \"Unhandled callback error\" prefix to the error message.\n            // The following line is not guaranteed to be executed.\n\n            _this.onEvent(new AudioSourceErrorEvent(_this.privId, errorMsg));\n          });\n        };\n\n        if (_this.privContext.state === \"suspended\") {\n          // NOTE: On iOS, the Web Audio API requires sounds to be triggered from an explicit user action.\n          // https://github.com/WebAudio/web-audio-api/issues/790\n          _this.privContext.resume().then(next, function (reason) {\n            _this.privInitializeDeferral.reject(\"Failed to initialize audio context: \".concat(reason));\n          });\n        } else {\n          next();\n        }\n      }\n\n      return _this.privInitializeDeferral.promise();\n    };\n\n    this.id = function () {\n      return _this.privId;\n    };\n\n    this.attach = function (audioNodeId) {\n      _this.onEvent(new AudioStreamNodeAttachingEvent(_this.privId, audioNodeId));\n\n      return _this.listen(audioNodeId).onSuccessContinueWith(function (stream) {\n        _this.onEvent(new AudioStreamNodeAttachedEvent(_this.privId, audioNodeId));\n\n        return {\n          detach: function detach() {\n            stream.readEnded();\n\n            _this.turnOff();\n\n            delete _this.privStreams[audioNodeId];\n\n            _this.onEvent(new AudioStreamNodeDetachedEvent(_this.privId, audioNodeId));\n          },\n          id: function id() {\n            return audioNodeId;\n          },\n          read: function read() {\n            return stream.read();\n          }\n        };\n      });\n    };\n\n    this.detach = function (audioNodeId) {\n      if (audioNodeId && _this.privStreams[audioNodeId]) {\n        _this.privStreams[audioNodeId].close();\n\n        delete _this.privStreams[audioNodeId];\n\n        _this.onEvent(new AudioStreamNodeDetachedEvent(_this.privId, audioNodeId));\n      }\n    };\n\n    this.turnOff = function () {\n      for (var streamId in _this.privStreams) {\n        if (streamId) {\n          var stream = _this.privStreams[streamId];\n\n          if (stream) {\n            stream.close();\n          }\n        }\n      }\n\n      _this.onEvent(new AudioSourceOffEvent(_this.privId)); // no stream now\n\n\n      _this.privInitializeDeferral = null;\n\n      _this.destroyAudioContext();\n\n      return PromiseHelper.fromResult(true);\n    };\n\n    this.listen = function (audioNodeId) {\n      return _this.turnOn().onSuccessContinueWith(function (_) {\n        var stream = new ChunkedArrayBufferStream(_this.privOutputChunkSize, audioNodeId);\n        _this.privStreams[audioNodeId] = stream;\n\n        try {\n          _this.privRecorder.record(_this.privContext, _this.privMediaStream, stream);\n        } catch (error) {\n          _this.onEvent(new AudioStreamNodeErrorEvent(_this.privId, audioNodeId, error));\n\n          throw error;\n        }\n\n        return stream;\n      });\n    };\n\n    this.onEvent = function (event) {\n      _this.privEvents.onEvent(event);\n\n      Events.instance.onEvent(event);\n    };\n\n    this.createAudioContext = function () {\n      if (!!_this.privContext) {\n        return;\n      } // https://developer.mozilla.org/en-US/docs/Web/API/AudioContext\n\n\n      if (typeof AudioContext === \"undefined\") {\n        throw new Error(\"Browser does not support Web Audio API (AudioContext is not available).\");\n      } // Browsers without sampleRate constraint support can't connect nodes with different sample rates\n\n\n      if (navigator.mediaDevices.getSupportedConstraints().sampleRate) {\n        _this.privContext = new AudioContext({\n          sampleRate: MicAudioSource.AUDIOFORMAT.samplesPerSec\n        });\n      } else {\n        _this.privContext = new AudioContext();\n      }\n    };\n\n    this.destroyAudioContext = function () {\n      if (!_this.privContext) {\n        return;\n      }\n\n      _this.privRecorder.releaseMediaResources(_this.privContext); // This pattern brought to you by a bug in the TypeScript compiler where it\n      // confuses the (\"close\" in this.privContext) with this.privContext always being null as the alternate.\n      // https://github.com/Microsoft/TypeScript/issues/11498\n\n\n      var hasClose = false;\n\n      if (\"close\" in _this.privContext) {\n        hasClose = true;\n      }\n\n      if (hasClose) {\n        _this.privContext.close();\n\n        _this.privContext = null;\n      } else if (null !== _this.privContext && _this.privContext.state === \"running\") {\n        // Suspend actually takes a callback, but analogous to the\n        // resume method, it'll be only fired if suspend is called\n        // in a direct response to a user action. The later is not always\n        // the case, as TurnOff is also called, when we receive an\n        // end-of-speech message from the service. So, doing a best effort\n        // fire-and-forget here.\n        _this.privContext.suspend();\n      }\n    };\n\n    this.privOutputChunkSize = MicAudioSource.AUDIOFORMAT.avgBytesPerSec / 10;\n    this.privId = audioSourceId ? audioSourceId : createNoDashGuid();\n    this.privEvents = new EventSource();\n  }\n\n  _createClass(MicAudioSource, [{\n    key: \"format\",\n    get: function get() {\n      return PromiseHelper.fromResult(MicAudioSource.AUDIOFORMAT);\n    }\n  }, {\n    key: \"blob\",\n    get: function get() {\n      return PromiseHelper.fromError(\"Not implemented for Mic input\");\n    }\n  }, {\n    key: \"events\",\n    get: function get() {\n      return this.privEvents;\n    }\n  }, {\n    key: \"deviceInfo\",\n    get: function get() {\n      return this.getMicrophoneLabel().onSuccessContinueWith(function (label) {\n        return {\n          bitspersample: MicAudioSource.AUDIOFORMAT.bitsPerSample,\n          channelcount: MicAudioSource.AUDIOFORMAT.channels,\n          connectivity: connectivity.Unknown,\n          manufacturer: \"Speech SDK\",\n          model: label,\n          samplerate: MicAudioSource.AUDIOFORMAT.samplesPerSec,\n          type: type.Microphones\n        };\n      });\n    }\n  }, {\n    key: \"setProperty\",\n    value: function setProperty(name, value) {\n      if (name === AudioWorkletSourceURLPropertyName) {\n        this.privRecorder.setWorkletUrl(value);\n      } else {\n        throw new Error(\"Property '\" + name + \"' is not supported on Microphone.\");\n      }\n    }\n  }, {\n    key: \"getMicrophoneLabel\",\n    value: function getMicrophoneLabel() {\n      var _this2 = this;\n\n      var defaultMicrophoneName = \"microphone\"; // If we did this already, return the value.\n\n      if (this.privMicrophoneLabel !== undefined) {\n        return PromiseHelper.fromResult(this.privMicrophoneLabel);\n      } // If the stream isn't currently running, we can't query devices because security.\n\n\n      if (this.privMediaStream === undefined || !this.privMediaStream.active) {\n        return PromiseHelper.fromResult(defaultMicrophoneName);\n      } // Setup a default\n\n\n      this.privMicrophoneLabel = defaultMicrophoneName; // Get the id of the device running the audio track.\n\n      var microphoneDeviceId = this.privMediaStream.getTracks()[0].getSettings().deviceId; // If the browser doesn't support getting the device ID, set a default and return.\n\n      if (undefined === microphoneDeviceId) {\n        return PromiseHelper.fromResult(this.privMicrophoneLabel);\n      }\n\n      var deferred = new Deferred(); // Enumerate the media devices.\n\n      navigator.mediaDevices.enumerateDevices().then(function (devices) {\n        var _iterator = _createForOfIteratorHelper(devices),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var device = _step.value;\n\n            if (device.deviceId === microphoneDeviceId) {\n              // Found the device\n              _this2.privMicrophoneLabel = device.label;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        deferred.resolve(_this2.privMicrophoneLabel);\n      }, function () {\n        return deferred.resolve(_this2.privMicrophoneLabel);\n      });\n      return deferred.promise();\n    }\n  }]);\n\n  return MicAudioSource;\n}();\nMicAudioSource.AUDIOFORMAT = AudioStreamFormat.getDefaultInputFormat();","map":{"version":3,"sources":["src/common.browser/MicAudioSource.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    connectivity,\r\n    ISpeechConfigAudioDevice,\r\n    type\r\n} from \"../common.speech/Exports\";\r\nimport {\r\n    AudioSourceErrorEvent,\r\n    AudioSourceEvent,\r\n    AudioSourceInitializingEvent,\r\n    AudioSourceOffEvent,\r\n    AudioSourceReadyEvent,\r\n    AudioStreamNodeAttachedEvent,\r\n    AudioStreamNodeAttachingEvent,\r\n    AudioStreamNodeDetachedEvent,\r\n    AudioStreamNodeErrorEvent,\r\n    ChunkedArrayBufferStream,\r\n    createNoDashGuid,\r\n    Deferred,\r\n    Events,\r\n    EventSource,\r\n    IAudioSource,\r\n    IAudioStreamNode,\r\n    IStringDictionary,\r\n    Promise,\r\n    PromiseHelper,\r\n    Stream,\r\n} from \"../common/Exports\";\r\nimport {\r\n    AudioStreamFormat,\r\n    AudioStreamFormatImpl,\r\n} from \"../sdk/Audio/AudioStreamFormat\";\r\nimport { IRecorder } from \"./IRecorder\";\r\n\r\n// Extending the default definition with browser specific definitions for backward compatibility\r\ninterface INavigator extends Navigator {\r\n    webkitGetUserMedia?: (constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback, errorCallback: NavigatorUserMediaErrorCallback) => void;\r\n    mozGetUserMedia?: (constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback, errorCallback: NavigatorUserMediaErrorCallback) => void;\r\n    msGetUserMedia?: (constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback, errorCallback: NavigatorUserMediaErrorCallback) => void;\r\n}\r\n\r\nexport const AudioWorkletSourceURLPropertyName = \"MICROPHONE-WorkletSourceUrl\";\r\n\r\nexport class MicAudioSource implements IAudioSource {\r\n\r\n    private static readonly AUDIOFORMAT: AudioStreamFormatImpl = AudioStreamFormat.getDefaultInputFormat() as AudioStreamFormatImpl;\r\n\r\n    private privStreams: IStringDictionary<Stream<ArrayBuffer>> = {};\r\n\r\n    private privId: string;\r\n\r\n    private privEvents: EventSource<AudioSourceEvent>;\r\n\r\n    private privInitializeDeferral: Deferred<boolean>;\r\n\r\n    private privMediaStream: MediaStream;\r\n\r\n    private privContext: AudioContext;\r\n\r\n    private privMicrophoneLabel: string;\r\n\r\n    private privOutputChunkSize: number;\r\n\r\n    public constructor(\r\n        private readonly privRecorder: IRecorder,\r\n        private readonly deviceId?: string,\r\n        audioSourceId?: string) {\r\n\r\n        this.privOutputChunkSize = MicAudioSource.AUDIOFORMAT.avgBytesPerSec / 10;\r\n        this.privId = audioSourceId ? audioSourceId : createNoDashGuid();\r\n        this.privEvents = new EventSource<AudioSourceEvent>();\r\n    }\r\n\r\n    public get format(): Promise<AudioStreamFormatImpl> {\r\n        return PromiseHelper.fromResult(MicAudioSource.AUDIOFORMAT);\r\n    }\r\n\r\n    public get blob(): Promise<Blob> {\r\n        return PromiseHelper.fromError(\"Not implemented for Mic input\");\r\n    }\r\n\r\n    public turnOn = (): Promise<boolean> => {\r\n        if (this.privInitializeDeferral) {\r\n            return this.privInitializeDeferral.promise();\r\n        }\r\n\r\n        this.privInitializeDeferral = new Deferred<boolean>();\r\n\r\n        try {\r\n            this.createAudioContext();\r\n        } catch (error) {\r\n            if (error instanceof Error) {\r\n                const typedError: Error = error as Error;\r\n                this.privInitializeDeferral.reject(typedError.name + \": \" + typedError.message);\r\n            } else {\r\n                this.privInitializeDeferral.reject(error);\r\n            }\r\n            return this.privInitializeDeferral.promise();\r\n        }\r\n\r\n        const nav = window.navigator as INavigator;\r\n\r\n        let getUserMedia = (\r\n            nav.getUserMedia ||\r\n            nav.webkitGetUserMedia ||\r\n            nav.mozGetUserMedia ||\r\n            nav.msGetUserMedia\r\n        );\r\n\r\n        if (!!nav.mediaDevices) {\r\n            getUserMedia = (constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback, errorCallback: NavigatorUserMediaErrorCallback): void => {\r\n                nav.mediaDevices\r\n                    .getUserMedia(constraints)\r\n                    .then(successCallback)\r\n                    .catch(errorCallback);\r\n            };\r\n        }\r\n\r\n        if (!getUserMedia) {\r\n            const errorMsg = \"Browser does not support getUserMedia.\";\r\n            this.privInitializeDeferral.reject(errorMsg);\r\n            this.onEvent(new AudioSourceErrorEvent(errorMsg, \"\")); // mic initialized error - no streamid at this point\r\n        } else {\r\n            const next = () => {\r\n                this.onEvent(new AudioSourceInitializingEvent(this.privId)); // no stream id\r\n                getUserMedia(\r\n                    { audio: this.deviceId ? { deviceId: this.deviceId } : true, video: false },\r\n                    (mediaStream: MediaStream) => {\r\n                        this.privMediaStream = mediaStream;\r\n                        this.onEvent(new AudioSourceReadyEvent(this.privId));\r\n                        this.privInitializeDeferral.resolve(true);\r\n                    }, (error: MediaStreamError) => {\r\n                        const errorMsg = `Error occurred during microphone initialization: ${error}`;\r\n                        const tmp = this.privInitializeDeferral;\r\n                        // HACK: this should be handled through onError callbacks of all promises up the stack.\r\n                        // Unfortunately, the current implementation does not provide an easy way to reject promises\r\n                        // without a lot of code replication.\r\n                        // TODO: fix promise implementation, allow for a graceful reject chaining.\r\n                        this.privInitializeDeferral = null;\r\n                        tmp.reject(errorMsg); // this will bubble up through the whole chain of promises,\r\n                        // with each new level adding extra \"Unhandled callback error\" prefix to the error message.\r\n                        // The following line is not guaranteed to be executed.\r\n                        this.onEvent(new AudioSourceErrorEvent(this.privId, errorMsg));\r\n                    });\r\n            };\r\n\r\n            if (this.privContext.state === \"suspended\") {\r\n                // NOTE: On iOS, the Web Audio API requires sounds to be triggered from an explicit user action.\r\n                // https://github.com/WebAudio/web-audio-api/issues/790\r\n                this.privContext.resume().then(next, (reason: any) => {\r\n                    this.privInitializeDeferral.reject(`Failed to initialize audio context: ${reason}`);\r\n                });\r\n            } else {\r\n                next();\r\n            }\r\n        }\r\n\r\n        return this.privInitializeDeferral.promise();\r\n    }\r\n\r\n    public id = (): string => {\r\n        return this.privId;\r\n    }\r\n\r\n    public attach = (audioNodeId: string): Promise<IAudioStreamNode> => {\r\n        this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\r\n\r\n        return this.listen(audioNodeId).onSuccessContinueWith<IAudioStreamNode>(\r\n            (stream: Stream<ArrayBuffer>) => {\r\n                this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\r\n                return {\r\n                    detach: () => {\r\n                        stream.readEnded();\r\n                        this.turnOff();\r\n                        delete this.privStreams[audioNodeId];\r\n                        this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\r\n                    },\r\n                    id: () => {\r\n                        return audioNodeId;\r\n                    },\r\n                    read: () => {\r\n                        return stream.read();\r\n                    },\r\n                };\r\n            });\r\n    }\r\n\r\n    public detach = (audioNodeId: string): void => {\r\n        if (audioNodeId && this.privStreams[audioNodeId]) {\r\n            this.privStreams[audioNodeId].close();\r\n            delete this.privStreams[audioNodeId];\r\n            this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\r\n        }\r\n    }\r\n\r\n    public turnOff = (): Promise<boolean> => {\r\n        for (const streamId in this.privStreams) {\r\n            if (streamId) {\r\n                const stream = this.privStreams[streamId];\r\n                if (stream) {\r\n                    stream.close();\r\n                }\r\n            }\r\n        }\r\n\r\n        this.onEvent(new AudioSourceOffEvent(this.privId)); // no stream now\r\n        this.privInitializeDeferral = null;\r\n\r\n        this.destroyAudioContext();\r\n\r\n        return PromiseHelper.fromResult(true);\r\n    }\r\n\r\n    public get events(): EventSource<AudioSourceEvent> {\r\n        return this.privEvents;\r\n    }\r\n\r\n    public get deviceInfo(): Promise<ISpeechConfigAudioDevice> {\r\n        return this.getMicrophoneLabel().onSuccessContinueWith((label: string) => {\r\n            return {\r\n                bitspersample: MicAudioSource.AUDIOFORMAT.bitsPerSample,\r\n                channelcount: MicAudioSource.AUDIOFORMAT.channels,\r\n                connectivity: connectivity.Unknown,\r\n                manufacturer: \"Speech SDK\",\r\n                model: label,\r\n                samplerate: MicAudioSource.AUDIOFORMAT.samplesPerSec,\r\n                type: type.Microphones,\r\n            };\r\n        });\r\n    }\r\n\r\n    public setProperty(name: string, value: string): void {\r\n        if (name === AudioWorkletSourceURLPropertyName) {\r\n            this.privRecorder.setWorkletUrl(value);\r\n        } else {\r\n            throw new Error(\"Property '\" + name + \"' is not supported on Microphone.\");\r\n        }\r\n    }\r\n\r\n    private getMicrophoneLabel(): Promise<string> {\r\n        const defaultMicrophoneName: string = \"microphone\";\r\n\r\n        // If we did this already, return the value.\r\n        if (this.privMicrophoneLabel !== undefined) {\r\n            return PromiseHelper.fromResult(this.privMicrophoneLabel);\r\n        }\r\n\r\n        // If the stream isn't currently running, we can't query devices because security.\r\n        if (this.privMediaStream === undefined || !this.privMediaStream.active) {\r\n            return PromiseHelper.fromResult(defaultMicrophoneName);\r\n        }\r\n\r\n        // Setup a default\r\n        this.privMicrophoneLabel = defaultMicrophoneName;\r\n\r\n        // Get the id of the device running the audio track.\r\n        const microphoneDeviceId: string = this.privMediaStream.getTracks()[0].getSettings().deviceId;\r\n\r\n        // If the browser doesn't support getting the device ID, set a default and return.\r\n        if (undefined === microphoneDeviceId) {\r\n            return PromiseHelper.fromResult(this.privMicrophoneLabel);\r\n        }\r\n\r\n        const deferred: Deferred<string> = new Deferred<string>();\r\n\r\n        // Enumerate the media devices.\r\n        navigator.mediaDevices.enumerateDevices().then((devices: MediaDeviceInfo[]) => {\r\n            for (const device of devices) {\r\n                if (device.deviceId === microphoneDeviceId) {\r\n                    // Found the device\r\n                    this.privMicrophoneLabel = device.label;\r\n                    break;\r\n                }\r\n            }\r\n            deferred.resolve(this.privMicrophoneLabel);\r\n        }, () => deferred.resolve(this.privMicrophoneLabel));\r\n\r\n        return deferred.promise();\r\n    }\r\n\r\n    private listen = (audioNodeId: string): Promise<Stream<ArrayBuffer>> => {\r\n        return this.turnOn()\r\n            .onSuccessContinueWith<Stream<ArrayBuffer>>((_: boolean) => {\r\n                const stream = new ChunkedArrayBufferStream(this.privOutputChunkSize, audioNodeId);\r\n                this.privStreams[audioNodeId] = stream;\r\n\r\n                try {\r\n                    this.privRecorder.record(this.privContext, this.privMediaStream, stream);\r\n                } catch (error) {\r\n                    this.onEvent(new AudioStreamNodeErrorEvent(this.privId, audioNodeId, error));\r\n                    throw error;\r\n                }\r\n\r\n                return stream;\r\n            });\r\n    }\r\n\r\n    private onEvent = (event: AudioSourceEvent): void => {\r\n        this.privEvents.onEvent(event);\r\n        Events.instance.onEvent(event);\r\n    }\r\n\r\n    private createAudioContext = (): void => {\r\n        if (!!this.privContext) {\r\n            return;\r\n        }\r\n\r\n        // https://developer.mozilla.org/en-US/docs/Web/API/AudioContext\r\n        if (typeof (AudioContext) === \"undefined\") {\r\n            throw new Error(\"Browser does not support Web Audio API (AudioContext is not available).\");\r\n        }\r\n\r\n        // Browsers without sampleRate constraint support can't connect nodes with different sample rates\r\n        if (navigator.mediaDevices.getSupportedConstraints().sampleRate) {\r\n            this.privContext = new AudioContext({ sampleRate: MicAudioSource.AUDIOFORMAT.samplesPerSec });\r\n        } else {\r\n            this.privContext = new AudioContext();\r\n        }\r\n    }\r\n\r\n    private destroyAudioContext = (): void => {\r\n        if (!this.privContext) {\r\n            return;\r\n        }\r\n\r\n        this.privRecorder.releaseMediaResources(this.privContext);\r\n\r\n        // This pattern brought to you by a bug in the TypeScript compiler where it\r\n        // confuses the (\"close\" in this.privContext) with this.privContext always being null as the alternate.\r\n        // https://github.com/Microsoft/TypeScript/issues/11498\r\n        let hasClose: boolean = false;\r\n        if (\"close\" in this.privContext) {\r\n            hasClose = true;\r\n        }\r\n\r\n        if (hasClose) {\r\n            this.privContext.close();\r\n            this.privContext = null;\r\n        } else if (null !== this.privContext && this.privContext.state === \"running\") {\r\n            // Suspend actually takes a callback, but analogous to the\r\n            // resume method, it'll be only fired if suspend is called\r\n            // in a direct response to a user action. The later is not always\r\n            // the case, as TurnOff is also called, when we receive an\r\n            // end-of-speech message from the service. So, doing a best effort\r\n            // fire-and-forget here.\r\n            this.privContext.suspend();\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}